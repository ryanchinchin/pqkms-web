var ye=Object.defineProperty;var pe=(t,n,e)=>n in t?ye(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var G=(t,n,e)=>(pe(t,typeof n!="symbol"?n+"":n,e),e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ft=BigInt(0),vt=BigInt(1),me=BigInt(2);function K(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}const Ee=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function wt(t){if(!K(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=Ee[t[e]];return n}function te(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function $t(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}const Q={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function zt(t){if(t>=Q._0&&t<=Q._9)return t-Q._0;if(t>=Q._A&&t<=Q._F)return t-(Q._A-10);if(t>=Q._a&&t<=Q._f)return t-(Q._a-10)}function lt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length,e=n/2;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const r=new Uint8Array(e);for(let o=0,i=0;o<e;o++,i+=2){const s=zt(t.charCodeAt(i)),c=zt(t.charCodeAt(i+1));if(s===void 0||c===void 0){const f=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+f+'" at index '+i)}r[o]=s*16+c}return r}function X(t){return $t(wt(t))}function Vt(t){if(!K(t))throw new Error("Uint8Array expected");return $t(wt(Uint8Array.from(t).reverse()))}function F(t,n){return lt(t.toString(16).padStart(n*2,"0"))}function kt(t,n){return F(t,n).reverse()}function xe(t){return lt(te(t))}function M(t,n,e){let r;if(typeof n=="string")try{r=lt(n)}catch(i){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${i}`)}else if(K(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function P(...t){let n=0;for(let o=0;o<t.length;o++){const i=t[o];if(!K(i))throw new Error("Uint8Array expected");n+=i.length}let e=new Uint8Array(n),r=0;for(let o=0;o<t.length;o++){const i=t[o];e.set(i,r),r+=i.length}return e}function Be(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function ut(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ae(t){let n;for(n=0;t>Ft;t>>=vt,n+=1);return n}function Se(t,n){return t>>BigInt(n)&vt}const ve=(t,n,e)=>t|(e?vt:Ft)<<BigInt(n),Pt=t=>(me<<BigInt(t-1))-vt,Ut=t=>new Uint8Array(t),Mt=t=>Uint8Array.from(t);function ee(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ut(t),o=Ut(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...u)=>e(o,r,...u),f=(u=Ut())=>{o=c(Mt([0]),u),r=c(),u.length!==0&&(o=c(Mt([1]),u),r=c())},a=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const A=[];for(;u<n;){r=c();const v=r.slice();A.push(v),u+=r.length}return P(...A)};return(u,A)=>{s(),f(u);let v;for(;!(v=A(a()));)f();return s(),v}}const Ie={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||K(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function yt(t,n,e={}){const r=(o,i,s)=>{const c=Ie[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const f=t[o];if(!(s&&f===void 0)&&!c(f,t))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${i}`)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}const Ue=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Se,bitLen:Ae,bitMask:Pt,bitSet:ve,bytesToHex:wt,bytesToNumberBE:X,bytesToNumberLE:Vt,concatBytes:P,createHmacDrbg:ee,ensureBytes:M,equalBytes:Be,hexToBytes:lt,hexToNumber:$t,isBytes:K,numberToBytesBE:F,numberToBytesLE:kt,numberToHexUnpadded:te,numberToVarBytesBE:xe,utf8ToBytes:ut,validateObject:yt},Symbol.toStringTag,{value:"Module"})),Mn=t=>typeof t>"u";function Wn(t){if(!t)throw EvalError("Assertion failed")}function Yn(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),o=t.byteLength==n.byteLength,i=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let s=0;s<i;s++)o&&(o=e[s]===r[s]);return o}class Xn extends Error{constructor(n){super(n),this.name="ValidationError"}}class Qn extends Error{constructor(n){super(n),this.name="InvalidRequest"}}class Jn extends Error{constructor(e,r,o){const i=`Authentication failed for user '${r}', project '${o}'. Reason: ${e}`;super(i);G(this,"reason");G(this,"user_name");G(this,"domain");this.reason=e,this.user_name=r,this.domain=o,this.name="AuthenticationFailed"}}const Fn=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},_e=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),tr=function(t){let n=new Uint8Array(t);return btoa(Array.from(n,e=>String.fromCharCode(e)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},er=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),o=new DataView(r),i=0;return n==="little"?[...atob(t)].slice().reverse().forEach(s=>o.setUint8(i++,s.codePointAt(0))):[...atob(t)].forEach(s=>o.setUint8(i++,s.codePointAt(0))),r.slice(0,i)};function nr(){return(navigator.userAgent.indexOf("Opera")||navigator.userAgent.indexOf("OPR"))!=-1?"Opera":navigator.userAgent.indexOf("Edg")!=-1?"Edge":navigator.userAgent.indexOf("Chrome")!=-1?"Chrome":navigator.userAgent.indexOf("Safari")!=-1?"Safari":navigator.userAgent.indexOf("Firefox")!=-1?"Firefox":navigator.userAgent.indexOf("MSIE")!=-1?"MSIE":"Unknown"}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt(0),q=BigInt(1),ft=BigInt(2),He=BigInt(3),Rt=BigInt(4),Wt=BigInt(5),Yt=BigInt(8);BigInt(9);BigInt(16);function Z(t,n){const e=t%n;return e>=k?e:n+e}function Le(t,n,e){if(e<=k||n<k)throw new Error("Expected power/modulo > 0");if(e===q)return k;let r=q;for(;n>k;)n&q&&(r=r*t%e),t=t*t%e,n>>=q;return r}function Ct(t,n){if(t===k||n<=k)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=Z(t,n),r=n,o=k,i=q;for(;e!==k;){const c=r/e,f=r%e,a=o-i*c;r=e,e=f,o=i,i=a}if(r!==q)throw new Error("invert: does not exist");return Z(o,n)}function Oe(t){const n=(t-q)/ft;let e,r,o;for(e=t-q,r=0;e%ft===k;e/=ft,r++);for(o=ft;o<t&&Le(o,n,t)!==t-q;o++);if(r===1){const s=(t+q)/Rt;return function(f,a){const p=f.pow(a,s);if(!f.eql(f.sqr(p),a))throw new Error("Cannot find square root");return p}}const i=(e+q)/ft;return function(c,f){if(c.pow(f,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,p=c.pow(c.mul(c.ONE,o),e),u=c.pow(f,i),A=c.pow(f,e);for(;!c.eql(A,c.ONE);){if(c.eql(A,c.ZERO))return c.ZERO;let v=1;for(let l=c.sqr(A);v<a&&!c.eql(l,c.ONE);v++)l=c.sqr(l);const y=c.pow(p,q<<BigInt(a-v-1));p=c.sqr(y),u=c.mul(u,y),A=c.mul(A,p),a=v}return u}}function Re(t){if(t%Rt===He){const n=(t+q)/Rt;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%Yt===Wt){const n=(t-Wt)/Yt;return function(r,o){const i=r.mul(o,ft),s=r.pow(i,n),c=r.mul(o,s),f=r.mul(r.mul(c,ft),s),a=r.mul(c,r.sub(f,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Oe(t)}const Ce=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ne(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Ce.reduce((r,o)=>(r[o]="function",r),n);return yt(t,e)}function Te(t,n,e){if(e<k)throw new Error("Expected power > 0");if(e===k)return t.ONE;if(e===q)return n;let r=t.ONE,o=n;for(;e>k;)e&q&&(r=t.mul(r,o)),o=t.sqr(o),e>>=q;return r}function qe(t,n){const e=new Array(n.length),r=n.reduce((i,s,c)=>t.is0(s)?i:(e[c]=i,t.mul(i,s)),t.ONE),o=t.inv(r);return n.reduceRight((i,s,c)=>t.is0(s)?i:(e[c]=t.mul(i,e[c]),t.mul(i,s)),o),e}function re(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function oe(t,n,e=!1,r={}){if(t<=k)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=re(t,n);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Re(t),c=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:Pt(o),ZERO:k,ONE:q,create:f=>Z(f,t),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return k<=f&&f<t},is0:f=>f===k,isOdd:f=>(f&q)===q,neg:f=>Z(-f,t),eql:(f,a)=>f===a,sqr:f=>Z(f*f,t),add:(f,a)=>Z(f+a,t),sub:(f,a)=>Z(f-a,t),mul:(f,a)=>Z(f*a,t),pow:(f,a)=>Te(c,f,a),div:(f,a)=>Z(f*Ct(a,t),t),sqrN:f=>f*f,addN:(f,a)=>f+a,subN:(f,a)=>f-a,mulN:(f,a)=>f*a,inv:f=>Ct(f,t),sqrt:r.sqrt||(f=>s(c,f)),invertBatch:f=>qe(c,f),cmov:(f,a,p)=>p?a:f,toBytes:f=>e?kt(f,i):F(f,i),fromBytes:f=>{if(f.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${f.length}`);return e?Vt(f):X(f)}});return Object.freeze(c)}function ie(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function se(t){const n=ie(t);return n+Math.ceil(n/2)}function Ne(t,n,e=!1){const r=t.length,o=ie(n),i=se(n);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const s=e?X(t):Vt(t),c=Z(s,n-q)+q;return e?kt(c,o):F(c,o)}function _t(t,n){let e=F(t,n);return btoa(Array.from(e,r=>String.fromCharCode(r)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}class mt extends Error{constructor(e){super(e);G(this,"error_type");this.error_type=e}err(){return this.error_type}}function J(t){return typeof t=="string"?ut(t):t}var Tt;(function(t){t[t.OPRF=0]="OPRF",t[t.VOPRF=1]="VOPRF",t[t.POPRF=2]="POPRF"})(Tt||(Tt={}));function $e(t){let n=new Uint8Array(2);return n[0]=t,n[1]=45,n}class Ve{constructor(n,e){G(this,"EcGroup");G(this,"Fq");G(this,"hashToCurve");G(this,"coordinateSize");this.EcGroup=n,this.Fq=oe(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}curveName(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P-256";if(n===384)return"P-384";if(n===521)return"P-521";throw new mt("UnknownCurveType")}hashAlgo(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"SHA-256";if(n===384)return"SHA-384";if(n===521)return"SHA-512";throw new mt("UnknownCurveType")}cipersuiteId(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P256-SHA256";if(n===384)return"P384-SHA384";if(n===521)return"P521-SHA512";throw new mt("UnknownCurveType")}contextString(n){this.EcGroup.CURVE.Fp.BITS;let e=ut("HashToGroup-OPRFV1-"),r=$e(n),o=ut(this.cipersuiteId());return P(e,r,o)}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=X(e);if(r===BigInt(0))return this.blind(n);let o=J(n);const i={DST:this.contextString(Tt.OPRF)};let s=this.hashToCurve(o,i);this.EcGroup.ProjectivePoint.fromAffine(s.toAffine());let c=s.multiply(r);if(c.equals(this.EcGroup.ProjectivePoint.ZERO))throw new mt("HashedToInifinity");let f=this.EcGroup.ProjectivePoint.fromAffine(c.toAffine());return{hashed_password:n,blinder:r,clientRequestBytes:f.toHex(!1)}}async finalize(n,e){const r=globalThis.crypto.subtle;let o=this.EcGroup.ProjectivePoint.fromHex(n);if(o.assertValidity(),o.toHex(!1)===e.clientRequestBytes)throw Error("Server tried to attack the client during OPRF finalize step by replaying the client's request");let s=this.Fq.inv(e.blinder),c=o.multiply(s).toRawBytes(!0);const f=P(F(e.hashed_password.length,2),J(e.hashed_password),F(c.length,2),c,J("Finalize")),a=await r.digest(this.hashAlgo(),f);return r.importKey("raw",a,"HKDF",!1,["deriveBits","deriveKey"])}async login_key(n,e){const r=this.EcGroup.CURVE,o=this.EcGroup.ProjectivePoint,i=globalThis.crypto.subtle,s=P(J(e),J("LoginKeySalt")),c=J("LoginKey"),f=await i.deriveBits({name:"HKDF",hash:"SHA-512",salt:s.buffer,info:c.buffer},n,8*(3*r.nByteLength/2));let a=X(new Uint8Array(f)),p=Z(a,r.n),u=o.fromPrivateKey(p),A={crv:this.curveName(),d:_t(p,r.nByteLength),ext:!0,key_ops:["sign"],kty:"EC",x:_t(u.x,r.Fp.BYTES),y:_t(u.y,r.Fp.BYTES)};return{loginKey:await i.importKey("jwk",A,{name:"ECDSA",namedCurve:this.curveName()},!0,["sign"]),publicKey:u.toRawBytes(!1)}}async lockbox_key(n,e){const r=globalThis.crypto.subtle,o=P(J(e),J("LockboxSalt")),i=J("LockboxKey");return r.deriveKey({name:"HKDF",hash:"SHA-256",salt:o.buffer,info:i.buffer},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}}function Xt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function ke(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function ce(t,...n){if(!ke(t))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function Pe(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Xt(t.outputLen),Xt(t.blockLen)}function At(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Ze(t,n){ce(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Ht=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function fe(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}const Lt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),De=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!De)throw new Error("Non little-endian hardware is not supported");function je(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Zt(t){if(typeof t=="string"&&(t=je(t)),!fe(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Ge(...t){let n=0;for(let r=0;r<t.length;r++){const o=t[r];if(!fe(o))throw new Error("Uint8Array expected");n+=o.length}const e=new Uint8Array(n);for(let r=0,o=0;r<t.length;r++){const i=t[r];e.set(i,o),o+=i.length}return e}class ae{clone(){return this._cloneInto()}}function Ke(t){const n=r=>t().update(Zt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function ze(t=32){if(Ht&&typeof Ht.getRandomValues=="function")return Ht.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class le extends ae{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Pe(n);const r=Zt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=n.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(n){return At(this),this.iHash.update(n),this}digestInto(n){At(this),ce(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=s,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ue=(t,n,e)=>new le(t,n).update(e).digest();ue.create=(t,n)=>new le(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Me=BigInt(0),Ot=BigInt(1);function We(t,n){const e=(o,i)=>{const s=i.negate();return o?s:i},r=o=>{const i=Math.ceil(n/o)+1,s=2**(o-1);return{windows:i,windowSize:s}};return{constTimeNegate:e,unsafeLadder(o,i){let s=t.ZERO,c=o;for(;i>Me;)i&Ot&&(s=s.add(c)),c=c.double(),i>>=Ot;return s},precomputeWindow(o,i){const{windows:s,windowSize:c}=r(i),f=[];let a=o,p=a;for(let u=0;u<s;u++){p=a,f.push(p);for(let A=1;A<c;A++)p=p.add(a),f.push(p);a=p.double()}return f},wNAF(o,i,s){const{windows:c,windowSize:f}=r(o);let a=t.ZERO,p=t.BASE;const u=BigInt(2**o-1),A=2**o,v=BigInt(o);for(let y=0;y<c;y++){const l=y*f;let h=Number(s&u);s>>=v,h>f&&(h-=A,s+=Ot);const d=l,w=l+Math.abs(h)-1,g=y%2!==0,S=h<0;h===0?p=p.add(e(g,i[d])):a=a.add(e(S,i[w]))}return{p:a,f:p}},wNAFCached(o,i,s,c){const f=o._WINDOW_SIZE||1;let a=i.get(o);return a||(a=this.precomputeWindow(o,f),f!==1&&i.set(o,c(a))),this.wNAF(f,a,s)}}}function he(t){return ne(t.Fp),yt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...re(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ye(t){const n=he(t);yt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Xe,hexToBytes:Qe}=Ue,at={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=at;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:Xe(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=at,e=typeof t=="string"?Qe(t):t;if(!K(e))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:i}=at._parseInt(e.subarray(2)),{d:s,l:c}=at._parseInt(i);if(c.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,e=a=>{const p=a.toString(16);return p.length&1?`0${p}`:p},r=n(e(t.s)),o=n(e(t.r)),i=r.length/2,s=o.length/2,c=e(i),f=e(s);return`30${e(s+i+4)}02${f}${o}02${c}${r}`}},W=BigInt(0),T=BigInt(1),rt=BigInt(2),St=BigInt(3),Qt=BigInt(4);function Je(t){const n=Ye(t),{Fp:e}=n,r=n.toBytes||((y,l,h)=>{const d=l.toAffine();return P(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(y=>{const l=y.subarray(1),h=e.fromBytes(l.subarray(0,e.BYTES)),d=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function i(y){const{a:l,b:h}=n,d=e.sqr(y),w=e.mul(d,y);return e.add(e.add(w,e.mul(y,l)),h)}if(!e.eql(e.sqr(n.Gy),i(n.Gx)))throw new Error("bad generator point: equation left != right");function s(y){return typeof y=="bigint"&&W<y&&y<n.n}function c(y){if(!s(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(y){const{allowedPrivateKeyLengths:l,nByteLength:h,wrapPrivateKey:d,n:w}=n;if(l&&typeof y!="bigint"){if(K(y)&&(y=wt(y)),typeof y!="string"||!l.includes(y.length))throw new Error("Invalid key");y=y.padStart(h*2,"0")}let g;try{g=typeof y=="bigint"?y:X(M("private key",y,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof y}`)}return d&&(g=Z(g,w)),c(g),g}const a=new Map;function p(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,h,d){if(this.px=l,this.py=h,this.pz=d,l==null||!e.isValid(l))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(l){const{x:h,y:d}=l||{};if(!l||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const w=g=>e.eql(g,e.ZERO);return w(h)&&w(d)?u.ZERO:new u(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const h=e.invertBatch(l.map(d=>d.pz));return l.map((d,w)=>d.toAffine(h[w])).map(u.fromAffine)}static fromHex(l){const h=u.fromAffine(o(M("pointHex",l)));return h.assertValidity(),h}static fromPrivateKey(l){return u.BASE.multiply(f(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:h}=this.toAffine();if(!e.isValid(l)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),w=i(l);if(!e.eql(d,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){p(l);const{px:h,py:d,pz:w}=this,{px:g,py:S,pz:I}=l,E=e.eql(e.mul(h,I),e.mul(g,w)),x=e.eql(e.mul(d,I),e.mul(S,w));return E&&x}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){const{a:l,b:h}=n,d=e.mul(h,St),{px:w,py:g,pz:S}=this;let I=e.ZERO,E=e.ZERO,x=e.ZERO,B=e.mul(w,w),R=e.mul(g,g),L=e.mul(S,S),H=e.mul(w,g);return H=e.add(H,H),x=e.mul(w,S),x=e.add(x,x),I=e.mul(l,x),E=e.mul(d,L),E=e.add(I,E),I=e.sub(R,E),E=e.add(R,E),E=e.mul(I,E),I=e.mul(H,I),x=e.mul(d,x),L=e.mul(l,L),H=e.sub(B,L),H=e.mul(l,H),H=e.add(H,x),x=e.add(B,B),B=e.add(x,B),B=e.add(B,L),B=e.mul(B,H),E=e.add(E,B),L=e.mul(g,S),L=e.add(L,L),B=e.mul(L,H),I=e.sub(I,B),x=e.mul(L,R),x=e.add(x,x),x=e.add(x,x),new u(I,E,x)}add(l){p(l);const{px:h,py:d,pz:w}=this,{px:g,py:S,pz:I}=l;let E=e.ZERO,x=e.ZERO,B=e.ZERO;const R=n.a,L=e.mul(n.b,St);let H=e.mul(h,g),N=e.mul(d,S),V=e.mul(w,I),Y=e.add(h,d),b=e.add(g,S);Y=e.mul(Y,b),b=e.add(H,N),Y=e.sub(Y,b),b=e.add(h,w);let m=e.add(g,I);return b=e.mul(b,m),m=e.add(H,V),b=e.sub(b,m),m=e.add(d,w),E=e.add(S,I),m=e.mul(m,E),E=e.add(N,V),m=e.sub(m,E),B=e.mul(R,b),E=e.mul(L,V),B=e.add(E,B),E=e.sub(N,B),B=e.add(N,B),x=e.mul(E,B),N=e.add(H,H),N=e.add(N,H),V=e.mul(R,V),b=e.mul(L,b),N=e.add(N,V),V=e.sub(H,V),V=e.mul(R,V),b=e.add(b,V),H=e.mul(N,b),x=e.add(x,H),H=e.mul(m,b),E=e.mul(Y,E),E=e.sub(E,H),H=e.mul(Y,N),B=e.mul(m,B),B=e.add(B,H),new u(E,x,B)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return v.wNAFCached(this,a,l,h=>{const d=e.invertBatch(h.map(w=>w.pz));return h.map((w,g)=>w.toAffine(d[g])).map(u.fromAffine)})}multiplyUnsafe(l){const h=u.ZERO;if(l===W)return h;if(c(l),l===T)return this;const{endo:d}=n;if(!d)return v.unsafeLadder(this,l);let{k1neg:w,k1:g,k2neg:S,k2:I}=d.splitScalar(l),E=h,x=h,B=this;for(;g>W||I>W;)g&T&&(E=E.add(B)),I&T&&(x=x.add(B)),B=B.double(),g>>=T,I>>=T;return w&&(E=E.negate()),S&&(x=x.negate()),x=new u(e.mul(x.px,d.beta),x.py,x.pz),E.add(x)}multiply(l){c(l);let h=l,d,w;const{endo:g}=n;if(g){const{k1neg:S,k1:I,k2neg:E,k2:x}=g.splitScalar(h);let{p:B,f:R}=this.wNAF(I),{p:L,f:H}=this.wNAF(x);B=v.constTimeNegate(S,B),L=v.constTimeNegate(E,L),L=new u(e.mul(L.px,g.beta),L.py,L.pz),d=B.add(L),w=R.add(H)}else{const{p:S,f:I}=this.wNAF(h);d=S,w=I}return u.normalizeZ([d,w])[0]}multiplyAndAddUnsafe(l,h,d){const w=u.BASE,g=(I,E)=>E===W||E===T||!I.equals(w)?I.multiplyUnsafe(E):I.multiply(E),S=g(this,h).add(g(l,d));return S.is0()?void 0:S}toAffine(l){const{px:h,py:d,pz:w}=this,g=this.is0();l==null&&(l=g?e.ONE:e.inv(w));const S=e.mul(h,l),I=e.mul(d,l),E=e.mul(w,l);if(g)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:S,y:I}}isTorsionFree(){const{h:l,isTorsionFree:h}=n;if(l===T)return!0;if(h)return h(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:h}=n;return l===T?this:h?h(u,this):this.multiplyUnsafe(n.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return wt(this.toRawBytes(l))}}u.BASE=new u(n.Gx,n.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);const A=n.nBitLength,v=We(u,n.endo?Math.ceil(A/2):A);return{CURVE:n,ProjectivePoint:u,normPrivateKeyToScalar:f,weierstrassEquation:i,isWithinCurveOrder:s}}function Fe(t){const n=he(t);return yt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function tn(t){const n=Fe(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function s(b){return W<b&&b<e.ORDER}function c(b){return Z(b,r)}function f(b){return Ct(b,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:p,weierstrassEquation:u,isWithinCurveOrder:A}=Je({...n,toBytes(b,m,_){const C=m.toAffine(),O=e.toBytes(C.x),$=P;return _?$(Uint8Array.from([m.hasEvenY()?2:3]),O):$(Uint8Array.from([4]),O,e.toBytes(C.y))},fromBytes(b){const m=b.length,_=b[0],C=b.subarray(1);if(m===o&&(_===2||_===3)){const O=X(C);if(!s(O))throw new Error("Point is not on curve");const $=u(O);let D=e.sqrt($);const j=(D&T)===T;return(_&1)===1!==j&&(D=e.neg(D)),{x:O,y:D}}else if(m===i&&_===4){const O=e.fromBytes(C.subarray(0,e.BYTES)),$=e.fromBytes(C.subarray(e.BYTES,2*e.BYTES));return{x:O,y:$}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}}),v=b=>wt(F(b,n.nByteLength));function y(b){const m=r>>T;return b>m}function l(b){return y(b)?c(-b):b}const h=(b,m,_)=>X(b.slice(m,_));class d{constructor(m,_,C){this.r=m,this.s=_,this.recovery=C,this.assertValidity()}static fromCompact(m){const _=n.nByteLength;return m=M("compactSignature",m,_*2),new d(h(m,0,_),h(m,_,2*_))}static fromDER(m){const{r:_,s:C}=at.toSig(M("DER",m));return new d(_,C)}assertValidity(){if(!A(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!A(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:_,s:C,recovery:O}=this,$=x(M("msgHash",m));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const D=O===2||O===3?_+n.n:_;if(D>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=O&1?"03":"02",tt=a.fromHex(j+v(D)),et=f(D),ht=c(-$*et),pt=c(C*et),nt=a.BASE.multiplyAndAddUnsafe(tt,ht,pt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return lt(this.toDERHex())}toDERHex(){return at.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return lt(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}const w={isValidPrivateKey(b){try{return p(b),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const b=se(n.n);return Ne(n.randomBytes(b),n.n)},precompute(b=8,m=a.BASE){return m._setWindowSize(b),m.multiply(BigInt(3)),m}};function g(b,m=!0){return a.fromPrivateKey(b).toRawBytes(m)}function S(b){const m=K(b),_=typeof b=="string",C=(m||_)&&b.length;return m?C===o||C===i:_?C===2*o||C===2*i:b instanceof a}function I(b,m,_=!0){if(S(b))throw new Error("first arg must be private key");if(!S(m))throw new Error("second arg must be public key");return a.fromHex(m).multiply(p(b)).toRawBytes(_)}const E=n.bits2int||function(b){const m=X(b),_=b.length*8-n.nBitLength;return _>0?m>>BigInt(_):m},x=n.bits2int_modN||function(b){return c(E(b))},B=Pt(n.nBitLength);function R(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(W<=b&&b<B))throw new Error(`bigint expected < 2^${n.nBitLength}`);return F(b,n.nByteLength)}function L(b,m,_=H){if(["recovered","canonical"].some(ct=>ct in _))throw new Error("sign() legacy options not supported");const{hash:C,randomBytes:O}=n;let{lowS:$,prehash:D,extraEntropy:j}=_;$==null&&($=!0),b=M("msgHash",b),D&&(b=M("prehashed msgHash",C(b)));const tt=x(b),et=p(m),ht=[R(et),R(tt)];if(j!=null){const ct=j===!0?O(e.BYTES):j;ht.push(M("extraEntropy",ct))}const pt=P(...ht),nt=tt;function It(ct){const dt=E(ct);if(!A(dt))return;const jt=f(dt),gt=a.BASE.multiply(dt).toAffine(),z=c(gt.x);if(z===W)return;const bt=c(jt*c(nt+z*et));if(bt===W)return;let Gt=(gt.x===z?0:2)|Number(gt.y&T),Kt=bt;return $&&y(bt)&&(Kt=l(bt),Gt^=1),new d(z,Kt,Gt)}return{seed:pt,k2sig:It}}const H={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function V(b,m,_=H){const{seed:C,k2sig:O}=L(b,m,_),$=n;return ee($.hash.outputLen,$.nByteLength,$.hmac)(C,O)}a.BASE._setWindowSize(8);function Y(b,m,_,C=N){var gt;const O=b;if(m=M("msgHash",m),_=M("publicKey",_),"strict"in C)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:D}=C;let j,tt;try{if(typeof O=="string"||K(O))try{j=d.fromDER(O)}catch(z){if(!(z instanceof at.Err))throw z;j=d.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:z,s:bt}=O;j=new d(z,bt)}else throw new Error("PARSE");tt=a.fromHex(_)}catch(z){if(z.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;D&&(m=n.hash(m));const{r:et,s:ht}=j,pt=x(m),nt=f(ht),It=c(pt*nt),ct=c(et*nt),dt=(gt=a.BASE.multiplyAndAddUnsafe(tt,It,ct))==null?void 0:gt.toAffine();return dt?c(dt.x)===et:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:I,sign:V,verify:Y,ProjectivePoint:a,Signature:d,utils:w}}function en(t,n){const e=t.ORDER;let r=W;for(let y=e-T;y%rt===W;y/=rt)r+=T;const o=r,i=rt<<o-T-T,s=i*rt,c=(e-T)/s,f=(c-T)/rt,a=s-T,p=i,u=t.pow(n,c),A=t.pow(n,(c+T)/rt);let v=(y,l)=>{let h=u,d=t.pow(l,a),w=t.sqr(d);w=t.mul(w,l);let g=t.mul(y,w);g=t.pow(g,f),g=t.mul(g,d),d=t.mul(g,l),w=t.mul(g,y);let S=t.mul(w,d);g=t.pow(S,p);let I=t.eql(g,t.ONE);d=t.mul(w,A),g=t.mul(S,h),w=t.cmov(d,w,I),S=t.cmov(g,S,I);for(let E=o;E>T;E--){let x=E-rt;x=rt<<x-T;let B=t.pow(S,x);const R=t.eql(B,t.ONE);d=t.mul(w,h),h=t.mul(h,h),B=t.mul(S,h),w=t.cmov(d,w,R),S=t.cmov(B,S,R)}return{isValid:I,value:w}};if(t.ORDER%Qt===St){const y=(t.ORDER-St)/Qt,l=t.sqrt(t.neg(n));v=(h,d)=>{let w=t.sqr(d);const g=t.mul(h,d);w=t.mul(w,g);let S=t.pow(w,y);S=t.mul(S,g);const I=t.mul(S,l),E=t.mul(t.sqr(S),d),x=t.eql(E,h);let B=t.cmov(I,S,x);return{isValid:x,value:B}}}return v}function nn(t,n){if(ne(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=en(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,s,c,f,a,p,u;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,n.B),c=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),c=t.mul(c,n.A),i=t.sqr(s),a=t.sqr(c),f=t.mul(a,n.A),i=t.add(i,f),i=t.mul(i,s),a=t.mul(a,c),f=t.mul(a,n.B),i=t.add(i,f),p=t.mul(o,s);const{isValid:A,value:v}=e(i,a);u=t.mul(o,r),u=t.mul(u,v),p=t.cmov(p,s,A),u=t.cmov(u,v,A);const y=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,y),p=t.div(p,c),{x:p,y:u}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function rn(t){return{hash:t,hmac:(n,...e)=>ue(t,n,Ge(...e)),randomBytes:ze}}function on(t,n){const e=r=>tn({...t,...rn(r)});return Object.freeze({...e(n),create:e})}function sn(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(e>>o&i),c=Number(e&i),f=r?4:0,a=r?0:4;t.setUint32(n+f,s,r),t.setUint32(n+a,c,r)}class cn extends ae{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Lt(this.buffer)}update(n){At(this);const{view:e,buffer:r,blockLen:o}=this;n=Zt(n);const i=n.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const f=Lt(n);for(;o<=i-s;s+=o)this.process(f,s);continue}r.set(n.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){At(this),Ze(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let u=s;u<o;u++)e[u]=0;sn(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=Lt(n),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,p=this.get();if(a>p.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)c.setUint32(4*u,p[u],i)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return n.length=o,n.pos=c,n.finished=i,n.destroyed=s,o%e&&n.buffer.set(r),n}}const Bt=BigInt(2**32-1),qt=BigInt(32);function de(t,n=!1){return n?{h:Number(t&Bt),l:Number(t>>qt&Bt)}:{h:Number(t>>qt&Bt)|0,l:Number(t&Bt)|0}}function fn(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=de(t[o],n);[e[o],r[o]]=[i,s]}return[e,r]}const an=(t,n)=>BigInt(t>>>0)<<qt|BigInt(n>>>0),ln=(t,n,e)=>t>>>e,un=(t,n,e)=>t<<32-e|n>>>e,hn=(t,n,e)=>t>>>e|n<<32-e,dn=(t,n,e)=>t<<32-e|n>>>e,gn=(t,n,e)=>t<<64-e|n>>>e-32,bn=(t,n,e)=>t>>>e-32|n<<64-e,wn=(t,n)=>n,yn=(t,n)=>t,pn=(t,n,e)=>t<<e|n>>>32-e,mn=(t,n,e)=>n<<e|t>>>32-e,En=(t,n,e)=>n<<e-32|t>>>64-e,xn=(t,n,e)=>t<<e-32|n>>>64-e;function Bn(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const An=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),Sn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,vn=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),In=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,Un=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),_n=(t,n,e,r,o,i)=>n+e+r+o+i+(t/2**32|0)|0,Hn={fromBig:de,split:fn,toBig:an,shrSH:ln,shrSL:un,rotrSH:hn,rotrSL:dn,rotrBH:gn,rotrBL:bn,rotr32H:wn,rotr32L:yn,rotlSH:pn,rotlSL:mn,rotlBH:En,rotlBL:xn,add:Bn,add3L:An,add3H:Sn,add4L:vn,add4H:In,add5H:_n,add5L:Un},U=Hn,[Ln,On]=(()=>U.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),ot=new Uint32Array(80),it=new Uint32Array(80);class Rn extends cn{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:i,Cl:s,Dh:c,Dl:f,Eh:a,El:p,Fh:u,Fl:A,Gh:v,Gl:y,Hh:l,Hl:h}=this;return[n,e,r,o,i,s,c,f,a,p,u,A,v,y,l,h]}set(n,e,r,o,i,s,c,f,a,p,u,A,v,y,l,h){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=i|0,this.Cl=s|0,this.Dh=c|0,this.Dl=f|0,this.Eh=a|0,this.El=p|0,this.Fh=u|0,this.Fl=A|0,this.Gh=v|0,this.Gl=y|0,this.Hh=l|0,this.Hl=h|0}process(n,e){for(let g=0;g<16;g++,e+=4)ot[g]=n.getUint32(e),it[g]=n.getUint32(e+=4);for(let g=16;g<80;g++){const S=ot[g-15]|0,I=it[g-15]|0,E=U.rotrSH(S,I,1)^U.rotrSH(S,I,8)^U.shrSH(S,I,7),x=U.rotrSL(S,I,1)^U.rotrSL(S,I,8)^U.shrSL(S,I,7),B=ot[g-2]|0,R=it[g-2]|0,L=U.rotrSH(B,R,19)^U.rotrBH(B,R,61)^U.shrSH(B,R,6),H=U.rotrSL(B,R,19)^U.rotrBL(B,R,61)^U.shrSL(B,R,6),N=U.add4L(x,H,it[g-7],it[g-16]),V=U.add4H(N,E,L,ot[g-7],ot[g-16]);ot[g]=V|0,it[g]=N|0}let{Ah:r,Al:o,Bh:i,Bl:s,Ch:c,Cl:f,Dh:a,Dl:p,Eh:u,El:A,Fh:v,Fl:y,Gh:l,Gl:h,Hh:d,Hl:w}=this;for(let g=0;g<80;g++){const S=U.rotrSH(u,A,14)^U.rotrSH(u,A,18)^U.rotrBH(u,A,41),I=U.rotrSL(u,A,14)^U.rotrSL(u,A,18)^U.rotrBL(u,A,41),E=u&v^~u&l,x=A&y^~A&h,B=U.add5L(w,I,x,On[g],it[g]),R=U.add5H(B,d,S,E,Ln[g],ot[g]),L=B|0,H=U.rotrSH(r,o,28)^U.rotrBH(r,o,34)^U.rotrBH(r,o,39),N=U.rotrSL(r,o,28)^U.rotrBL(r,o,34)^U.rotrBL(r,o,39),V=r&i^r&c^i&c,Y=o&s^o&f^s&f;d=l|0,w=h|0,l=v|0,h=y|0,v=u|0,y=A|0,{h:u,l:A}=U.add(a|0,p|0,R|0,L|0),a=c|0,p=f|0,c=i|0,f=s|0,i=r|0,s=o|0;const b=U.add3L(L,N,Y);r=U.add3H(b,R,H,V),o=b|0}({h:r,l:o}=U.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:i,l:s}=U.add(this.Bh|0,this.Bl|0,i|0,s|0),{h:c,l:f}=U.add(this.Ch|0,this.Cl|0,c|0,f|0),{h:a,l:p}=U.add(this.Dh|0,this.Dl|0,a|0,p|0),{h:u,l:A}=U.add(this.Eh|0,this.El|0,u|0,A|0),{h:v,l:y}=U.add(this.Fh|0,this.Fl|0,v|0,y|0),{h:l,l:h}=U.add(this.Gh|0,this.Gl|0,l|0,h|0),{h:d,l:w}=U.add(this.Hh|0,this.Hl|0,d|0,w|0),this.set(r,o,i,s,c,f,a,p,u,A,v,y,l,h,d,w)}roundClean(){ot.fill(0),it.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Cn extends Rn{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const ge=Ke(()=>new Cn);function Tn(t){if(K(t))return t;if(typeof t=="string")return ut(t);throw new Error("DST must be Uint8Array or string")}const qn=X;function st(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Nn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Et(t){if(!K(t))throw new Error("Uint8Array expected")}function Dt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function $n(t,n,e,r){Et(t),Et(n),Dt(e),n.length>255&&(n=r(P(ut("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(e/o);if(s>255)throw new Error("Invalid xmd length");const c=P(n,st(n.length,1)),f=st(0,i),a=st(e,2),p=new Array(s),u=r(P(f,t,a,st(0,1),c));p[0]=r(P(u,st(1,1),c));for(let v=1;v<=s;v++){const y=[Nn(u,p[v-1]),st(v+1,1),c];p[v]=r(P(...y))}return P(...p).slice(0,e)}function Vn(t,n,e,r,o){if(Et(t),Et(n),Dt(e),n.length>255){const i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(ut("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(st(e,2)).update(n).update(st(n.length,1)).digest()}function Jt(t,n,e){yt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:c,DST:f}=e;Et(t),Dt(n);const a=Tn(f),p=r.toString(2).length,u=Math.ceil((p+o)/8),A=n*i*u;let v;if(c==="xmd")v=$n(t,a,A,s);else if(c==="xof")v=Vn(t,a,A,o,s);else if(c==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(n);for(let l=0;l<n;l++){const h=new Array(i);for(let d=0;d<i;d++){const w=u*(d+l*i),g=v.subarray(w,w+u);h[d]=Z(qn(g),r)}y[l]=h}return y}function kn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=Jt(r,2,{...e,DST:e.DST,...o}),s=t.fromAffine(n(i[0])),c=t.fromAffine(n(i[1])),f=s.add(c).clearCofactor();return f.assertValidity(),f},encodeToCurve(r,o){const i=Jt(r,1,{...e,DST:e.encodeDST,...o}),s=t.fromAffine(n(i[0])).clearCofactor();return s.assertValidity(),s}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Pn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),xt=oe(Pn),be=xt.create(BigInt("-3")),we=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Nt=on({a:be,b:we,Fp:xt,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},ge),Zn=Nt,Dn=(()=>nn(xt,{A:be,B:we,Z:xt.create(BigInt("-12"))}))(),jn=(()=>kn(Zn.ProjectivePoint,t=>Dn(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:xt.ORDER,m:1,k:192,expand:"xmd",hash:ge}))(),Gn=(()=>jn.hashToCurve)();class or{constructor(n){G(this,"discoveryURL");G(this,"baseURL");G(this,"oprfClient");G(this,"oprfClientData",null);if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto");this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new Ve(Nt,Gn)}async computeOprfClientData(n,e){try{e.salt||(e.salt=_e(globalThis.crypto.getRandomValues(new Uint8Array(32))));const r=await Kn(n,e,Nt.CURVE.nByteLength);return this.oprfClientData=this.oprfClient.blind(r),this.oprfClientData}catch(r){if(r instanceof mt&&r.err()=="HashedToInifinity")return this.computeOprfClientData(n,e);throw r}}async parseServerResponse(n){if(n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`${e.message}`)}else{const e=await n.json();throw new Error(`${JSON.stringify(e)}`)}}async fetchUserInfo(n,e,r){const o=await this.fetchDirectory();let i=`${this.discoveryURL}${o.user_info}?user_name=${n}`;e&&(i=`${i}&domain=${e}`),r&&(i=`${i}&domain=${r}`);const s=await fetch(i,{keepalive:!0,mode:"cors",cache:"no-store"});return this.parseServerResponse(s)}}async function Kn(t,n,e){const r=t+n.domain_name+n.user_name+t,o=await globalThis.crypto.subtle.importKey("raw",new TextEncoder().encode(r),{name:"PBKDF2"},!1,["deriveBits"]);let i=lt(n.salt),s=await globalThis.crypto.subtle.deriveBits({name:"PBKDF2",salt:i,iterations:6e5,hash:"SHA-256"},o,8*e);return new Uint8Array(s)}export{Jn as A,Qn as I,or as U,Xn as V,Wn as a,er as b,nr as c,P as d,Yn as e,Fn as f,tr as g,X as h,Mn as i,Z as m,xe as n,Le as p,_e as t,ut as u};

var Ee=Object.defineProperty;var ve=(t,n,e)=>n in t?Ee(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var z=(t,n,e)=>(ve(t,typeof n!="symbol"?n+"":n,e),e);(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function e(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=e(o);fetch(o.href,s)}})();const Se="modulepreload",Ae=function(t){return"/pqkms-web/"+t},jt={},Be=function(n,e,r){if(!e||e.length===0)return n();const o=document.getElementsByTagName("link");return Promise.all(e.map(s=>{if(s=Ae(s),s in jt)return;jt[s]=!0;const a=s.endsWith(".css"),i=a?'[rel="stylesheet"]':"";if(!!r)for(let w=o.length-1;w>=0;w--){const f=o[w];if(f.href===s&&(!a||f.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${s}"]${i}`))return;const l=document.createElement("link");if(l.rel=a?"stylesheet":Se,a||(l.as="script",l.crossOrigin=""),l.href=s,document.head.appendChild(l),a)return new Promise((w,f)=>{l.addEventListener("load",w),l.addEventListener("error",()=>f(new Error(`Unable to preload CSS for ${s}`)))})})).then(()=>n()).catch(s=>{const a=new Event("vite:preloadError",{cancelable:!0});if(a.payload=s,window.dispatchEvent(a),!a.defaultPrevented)throw s})},_e=function(){const t={argon2d:0,argon2i:1,argon2id:2};function n(i){if(n._promise)return n._promise;if(n._module)return Promise.resolve(n._module);let c=e().then(l=>new Promise(w=>{l.postRun.push(()=>w(l))}));return n._promise=c,c.then(l=>(n._module=l,delete n._promise,l))}function e(){return Be(()=>import("./argon2-89744aa5.js"),[]).then(i=>i.default)}function r(i,c){const l=c instanceof Uint8Array||c instanceof Array?c:o(c),w=new Uint8Array([...l,0]);return i.allocate(w,"i8",i.ALLOC_NORMAL)}function o(i){if(typeof TextEncoder=="function")return new TextEncoder().encode(i);if(typeof Buffer=="function")return Buffer.from(i);throw new Error("Don't know how to decode UTF8")}function s(i){const c=i.mem||1024;return n().then(l=>{const w=i.time||1,f=i.parallelism||1,x=r(l,i.pass),v=i.pass.length,b=r(l,i.salt),u=i.salt.length,h=l.allocate(new Array(i.hashLen||24),"i8",l.ALLOC_NORMAL),d=i.hashLen||24,m=l.allocate(new Array(512),"i8",l.ALLOC_NORMAL),g=512,B=i.type||t.argon2d,_=19;let p,S;try{S=l._argon2_hash(w,c,f,x,v,b,u,h,d,m,g,B,_)}catch(H){p=H}let A;if(S===0&&!p){let H="";const O=new Uint8Array(d);for(let C=0;C<d;C++){const N=l.HEAP8[h+C];O[C]=N,H+=("0"+(255&N).toString(16)).slice(-2)}const I=l.UTF8ToString(m);A={hash:O,hashHex:H,encoded:I}}else{try{p||(p=l.UTF8ToString(l._argon2_error_message(S)))}catch{}A={message:p,code:S}}try{l._free(x),l._free(b),l._free(h),l._free(m)}catch{}if(p)throw A;return A})}function a(i){return n().then(c=>{const l=r(c,i.pass),w=i.pass.length,f=r(c,i.encoded);let x=i.type;if(x===void 0){let h=i.encoded.split("$")[1];h&&(h=h.replace("a","A"),x=t[h]||t.argon2d)}let v,b;try{b=c._argon2_verify(f,l,w,x)}catch(h){v=h}let u;if(b||v){try{v||(v=c.UTF8ToString(c._argon2_error_message(b)))}catch{}u={message:v,code:b}}try{c._free(l),c._free(f)}catch{}if(v)throw u;return u})}return{ArgonType:t,hash:s,verify:a}}(),{ArgonType:Le,hash:Ue,verify:ur}=_e;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const te=BigInt(0),At=BigInt(1),Ie=BigInt(2),Bt=t=>t instanceof Uint8Array,He=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function lt(t){if(!Bt(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=He[t[e]];return n}function ee(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function qt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function wt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,s=t.slice(o,o+2),a=Number.parseInt(s,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");e[r]=a}return e}function X(t){return qt(lt(t))}function $t(t){if(!Bt(t))throw new Error("Uint8Array expected");return qt(lt(Uint8Array.from(t).reverse()))}function st(t,n){return wt(t.toString(16).padStart(n*2,"0"))}function Nt(t,n){return st(t,n).reverse()}function Oe(t){return wt(ee(t))}function W(t,n,e){let r;if(typeof n=="string")try{r=wt(n)}catch(s){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${s}`)}else if(Bt(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function j(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!Bt(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function Re(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function xt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Te(t){let n;for(n=0;t>te;t>>=At,n+=1);return n}function Ce(t,n){return t>>BigInt(n)&At}const qe=(t,n,e)=>t|(e?At:te)<<BigInt(n),Dt=t=>(Ie<<BigInt(t-1))-At,Lt=t=>new Uint8Array(t),Gt=t=>Uint8Array.from(t);function ne(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lt(t),o=Lt(t),s=0;const a=()=>{r.fill(1),o.fill(0),s=0},i=(...f)=>e(o,r,...f),c=(f=Lt())=>{o=i(Gt([0]),f),r=i(),f.length!==0&&(o=i(Gt([1]),f),r=i())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const x=[];for(;f<n;){r=i();const v=r.slice();x.push(v),f+=r.length}return j(...x)};return(f,x)=>{a(),c(f);let v;for(;!(v=x(l()));)c();return a(),v}}const $e={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function yt(t,n,e={}){const r=(o,s,a)=>{const i=$e[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(a&&c===void 0)&&!i(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}const Ne=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Ce,bitLen:Te,bitMask:Dt,bitSet:qe,bytesToHex:lt,bytesToNumberBE:X,bytesToNumberLE:$t,concatBytes:j,createHmacDrbg:ne,ensureBytes:W,equalBytes:Re,hexToBytes:wt,hexToNumber:qt,numberToBytesBE:st,numberToBytesLE:Nt,numberToHexUnpadded:ee,numberToVarBytesBE:Oe,utf8ToBytes:xt,validateObject:yt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const V=BigInt(0),$=BigInt(1),ct=BigInt(2),De=BigInt(3),Rt=BigInt(4),Wt=BigInt(5),Yt=BigInt(8);BigInt(9);BigInt(16);function P(t,n){const e=t%n;return e>=V?e:n+e}function Ve(t,n,e){if(e<=V||n<V)throw new Error("Expected power/modulo > 0");if(e===$)return V;let r=$;for(;n>V;)n&$&&(r=r*t%e),t=t*t%e,n>>=$;return r}function Tt(t,n){if(t===V||n<=V)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=P(t,n),r=n,o=V,s=$;for(;e!==V;){const i=r/e,c=r%e,l=o-s*i;r=e,e=c,o=s,s=l}if(r!==$)throw new Error("invert: does not exist");return P(o,n)}function ke(t){const n=(t-$)/ct;let e,r,o;for(e=t-$,r=0;e%ct===V;e/=ct,r++);for(o=ct;o<t&&Ve(o,n,t)!==t-$;o++);if(r===1){const a=(t+$)/Rt;return function(c,l){const w=c.pow(l,a);if(!c.eql(c.sqr(w),l))throw new Error("Cannot find square root");return w}}const s=(e+$)/ct;return function(i,c){if(i.pow(c,n)===i.neg(i.ONE))throw new Error("Cannot find square root");let l=r,w=i.pow(i.mul(i.ONE,o),e),f=i.pow(c,s),x=i.pow(c,e);for(;!i.eql(x,i.ONE);){if(i.eql(x,i.ZERO))return i.ZERO;let v=1;for(let u=i.sqr(x);v<l&&!i.eql(u,i.ONE);v++)u=i.sqr(u);const b=i.pow(w,$<<BigInt(l-v-1));w=i.sqr(b),f=i.mul(f,b),x=i.mul(x,w),l=v}return f}}function Ze(t){if(t%Rt===De){const n=(t+$)/Rt;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%Yt===Wt){const n=(t-Wt)/Yt;return function(r,o){const s=r.mul(o,ct),a=r.pow(s,n),i=r.mul(o,a),c=r.mul(r.mul(i,ct),a),l=r.mul(i,r.sub(c,r.ONE));if(!r.eql(r.sqr(l),o))throw new Error("Cannot find square root");return l}}return ke(t)}const Pe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function re(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Pe.reduce((r,o)=>(r[o]="function",r),n);return yt(t,e)}function ze(t,n,e){if(e<V)throw new Error("Expected power > 0");if(e===V)return t.ONE;if(e===$)return n;let r=t.ONE,o=n;for(;e>V;)e&$&&(r=t.mul(r,o)),o=t.sqr(o),e>>=$;return r}function je(t,n){const e=new Array(n.length),r=n.reduce((s,a,i)=>t.is0(a)?s:(e[i]=s,t.mul(s,a)),t.ONE),o=t.inv(r);return n.reduceRight((s,a,i)=>t.is0(a)?s:(e[i]=t.mul(s,e[i]),t.mul(s,a)),o),e}function oe(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function se(t,n,e=!1,r={}){if(t<=V)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=oe(t,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=Ze(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Dt(o),ZERO:V,ONE:$,create:c=>P(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return V<=c&&c<t},is0:c=>c===V,isOdd:c=>(c&$)===$,neg:c=>P(-c,t),eql:(c,l)=>c===l,sqr:c=>P(c*c,t),add:(c,l)=>P(c+l,t),sub:(c,l)=>P(c-l,t),mul:(c,l)=>P(c*l,t),pow:(c,l)=>ze(i,c,l),div:(c,l)=>P(c*Tt(l,t),t),sqrN:c=>c*c,addN:(c,l)=>c+l,subN:(c,l)=>c-l,mulN:(c,l)=>c*l,inv:c=>Tt(c,t),sqrt:r.sqrt||(c=>a(i,c)),invertBatch:c=>je(i,c),cmov:(c,l,w)=>w?l:c,toBytes:c=>e?Nt(c,s):st(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return e?$t(c):X(c)}});return Object.freeze(i)}function ie(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ce(t){const n=ie(t);return n+Math.ceil(n/2)}function Ge(t,n,e=!1){const r=t.length,o=ie(n),s=ce(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const a=e?X(t):$t(t),i=P(a,n-$)+$;return e?Nt(i,o):st(i,o)}class ae extends Error{constructor(e){super(e);z(this,"error_type");this.error_type=e}err(){return this.error_type}}function We(t){return typeof t=="string"?xt(t):t}class Ye{constructor(n,e){z(this,"EcGroup");z(this,"Fq");z(this,"hashToCurve");z(this,"coordinateSize");this.EcGroup=n,this.Fq=se(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}encodeUncompressed(n){let e=n.toAffine(),r=st(e.x,this.coordinateSize),o=st(e.y,this.coordinateSize);return j(Uint8Array.from([4]),r,o)}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=X(e);if(r===BigInt(0))return this.blind(n);let o=We(n),s=this.hashToCurve(o).multiply(r);if(s.equals(this.EcGroup.ProjectivePoint.ZERO))throw new ae("HashedToInifinity");return{blinder:r,clientRequestBytes:lt(this.encodeUncompressed(s))}}finalize(n,e){let r=this.EcGroup.ProjectivePoint.fromHex(n);r.assertValidity();let o=this.Fq.inv(e.blinder),s=r.multiply(o);return this.encodeUncompressed(s)}}function Kt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function le(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function Ke(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Kt(t.outputLen),Kt(t.blockLen)}function vt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Me(t,n){le(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Ut=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const fe=t=>t instanceof Uint8Array,It=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Xe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Xe)throw new Error("Non little-endian hardware is not supported");function Qe(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Vt(t){if(typeof t=="string"&&(t=Qe(t)),!fe(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Je(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!fe(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}class ue{clone(){return this._cloneInto()}}function Fe(t){const n=r=>t().update(Vt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function tn(t=32){if(Ut&&typeof Ut.getRandomValues=="function")return Ut.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class he extends ue{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Ke(n);const r=Vt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let a=0;a<s.length;a++)s[a]^=54;this.iHash.update(s),this.oHash=n.create();for(let a=0;a<s.length;a++)s[a]^=106;this.oHash.update(s),s.fill(0)}update(n){return vt(this),this.iHash.update(n),this}digestInto(n){vt(this),le(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:a,outputLen:i}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=a,n.outputLen=i,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const de=(t,n,e)=>new he(t,n).update(e).digest();de.create=(t,n)=>new he(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const en=BigInt(0),Ht=BigInt(1);function nn(t,n){const e=(o,s)=>{const a=s.negate();return o?a:s},r=o=>{const s=Math.ceil(n/o)+1,a=2**(o-1);return{windows:s,windowSize:a}};return{constTimeNegate:e,unsafeLadder(o,s){let a=t.ZERO,i=o;for(;s>en;)s&Ht&&(a=a.add(i)),i=i.double(),s>>=Ht;return a},precomputeWindow(o,s){const{windows:a,windowSize:i}=r(s),c=[];let l=o,w=l;for(let f=0;f<a;f++){w=l,c.push(w);for(let x=1;x<i;x++)w=w.add(l),c.push(w);l=w.double()}return c},wNAF(o,s,a){const{windows:i,windowSize:c}=r(o);let l=t.ZERO,w=t.BASE;const f=BigInt(2**o-1),x=2**o,v=BigInt(o);for(let b=0;b<i;b++){const u=b*c;let h=Number(a&f);a>>=v,h>c&&(h-=x,a+=Ht);const d=u,m=u+Math.abs(h)-1,g=b%2!==0,B=h<0;h===0?w=w.add(e(g,s[d])):l=l.add(e(B,s[m]))}return{p:l,f:w}},wNAFCached(o,s,a,i){const c=o._WINDOW_SIZE||1;let l=s.get(o);return l||(l=this.precomputeWindow(o,c),c!==1&&s.set(o,i(l))),this.wNAF(c,l,a)}}}function ge(t){return re(t.Fp),yt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...oe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function rn(t){const n=ge(t);yt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:on,hexToBytes:sn}=Ne,at={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=at;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:on(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=at,e=typeof t=="string"?sn(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:s}=at._parseInt(e.subarray(2)),{d:a,l:i}=at._parseInt(s);if(i.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:a}},hexFromSig(t){const n=l=>Number.parseInt(l[0],16)&8?"00"+l:l,e=l=>{const w=l.toString(16);return w.length&1?`0${w}`:w},r=n(e(t.s)),o=n(e(t.r)),s=r.length/2,a=o.length/2,i=e(s),c=e(a);return`30${e(a+s+4)}02${c}${o}02${i}${r}`}},Y=BigInt(0),q=BigInt(1),tt=BigInt(2),St=BigInt(3),Mt=BigInt(4);function cn(t){const n=rn(t),{Fp:e}=n,r=n.toBytes||((b,u,h)=>{const d=u.toAffine();return j(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(b=>{const u=b.subarray(1),h=e.fromBytes(u.subarray(0,e.BYTES)),d=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function s(b){const{a:u,b:h}=n,d=e.sqr(b),m=e.mul(d,b);return e.add(e.add(m,e.mul(b,u)),h)}if(!e.eql(e.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function a(b){return typeof b=="bigint"&&Y<b&&b<n.n}function i(b){if(!a(b))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(b){const{allowedPrivateKeyLengths:u,nByteLength:h,wrapPrivateKey:d,n:m}=n;if(u&&typeof b!="bigint"){if(b instanceof Uint8Array&&(b=lt(b)),typeof b!="string"||!u.includes(b.length))throw new Error("Invalid key");b=b.padStart(h*2,"0")}let g;try{g=typeof b=="bigint"?b:X(W("private key",b,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof b}`)}return d&&(g=P(g,m)),i(g),g}const l=new Map;function w(b){if(!(b instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(u,h,d){if(this.px=u,this.py=h,this.pz=d,u==null||!e.isValid(u))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(u){const{x:h,y:d}=u||{};if(!u||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(u instanceof f)throw new Error("projective point not allowed");const m=g=>e.eql(g,e.ZERO);return m(h)&&m(d)?f.ZERO:new f(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const h=e.invertBatch(u.map(d=>d.pz));return u.map((d,m)=>d.toAffine(h[m])).map(f.fromAffine)}static fromHex(u){const h=f.fromAffine(o(W("pointHex",u)));return h.assertValidity(),h}static fromPrivateKey(u){return f.BASE.multiply(c(u))}_setWindowSize(u){this._WINDOW_SIZE=u,l.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:h}=this.toAffine();if(!e.isValid(u)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),m=s(u);if(!e.eql(d,m))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){w(u);const{px:h,py:d,pz:m}=this,{px:g,py:B,pz:_}=u,p=e.eql(e.mul(h,_),e.mul(g,m)),S=e.eql(e.mul(d,_),e.mul(B,m));return p&&S}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:h}=n,d=e.mul(h,St),{px:m,py:g,pz:B}=this;let _=e.ZERO,p=e.ZERO,S=e.ZERO,A=e.mul(m,m),H=e.mul(g,g),O=e.mul(B,B),I=e.mul(m,g);return I=e.add(I,I),S=e.mul(m,B),S=e.add(S,S),_=e.mul(u,S),p=e.mul(d,O),p=e.add(_,p),_=e.sub(H,p),p=e.add(H,p),p=e.mul(_,p),_=e.mul(I,_),S=e.mul(d,S),O=e.mul(u,O),I=e.sub(A,O),I=e.mul(u,I),I=e.add(I,S),S=e.add(A,A),A=e.add(S,A),A=e.add(A,O),A=e.mul(A,I),p=e.add(p,A),O=e.mul(g,B),O=e.add(O,O),A=e.mul(O,I),_=e.sub(_,A),S=e.mul(O,H),S=e.add(S,S),S=e.add(S,S),new f(_,p,S)}add(u){w(u);const{px:h,py:d,pz:m}=this,{px:g,py:B,pz:_}=u;let p=e.ZERO,S=e.ZERO,A=e.ZERO;const H=n.a,O=e.mul(n.b,St);let I=e.mul(h,g),C=e.mul(d,B),N=e.mul(m,_),M=e.add(h,d),y=e.add(g,B);M=e.mul(M,y),y=e.add(I,C),M=e.sub(M,y),y=e.add(h,m);let E=e.add(g,_);return y=e.mul(y,E),E=e.add(I,N),y=e.sub(y,E),E=e.add(d,m),p=e.add(B,_),E=e.mul(E,p),p=e.add(C,N),E=e.sub(E,p),A=e.mul(H,y),p=e.mul(O,N),A=e.add(p,A),p=e.sub(C,A),A=e.add(C,A),S=e.mul(p,A),C=e.add(I,I),C=e.add(C,I),N=e.mul(H,N),y=e.mul(O,y),C=e.add(C,N),N=e.sub(I,N),N=e.mul(H,N),y=e.add(y,N),I=e.mul(C,y),S=e.add(S,I),I=e.mul(E,y),p=e.mul(M,p),p=e.sub(p,I),I=e.mul(M,C),A=e.mul(E,A),A=e.add(A,I),new f(p,S,A)}subtract(u){return this.add(u.negate())}is0(){return this.equals(f.ZERO)}wNAF(u){return v.wNAFCached(this,l,u,h=>{const d=e.invertBatch(h.map(m=>m.pz));return h.map((m,g)=>m.toAffine(d[g])).map(f.fromAffine)})}multiplyUnsafe(u){const h=f.ZERO;if(u===Y)return h;if(i(u),u===q)return this;const{endo:d}=n;if(!d)return v.unsafeLadder(this,u);let{k1neg:m,k1:g,k2neg:B,k2:_}=d.splitScalar(u),p=h,S=h,A=this;for(;g>Y||_>Y;)g&q&&(p=p.add(A)),_&q&&(S=S.add(A)),A=A.double(),g>>=q,_>>=q;return m&&(p=p.negate()),B&&(S=S.negate()),S=new f(e.mul(S.px,d.beta),S.py,S.pz),p.add(S)}multiply(u){i(u);let h=u,d,m;const{endo:g}=n;if(g){const{k1neg:B,k1:_,k2neg:p,k2:S}=g.splitScalar(h);let{p:A,f:H}=this.wNAF(_),{p:O,f:I}=this.wNAF(S);A=v.constTimeNegate(B,A),O=v.constTimeNegate(p,O),O=new f(e.mul(O.px,g.beta),O.py,O.pz),d=A.add(O),m=H.add(I)}else{const{p:B,f:_}=this.wNAF(h);d=B,m=_}return f.normalizeZ([d,m])[0]}multiplyAndAddUnsafe(u,h,d){const m=f.BASE,g=(_,p)=>p===Y||p===q||!_.equals(m)?_.multiplyUnsafe(p):_.multiply(p),B=g(this,h).add(g(u,d));return B.is0()?void 0:B}toAffine(u){const{px:h,py:d,pz:m}=this,g=this.is0();u==null&&(u=g?e.ONE:e.inv(m));const B=e.mul(h,u),_=e.mul(d,u),p=e.mul(m,u);if(g)return{x:e.ZERO,y:e.ZERO};if(!e.eql(p,e.ONE))throw new Error("invZ was invalid");return{x:B,y:_}}isTorsionFree(){const{h:u,isTorsionFree:h}=n;if(u===q)return!0;if(h)return h(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:h}=n;return u===q?this:h?h(f,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(f,this,u)}toHex(u=!0){return lt(this.toRawBytes(u))}}f.BASE=new f(n.Gx,n.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const x=n.nBitLength,v=nn(f,n.endo?Math.ceil(x/2):x);return{CURVE:n,ProjectivePoint:f,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:a}}function an(t){const n=ge(t);return yt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function ln(t){const n=an(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function a(y){return Y<y&&y<e.ORDER}function i(y){return P(y,r)}function c(y){return Tt(y,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:w,weierstrassEquation:f,isWithinCurveOrder:x}=cn({...n,toBytes(y,E,U){const T=E.toAffine(),R=e.toBytes(T.x),D=j;return U?D(Uint8Array.from([E.hasEvenY()?2:3]),R):D(Uint8Array.from([4]),R,e.toBytes(T.y))},fromBytes(y){const E=y.length,U=y[0],T=y.subarray(1);if(E===o&&(U===2||U===3)){const R=X(T);if(!a(R))throw new Error("Point is not on curve");const D=f(R);let k=e.sqrt(D);const Z=(k&q)===q;return(U&1)===1!==Z&&(k=e.neg(k)),{x:R,y:k}}else if(E===s&&U===4){const R=e.fromBytes(T.subarray(0,e.BYTES)),D=e.fromBytes(T.subarray(e.BYTES,2*e.BYTES));return{x:R,y:D}}else throw new Error(`Point of length ${E} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),v=y=>lt(st(y,n.nByteLength));function b(y){const E=r>>q;return y>E}function u(y){return b(y)?i(-y):y}const h=(y,E,U)=>X(y.slice(E,U));class d{constructor(E,U,T){this.r=E,this.s=U,this.recovery=T,this.assertValidity()}static fromCompact(E){const U=n.nByteLength;return E=W("compactSignature",E,U*2),new d(h(E,0,U),h(E,U,2*U))}static fromDER(E){const{r:U,s:T}=at.toSig(W("DER",E));return new d(U,T)}assertValidity(){if(!x(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!x(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(E){return new d(this.r,this.s,E)}recoverPublicKey(E){const{r:U,s:T,recovery:R}=this,D=S(W("msgHash",E));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const k=R===2||R===3?U+n.n:U;if(k>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const Z=R&1?"03":"02",Q=l.fromHex(Z+v(k)),J=c(k),ut=i(-D*J),bt=i(T*J),F=l.BASE.multiplyAndAddUnsafe(Q,ut,bt);if(!F)throw new Error("point at infinify");return F.assertValidity(),F}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return wt(this.toDERHex())}toDERHex(){return at.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return wt(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}const m={isValidPrivateKey(y){try{return w(y),!0}catch{return!1}},normPrivateKeyToScalar:w,randomPrivateKey:()=>{const y=ce(n.n);return Ge(n.randomBytes(y),n.n)},precompute(y=8,E=l.BASE){return E._setWindowSize(y),E.multiply(BigInt(3)),E}};function g(y,E=!0){return l.fromPrivateKey(y).toRawBytes(E)}function B(y){const E=y instanceof Uint8Array,U=typeof y=="string",T=(E||U)&&y.length;return E?T===o||T===s:U?T===2*o||T===2*s:y instanceof l}function _(y,E,U=!0){if(B(y))throw new Error("first arg must be private key");if(!B(E))throw new Error("second arg must be public key");return l.fromHex(E).multiply(w(y)).toRawBytes(U)}const p=n.bits2int||function(y){const E=X(y),U=y.length*8-n.nBitLength;return U>0?E>>BigInt(U):E},S=n.bits2int_modN||function(y){return i(p(y))},A=Dt(n.nBitLength);function H(y){if(typeof y!="bigint")throw new Error("bigint expected");if(!(Y<=y&&y<A))throw new Error(`bigint expected < 2^${n.nBitLength}`);return st(y,n.nByteLength)}function O(y,E,U=I){if(["recovered","canonical"].some(it=>it in U))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:R}=n;let{lowS:D,prehash:k,extraEntropy:Z}=U;D==null&&(D=!0),y=W("msgHash",y),k&&(y=W("prehashed msgHash",T(y)));const Q=S(y),J=w(E),ut=[H(J),H(Q)];if(Z!=null){const it=Z===!0?R(e.BYTES):Z;ut.push(W("extraEntropy",it))}const bt=j(...ut),F=Q;function _t(it){const ht=p(it);if(!x(ht))return;const Zt=c(ht),dt=l.BASE.multiply(ht).toAffine(),G=i(dt.x);if(G===Y)return;const gt=i(Zt*i(F+G*J));if(gt===Y)return;let Pt=(dt.x===G?0:2)|Number(dt.y&q),zt=gt;return D&&b(gt)&&(zt=u(gt),Pt^=1),new d(G,zt,Pt)}return{seed:bt,k2sig:_t}}const I={lowS:n.lowS,prehash:!1},C={lowS:n.lowS,prehash:!1};function N(y,E,U=I){const{seed:T,k2sig:R}=O(y,E,U),D=n;return ne(D.hash.outputLen,D.nByteLength,D.hmac)(T,R)}l.BASE._setWindowSize(8);function M(y,E,U,T=C){var dt;const R=y;if(E=W("msgHash",E),U=W("publicKey",U),"strict"in T)throw new Error("options.strict was renamed to lowS");const{lowS:D,prehash:k}=T;let Z,Q;try{if(typeof R=="string"||R instanceof Uint8Array)try{Z=d.fromDER(R)}catch(G){if(!(G instanceof at.Err))throw G;Z=d.fromCompact(R)}else if(typeof R=="object"&&typeof R.r=="bigint"&&typeof R.s=="bigint"){const{r:G,s:gt}=R;Z=new d(G,gt)}else throw new Error("PARSE");Q=l.fromHex(U)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(D&&Z.hasHighS())return!1;k&&(E=n.hash(E));const{r:J,s:ut}=Z,bt=S(E),F=c(ut),_t=i(bt*F),it=i(J*F),ht=(dt=l.BASE.multiplyAndAddUnsafe(Q,_t,it))==null?void 0:dt.toAffine();return ht?i(ht.x)===J:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:_,sign:N,verify:M,ProjectivePoint:l,Signature:d,utils:m}}function fn(t,n){const e=t.ORDER;let r=Y;for(let b=e-q;b%tt===Y;b/=tt)r+=q;const o=r,s=tt<<o-q-q,a=s*tt,i=(e-q)/a,c=(i-q)/tt,l=a-q,w=s,f=t.pow(n,i),x=t.pow(n,(i+q)/tt);let v=(b,u)=>{let h=f,d=t.pow(u,l),m=t.sqr(d);m=t.mul(m,u);let g=t.mul(b,m);g=t.pow(g,c),g=t.mul(g,d),d=t.mul(g,u),m=t.mul(g,b);let B=t.mul(m,d);g=t.pow(B,w);let _=t.eql(g,t.ONE);d=t.mul(m,x),g=t.mul(B,h),m=t.cmov(d,m,_),B=t.cmov(g,B,_);for(let p=o;p>q;p--){let S=p-tt;S=tt<<S-q;let A=t.pow(B,S);const H=t.eql(A,t.ONE);d=t.mul(m,h),h=t.mul(h,h),A=t.mul(B,h),m=t.cmov(d,m,H),B=t.cmov(A,B,H)}return{isValid:_,value:m}};if(t.ORDER%Mt===St){const b=(t.ORDER-St)/Mt,u=t.sqrt(t.neg(n));v=(h,d)=>{let m=t.sqr(d);const g=t.mul(h,d);m=t.mul(m,g);let B=t.pow(m,b);B=t.mul(B,g);const _=t.mul(B,u),p=t.mul(t.sqr(B),d),S=t.eql(p,h);let A=t.cmov(_,B,S);return{isValid:S,value:A}}}return v}function un(t,n){if(re(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=fn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,a,i,c,l,w,f;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),a=t.add(s,t.ONE),a=t.mul(a,n.B),i=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,n.A),s=t.sqr(a),l=t.sqr(i),c=t.mul(l,n.A),s=t.add(s,c),s=t.mul(s,a),l=t.mul(l,i),c=t.mul(l,n.B),s=t.add(s,c),w=t.mul(o,a);const{isValid:x,value:v}=e(s,l);f=t.mul(o,r),f=t.mul(f,v),w=t.cmov(w,a,x),f=t.cmov(f,v,x);const b=t.isOdd(r)===t.isOdd(f);return f=t.cmov(t.neg(f),f,b),w=t.div(w,i),{x:w,y:f}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function hn(t){return{hash:t,hmac:(n,...e)=>de(t,n,Je(...e)),randomBytes:tn}}function dn(t,n){const e=r=>ln({...t,...hn(r)});return Object.freeze({...e(n),create:e})}function gn(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),a=Number(e>>o&s),i=Number(e&s),c=r?4:0,l=r?0:4;t.setUint32(n+c,a,r),t.setUint32(n+l,i,r)}class wn extends ue{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=It(this.buffer)}update(n){vt(this);const{view:e,buffer:r,blockLen:o}=this;n=Vt(n);const s=n.length;for(let a=0;a<s;){const i=Math.min(o-this.pos,s-a);if(i===o){const c=It(n);for(;o<=s-a;a+=o)this.process(c,a);continue}r.set(n.subarray(a,a+i),this.pos),this.pos+=i,a+=i,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){vt(this),Me(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:a}=this;e[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>o-a&&(this.process(r,0),a=0);for(let f=a;f<o;f++)e[f]=0;gn(r,o-8,BigInt(this.length*8),s),this.process(r,0);const i=It(n),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,w=this.get();if(l>w.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)i.setUint32(4*f,w[f],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:a,pos:i}=this;return n.length=o,n.pos=i,n.finished=s,n.destroyed=a,o%e&&n.buffer.set(r),n}}const Et=BigInt(2**32-1),Ct=BigInt(32);function we(t,n=!1){return n?{h:Number(t&Et),l:Number(t>>Ct&Et)}:{h:Number(t>>Ct&Et)|0,l:Number(t&Et)|0}}function yn(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:s,l:a}=we(t[o],n);[e[o],r[o]]=[s,a]}return[e,r]}const bn=(t,n)=>BigInt(t>>>0)<<Ct|BigInt(n>>>0),mn=(t,n,e)=>t>>>e,pn=(t,n,e)=>t<<32-e|n>>>e,xn=(t,n,e)=>t>>>e|n<<32-e,En=(t,n,e)=>t<<32-e|n>>>e,vn=(t,n,e)=>t<<64-e|n>>>e-32,Sn=(t,n,e)=>t>>>e-32|n<<64-e,An=(t,n)=>n,Bn=(t,n)=>t,_n=(t,n,e)=>t<<e|n>>>32-e,Ln=(t,n,e)=>n<<e|t>>>32-e,Un=(t,n,e)=>n<<e-32|t>>>64-e,In=(t,n,e)=>t<<e-32|n>>>64-e;function Hn(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const On=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),Rn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,Tn=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),Cn=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,qn=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),$n=(t,n,e,r,o,s)=>n+e+r+o+s+(t/2**32|0)|0,Nn={fromBig:we,split:yn,toBig:bn,shrSH:mn,shrSL:pn,rotrSH:xn,rotrSL:En,rotrBH:vn,rotrBL:Sn,rotr32H:An,rotr32L:Bn,rotlSH:_n,rotlSL:Ln,rotlBH:Un,rotlBL:In,add:Hn,add3L:On,add3H:Rn,add4L:Tn,add4H:Cn,add5H:$n,add5L:qn},L=Nn,[Dn,Vn]=(()=>L.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),et=new Uint32Array(80),nt=new Uint32Array(80);class kn extends wn{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:s,Cl:a,Dh:i,Dl:c,Eh:l,El:w,Fh:f,Fl:x,Gh:v,Gl:b,Hh:u,Hl:h}=this;return[n,e,r,o,s,a,i,c,l,w,f,x,v,b,u,h]}set(n,e,r,o,s,a,i,c,l,w,f,x,v,b,u,h){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=a|0,this.Dh=i|0,this.Dl=c|0,this.Eh=l|0,this.El=w|0,this.Fh=f|0,this.Fl=x|0,this.Gh=v|0,this.Gl=b|0,this.Hh=u|0,this.Hl=h|0}process(n,e){for(let g=0;g<16;g++,e+=4)et[g]=n.getUint32(e),nt[g]=n.getUint32(e+=4);for(let g=16;g<80;g++){const B=et[g-15]|0,_=nt[g-15]|0,p=L.rotrSH(B,_,1)^L.rotrSH(B,_,8)^L.shrSH(B,_,7),S=L.rotrSL(B,_,1)^L.rotrSL(B,_,8)^L.shrSL(B,_,7),A=et[g-2]|0,H=nt[g-2]|0,O=L.rotrSH(A,H,19)^L.rotrBH(A,H,61)^L.shrSH(A,H,6),I=L.rotrSL(A,H,19)^L.rotrBL(A,H,61)^L.shrSL(A,H,6),C=L.add4L(S,I,nt[g-7],nt[g-16]),N=L.add4H(C,p,O,et[g-7],et[g-16]);et[g]=N|0,nt[g]=C|0}let{Ah:r,Al:o,Bh:s,Bl:a,Ch:i,Cl:c,Dh:l,Dl:w,Eh:f,El:x,Fh:v,Fl:b,Gh:u,Gl:h,Hh:d,Hl:m}=this;for(let g=0;g<80;g++){const B=L.rotrSH(f,x,14)^L.rotrSH(f,x,18)^L.rotrBH(f,x,41),_=L.rotrSL(f,x,14)^L.rotrSL(f,x,18)^L.rotrBL(f,x,41),p=f&v^~f&u,S=x&b^~x&h,A=L.add5L(m,_,S,Vn[g],nt[g]),H=L.add5H(A,d,B,p,Dn[g],et[g]),O=A|0,I=L.rotrSH(r,o,28)^L.rotrBH(r,o,34)^L.rotrBH(r,o,39),C=L.rotrSL(r,o,28)^L.rotrBL(r,o,34)^L.rotrBL(r,o,39),N=r&s^r&i^s&i,M=o&a^o&c^a&c;d=u|0,m=h|0,u=v|0,h=b|0,v=f|0,b=x|0,{h:f,l:x}=L.add(l|0,w|0,H|0,O|0),l=i|0,w=c|0,i=s|0,c=a|0,s=r|0,a=o|0;const y=L.add3L(O,C,M);r=L.add3H(y,H,I,N),o=y|0}({h:r,l:o}=L.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:a}=L.add(this.Bh|0,this.Bl|0,s|0,a|0),{h:i,l:c}=L.add(this.Ch|0,this.Cl|0,i|0,c|0),{h:l,l:w}=L.add(this.Dh|0,this.Dl|0,l|0,w|0),{h:f,l:x}=L.add(this.Eh|0,this.El|0,f|0,x|0),{h:v,l:b}=L.add(this.Fh|0,this.Fl|0,v|0,b|0),{h:u,l:h}=L.add(this.Gh|0,this.Gl|0,u|0,h|0),{h:d,l:m}=L.add(this.Hh|0,this.Hl|0,d|0,m|0),this.set(r,o,s,a,i,c,l,w,f,x,v,b,u,h,d,m)}roundClean(){et.fill(0),nt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Zn extends kn{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const ye=Fe(()=>new Zn);function Pn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return xt(t);throw new Error("DST must be Uint8Array or string")}const zn=X;function rt(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function jn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function mt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function kt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Gn(t,n,e,r){mt(t),mt(n),kt(e),n.length>255&&(n=r(j(xt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=r,a=Math.ceil(e/o);if(a>255)throw new Error("Invalid xmd length");const i=j(n,rt(n.length,1)),c=rt(0,s),l=rt(e,2),w=new Array(a),f=r(j(c,t,l,rt(0,1),i));w[0]=r(j(f,rt(1,1),i));for(let v=1;v<=a;v++){const b=[jn(f,w[v-1]),rt(v+1,1),i];w[v]=r(j(...b))}return j(...w).slice(0,e)}function Wn(t,n,e,r,o){if(mt(t),mt(n),kt(e),n.length>255){const s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(xt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(rt(e,2)).update(n).update(rt(n.length,1)).digest()}function Xt(t,n,e){yt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:a,expand:i,DST:c}=e;mt(t),kt(n);const l=Pn(c),w=r.toString(2).length,f=Math.ceil((w+o)/8),x=n*s*f;let v;if(i==="xmd")v=Gn(t,l,x,a);else if(i==="xof")v=Wn(t,l,x,o,a);else if(i==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');const b=new Array(n);for(let u=0;u<n;u++){const h=new Array(s);for(let d=0;d<s;d++){const m=f*(d+u*s),g=v.subarray(m,m+f);h[d]=P(zn(g),r)}b[u]=h}return b}function Yn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=Xt(r,2,{...e,DST:e.DST,...o}),a=t.fromAffine(n(s[0])),i=t.fromAffine(n(s[1])),c=a.add(i).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=Xt(r,1,{...e,DST:e.encodeDST,...o}),a=t.fromAffine(n(s[0])).clearCofactor();return a.assertValidity(),a}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Kn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),pt=se(Kn),be=pt.create(BigInt("-3")),me=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),pe=dn({a:be,b:me,Fp:pt,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},ye),Mn=pe,Xn=(()=>un(pt,{A:be,B:me,Z:pt.create(BigInt("-12"))}))(),Qn=(()=>Yn(Mn.ProjectivePoint,t=>Xn(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:pt.ORDER,m:1,k:192,expand:"xmd",hash:ye}))(),Jn=(()=>Qn.hashToCurve)(),Fn={time:2,mem:19456,parallelism:1,type:Le.Argon2di},Ot=t=>typeof t>"u";function K(t){if(!t)throw EvalError("Assertion failed")}function tr(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),o=t.byteLength==n.byteLength,s=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let a=0;a<s;a++)o&&(o=e[a]===r[a]);return o}class xe extends Error{constructor(n){super(n),this.name="ValidationError"}}const Qt=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},Jt=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),Ft=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),o=new DataView(r),s=0;return n==="little"?[...atob(t)].slice().reverse().forEach(a=>o.setUint8(s++,a.codePointAt(0))):[...atob(t)].forEach(a=>o.setUint8(s++,a.codePointAt(0))),r.slice(0,s)},er=async(t,n="little")=>{K(t.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await ft.hsm().exportKey("jwk",t);K(!Ot(e.kty)&&!Ot(e.e)&&!Ot(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const r=Ft(e.e);return K(r.byteLength==1&&new DataView(r).getUint8(0)===3),Ft(e.n,n)},ot=class ot{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return ot.CRYPTO.subtle}uuid(){return ot.CRYPTO.randomUUID()}async sgx_rsa_key(){const n=new Uint8Array([3]);let e=["sign","verify"],r={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:n,hash:"SHA-256"};const o=performance.now(),s=await ot.hsm().generateKey(r,!1,e),a=performance.now();return console.log("Time taken to generate RSA key: ",a-o),s}async sign_enclave(n,e){return K(e.type==="private"),K(e.algorithm.name==="RSASSA-PKCS1-v1_5"),ot.hsm().sign(e.algorithm.name,e,n)}async verify_enclave(n,e,r){return K(r.algorithm.name==="RSASSA-PKCS1-v1_5"),K(r.type==="public"),ot.hsm().verify(r.algorithm.name,r,e,n)}};z(ot,"CRYPTO",globalThis.crypto);let ft=ot;class nr{constructor(n){z(this,"discoveryURL");z(this,"baseURL");z(this,"oprfClient");z(this,"oprfClientData",null);z(this,"urlDirectory",null);this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new Ye(pe,Jn)}async computeOprfClientData(n,e){for(let r=0;r<5;r++){let o=await sr(e.domain_name,e.email_addr,n,r);try{return this.oprfClientData=this.oprfClient.blind(o),this.oprfClientData}catch(s){if(s instanceof ae&&s.err()=="HashedToInifinity")continue;throw s}}throw new Error("Unusable password!")}async parseServerResponse(n){if(console.log(`Server returned response code: ${n.status} ${n.statusText} with headers:
 ${n.headers}`),n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`Server returned unexpected response with code: ${e.code} and message: ${e.message}`)}else{const e=await n.json();throw new Error(`Server error: ${e.code} => ${e.message}`)}}async fetchDirectory(){if(this.urlDirectory)return this.urlDirectory;try{const n=await fetch(this.discoveryURL,{mode:"cors"});console.log(`Server fetch returned code: ${n.status}`),n.status>=200&&n.status<300?this.urlDirectory=await n.json():this.urlDirectory={enclave_list:"/v0/admin/enclaves",register_domain:"/v0/admin/register_domain"}}catch(n){console.log(`Error getting enclave directory: ${n}`),this.urlDirectory={enclave_list:"/v0/admin/enclaves",register_domain:"/v0/admin/register_domain"}}return console.log(`Using URL directory: ${this.urlDirectory}`),this.urlDirectory}async fetchEnclaveList(){let n=await this.fetchDirectory();const e=`${this.baseURL}${n.enclave_list}`;console.log(`Attempting to fetch the list of enclaves from ${e}!`);const r=await fetch(e,{mode:"cors"});return await this.parseServerResponse(r)}async signEnclaves(n,e,r){const o=new ft;K(n.type==="private"),K(e.type==="public");let s=await er(e,"big"),a={user_info:null,server_nonce:null,signer_modulus:Jt(s),signed_enclaves:[]};for(let i of r.enclaves){const c=Qt(i.tbs_data),l=Qt(i.sighash),w=await ft.hsm().digest("SHA-256",c);let f={is_ok:!1,signature:"",enclave_name:i.enclave_name,config:i.config};if(!tr(l,w))f.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const x=await o.sign_enclave(c,n);f.is_ok=!0,f.signature=Jt(x),a.signed_enclaves.push(f)}}return a}async registerUser(n,e,r,o){const{privateKey:s,publicKey:a}=r;K(s.type==="private"),K(a.type==="public"),console.log("Fetching enclave directory");let i=await this.fetchDirectory();console.log("Fetching list of enclaves");let c=await this.fetchEnclaveList();console.log("Signing enclaves");let l=await this.signEnclaves(s,a,c);console.log("Computing OPRF Client Data"),await this.computeOprfClientData(n,e),e.oprf_client_data=this.oprfClientData.clientRequestBytes,l.user_info=e,l.server_nonce=c.resp_challenge,console.log("Attempting stage-1 of registration");let w=`${this.baseURL}${i.register_domain}`;try{let f=await fetch(w,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(l)}),x=await this.parseServerResponse(f);return x.code>=200&&x.code<300}catch{return!1}}}function rr(t){const n=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!t.match(n))throw new xe("Invalid domain prefix. Must be a valid domain component")}function or(t){if(t.length<8)throw new xe("Invalid password. Must be at least 8 characters")}async function sr(t,n,e,r){let o=e+t+n+e;if(r!=null)for(let c=0;c<r;c++)o=`${e}${o}${e}`;const s=new TextEncoder().encode(o),a=new Uint8Array(await ft.hsm().digest("SHA-256",s));return(await Ue({pass:e,salt:a,...Fn})).hash}async function ir(t,n,e,r,o){rr(t),or(e);let s=new nr(r);const a=o||await new ft().sgx_rsa_key();let i={domain_name:t,email_addr:n,oprf_client_data:null};const c=await s.registerUser(e,i,a);console.log("Registration ",c?"Successful":"Failed")}async function cr(t){let n=new FormData(t),e=n.get("domain"),r=n.get("email"),o=n.get("password");console.log(`FormData: ${e} => ${r} => ${o}`),await ir(e,r,o,"https://registrar.pqkms.dev:8443")}const ar=t=>{t.preventDefault(),t.currentTarget?cr(t.currentTarget):alert("Invalid event target for registration form")},lr=()=>{const t=document.querySelector("body > div > form");t?t.addEventListener("submit",ar):alert("Invalid registration test configuration")};lr();

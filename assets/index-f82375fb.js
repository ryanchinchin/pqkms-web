var Be=Object.defineProperty;var Ae=(t,n,e)=>n in t?Be(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var z=(t,n,e)=>(Ae(t,typeof n!="symbol"?n+"":n,e),e);(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function e(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=e(s);fetch(s.href,o)}})();/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const oe=BigInt(0),Lt=BigInt(1),_e=BigInt(2),Ut=t=>t instanceof Uint8Array,Le=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function pt(t){if(!Ut(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=Le[t[e]];return n}function ie(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Vt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function ut(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const s=r*2,o=t.slice(s,s+2),i=Number.parseInt(o,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");e[r]=i}return e}function Q(t){return Vt(pt(t))}function Pt(t){if(!Ut(t))throw new Error("Uint8Array expected");return Vt(pt(Uint8Array.from(t).reverse()))}function F(t,n){return ut(t.toString(16).padStart(n*2,"0"))}function Kt(t,n){return F(t,n).reverse()}function Ue(t){return ut(ie(t))}function M(t,n,e){let r;if(typeof n=="string")try{r=ut(n)}catch(o){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${o}`)}else if(Ut(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof e=="number"&&s!==e)throw new Error(`${t} expected ${e} bytes, got ${s}`);return r}function V(...t){const n=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let e=0;return t.forEach(r=>{if(!Ut(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function Ie(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function ht(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function He(t){let n;for(n=0;t>oe;t>>=Lt,n+=1);return n}function Ce(t,n){return t>>BigInt(n)&Lt}const Re=(t,n,e)=>t|(e?Lt:oe)<<BigInt(n),Zt=t=>(_e<<BigInt(t-1))-Lt,Ht=t=>new Uint8Array(t),Wt=t=>Uint8Array.from(t);function ae(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ht(t),s=Ht(t),o=0;const i=()=>{r.fill(1),s.fill(0),o=0},a=(...l)=>e(s,r,...l),c=(l=Ht())=>{s=a(Wt([0]),l),r=a(),l.length!==0&&(s=a(Wt([1]),l),r=a())},f=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const E=[];for(;l<n;){r=a();const A=r.slice();E.push(A),l+=r.length}return V(...E)};return(l,E)=>{i(),c(l);let A;for(;!(A=E(f()));)c();return i(),A}}const Oe={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function mt(t,n,e={}){const r=(s,o,i)=>{const a=Oe[o];if(typeof a!="function")throw new Error(`Invalid validator "${o}", expected function`);const c=t[s];if(!(i&&c===void 0)&&!a(c,t))throw new Error(`Invalid param ${String(s)}=${c} (${typeof c}), expected ${o}`)};for(const[s,o]of Object.entries(n))r(s,o,!1);for(const[s,o]of Object.entries(e))r(s,o,!0);return t}const Te=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Ce,bitLen:He,bitMask:Zt,bitSet:Re,bytesToHex:pt,bytesToNumberBE:Q,bytesToNumberLE:Pt,concatBytes:V,createHmacDrbg:ae,ensureBytes:M,equalBytes:Ie,hexToBytes:ut,hexToNumber:Vt,numberToBytesBE:F,numberToBytesLE:Kt,numberToHexUnpadded:ie,numberToVarBytesBE:Ue,utf8ToBytes:ht,validateObject:mt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D=BigInt(0),q=BigInt(1),ft=BigInt(2),qe=BigInt(3),Nt=BigInt(4),Xt=BigInt(5),Qt=BigInt(8);BigInt(9);BigInt(16);function K(t,n){const e=t%n;return e>=D?e:n+e}function Ne(t,n,e){if(e<=D||n<D)throw new Error("Expected power/modulo > 0");if(e===q)return D;let r=q;for(;n>D;)n&q&&(r=r*t%e),t=t*t%e,n>>=q;return r}function $t(t,n){if(t===D||n<=D)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=K(t,n),r=n,s=D,o=q;for(;e!==D;){const a=r/e,c=r%e,f=s-o*a;r=e,e=c,s=o,o=f}if(r!==q)throw new Error("invert: does not exist");return K(s,n)}function $e(t){const n=(t-q)/ft;let e,r,s;for(e=t-q,r=0;e%ft===D;e/=ft,r++);for(s=ft;s<t&&Ne(s,n,t)!==t-q;s++);if(r===1){const i=(t+q)/Nt;return function(c,f){const w=c.pow(f,i);if(!c.eql(c.sqr(w),f))throw new Error("Cannot find square root");return w}}const o=(e+q)/ft;return function(a,c){if(a.pow(c,n)===a.neg(a.ONE))throw new Error("Cannot find square root");let f=r,w=a.pow(a.mul(a.ONE,s),e),l=a.pow(c,o),E=a.pow(c,e);for(;!a.eql(E,a.ONE);){if(a.eql(E,a.ZERO))return a.ZERO;let A=1;for(let u=a.sqr(E);A<f&&!a.eql(u,a.ONE);A++)u=a.sqr(u);const p=a.pow(w,q<<BigInt(f-A-1));w=a.sqr(p),l=a.mul(l,p),E=a.mul(E,w),f=A}return l}}function ke(t){if(t%Nt===qe){const n=(t+q)/Nt;return function(r,s){const o=r.pow(s,n);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%Qt===Xt){const n=(t-Xt)/Qt;return function(r,s){const o=r.mul(s,ft),i=r.pow(o,n),a=r.mul(s,i),c=r.mul(r.mul(a,ft),i),f=r.mul(a,r.sub(c,r.ONE));if(!r.eql(r.sqr(f),s))throw new Error("Cannot find square root");return f}}return $e(t)}const De=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ce(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=De.reduce((r,s)=>(r[s]="function",r),n);return mt(t,e)}function Ve(t,n,e){if(e<D)throw new Error("Expected power > 0");if(e===D)return t.ONE;if(e===q)return n;let r=t.ONE,s=n;for(;e>D;)e&q&&(r=t.mul(r,s)),s=t.sqr(s),e>>=q;return r}function Pe(t,n){const e=new Array(n.length),r=n.reduce((o,i,a)=>t.is0(i)?o:(e[a]=o,t.mul(o,i)),t.ONE),s=t.inv(r);return n.reduceRight((o,i,a)=>t.is0(i)?o:(e[a]=t.mul(o,e[a]),t.mul(o,i)),s),e}function fe(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function le(t,n,e=!1,r={}){if(t<=D)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=fe(t,n);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=ke(t),a=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:Zt(s),ZERO:D,ONE:q,create:c=>K(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return D<=c&&c<t},is0:c=>c===D,isOdd:c=>(c&q)===q,neg:c=>K(-c,t),eql:(c,f)=>c===f,sqr:c=>K(c*c,t),add:(c,f)=>K(c+f,t),sub:(c,f)=>K(c-f,t),mul:(c,f)=>K(c*f,t),pow:(c,f)=>Ve(a,c,f),div:(c,f)=>K(c*$t(f,t),t),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>$t(c,t),sqrt:r.sqrt||(c=>i(a,c)),invertBatch:c=>Pe(a,c),cmov:(c,f,w)=>w?f:c,toBytes:c=>e?Kt(c,o):F(c,o),fromBytes:c=>{if(c.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${c.length}`);return e?Pt(c):Q(c)}});return Object.freeze(a)}function ue(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function he(t){const n=ue(t);return n+Math.ceil(n/2)}function Ke(t,n,e=!1){const r=t.length,s=ue(n),o=he(n);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const i=e?Q(t):Pt(t),a=K(i,n-q)+q;return e?Kt(a,s):F(a,s)}function Ct(t,n){let e=F(t,n);return btoa(Array.from(e,r=>String.fromCharCode(r)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}class Bt extends Error{constructor(e){super(e);z(this,"error_type");this.error_type=e}err(){return this.error_type}}function J(t){return typeof t=="string"?ht(t):t}class Ze{constructor(n,e){z(this,"EcGroup");z(this,"Fq");z(this,"hashToCurve");z(this,"coordinateSize");this.EcGroup=n,this.Fq=le(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}curveName(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P-256";if(n===384)return"P-384";if(n===521)return"P-521";throw new Bt("UnknownCurveType")}hashAlgo(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"SHA-256";if(n===384)return"SHA-384";if(n===521)return"SHA-512";throw new Bt("UnknownCurveType")}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=Q(e);if(r===BigInt(0))return this.blind(n);let s=J(n),o=this.hashToCurve(s).multiply(r);if(o.equals(this.EcGroup.ProjectivePoint.ZERO))throw new Bt("HashedToInifinity");let i=this.EcGroup.ProjectivePoint.fromAffine(o.toAffine());return{hashed_password:n,blinder:r,clientRequestBytes:i.toHex(!1)}}async finalize(n,e){const r=window.crypto.subtle;let s=this.EcGroup.ProjectivePoint.fromHex(n);if(s.assertValidity(),s.toHex(!1)===e.clientRequestBytes)throw Error("Server tried to attack the client during OPRF finalize step by replaying the client's request");let i=this.Fq.inv(e.blinder),a=s.multiply(i).toRawBytes(!0);const c=V(F(e.hashed_password.length,2),J(e.hashed_password),F(a.length,2),a,J("Finalize")),f=await r.digest(this.hashAlgo(),c);return r.importKey("raw",f,"HKDF",!1,["deriveBits","deriveKey"])}async login_key(n,e){const r=this.EcGroup.CURVE,s=this.EcGroup.ProjectivePoint,o=globalThis.crypto.subtle,i=V(J(e),J("LoginKeySalt")),a=J("LoginKey"),c=await o.deriveBits({name:"HKDF",hash:"SHA-512",salt:i.buffer,info:a.buffer},n,8*(3*r.nByteLength/2));let f=Q(new Uint8Array(c)),w=K(f,r.n),l=s.fromPrivateKey(w),E={crv:this.curveName(),d:Ct(w,r.nByteLength),ext:!0,key_ops:["sign"],kty:"EC",x:Ct(l.x,r.Fp.BYTES),y:Ct(l.y,r.Fp.BYTES)};return{loginKey:await o.importKey("jwk",E,{name:"ECDSA",namedCurve:this.curveName()},!0,["sign"]),publicKey:l.toRawBytes(!1)}}async lockbox_key(n,e){const r=globalThis.crypto.subtle,s=V(J(e),J("LockboxSalt")),o=J("LockboxKey");return r.deriveKey({name:"HKDF",hash:"SHA-512",salt:s.buffer,info:o.buffer},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}}function Jt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function de(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function je(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Jt(t.outputLen),Jt(t.blockLen)}function At(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function ze(t,n){de(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Rt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ge=t=>t instanceof Uint8Array,Ot=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Ge=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Ge)throw new Error("Non little-endian hardware is not supported");function Me(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function jt(t){if(typeof t=="string"&&(t=Me(t)),!ge(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Ye(...t){const n=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let e=0;return t.forEach(r=>{if(!ge(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}class ye{clone(){return this._cloneInto()}}function We(t){const n=r=>t().update(jt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function Xe(t=32){if(Rt&&typeof Rt.getRandomValues=="function")return Rt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class we extends ye{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,je(n);const r=jt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?n.create().update(r).digest():r);for(let i=0;i<o.length;i++)o[i]^=54;this.iHash.update(o),this.oHash=n.create();for(let i=0;i<o.length;i++)o[i]^=106;this.oHash.update(o),o.fill(0)}update(n){return At(this),this.iHash.update(n),this}digestInto(n){At(this),de(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:s,destroyed:o,blockLen:i,outputLen:a}=this;return n=n,n.finished=s,n.destroyed=o,n.blockLen=i,n.outputLen=a,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const be=(t,n,e)=>new we(t,n).update(e).digest();be.create=(t,n)=>new we(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Qe=BigInt(0),Tt=BigInt(1);function Je(t,n){const e=(s,o)=>{const i=o.negate();return s?i:o},r=s=>{const o=Math.ceil(n/s)+1,i=2**(s-1);return{windows:o,windowSize:i}};return{constTimeNegate:e,unsafeLadder(s,o){let i=t.ZERO,a=s;for(;o>Qe;)o&Tt&&(i=i.add(a)),a=a.double(),o>>=Tt;return i},precomputeWindow(s,o){const{windows:i,windowSize:a}=r(o),c=[];let f=s,w=f;for(let l=0;l<i;l++){w=f,c.push(w);for(let E=1;E<a;E++)w=w.add(f),c.push(w);f=w.double()}return c},wNAF(s,o,i){const{windows:a,windowSize:c}=r(s);let f=t.ZERO,w=t.BASE;const l=BigInt(2**s-1),E=2**s,A=BigInt(s);for(let p=0;p<a;p++){const u=p*c;let h=Number(i&l);i>>=A,h>c&&(h-=E,i+=Tt);const d=u,b=u+Math.abs(h)-1,g=p%2!==0,B=h<0;h===0?w=w.add(e(g,o[d])):f=f.add(e(B,o[b]))}return{p:f,f:w}},wNAFCached(s,o,i,a){const c=s._WINDOW_SIZE||1;let f=o.get(s);return f||(f=this.precomputeWindow(s,c),c!==1&&o.set(s,a(f))),this.wNAF(c,f,i)}}}function pe(t){return ce(t.Fp),mt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...fe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fe(t){const n=pe(t);mt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:s}=n;if(e){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:tn,hexToBytes:en}=Te,lt={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=lt;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:tn(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=lt,e=typeof t=="string"?en(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:s,l:o}=lt._parseInt(e.subarray(2)),{d:i,l:a}=lt._parseInt(o);if(a.length)throw new n("Invalid signature: left bytes after parsing");return{r:s,s:i}},hexFromSig(t){const n=f=>Number.parseInt(f[0],16)&8?"00"+f:f,e=f=>{const w=f.toString(16);return w.length&1?`0${w}`:w},r=n(e(t.s)),s=n(e(t.r)),o=r.length/2,i=s.length/2,a=e(o),c=e(i);return`30${e(i+o+4)}02${c}${s}02${a}${r}`}},Y=BigInt(0),T=BigInt(1),rt=BigInt(2),_t=BigInt(3),Ft=BigInt(4);function nn(t){const n=Fe(t),{Fp:e}=n,r=n.toBytes||((p,u,h)=>{const d=u.toAffine();return V(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),s=n.fromBytes||(p=>{const u=p.subarray(1),h=e.fromBytes(u.subarray(0,e.BYTES)),d=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function o(p){const{a:u,b:h}=n,d=e.sqr(p),b=e.mul(d,p);return e.add(e.add(b,e.mul(p,u)),h)}if(!e.eql(e.sqr(n.Gy),o(n.Gx)))throw new Error("bad generator point: equation left != right");function i(p){return typeof p=="bigint"&&Y<p&&p<n.n}function a(p){if(!i(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(p){const{allowedPrivateKeyLengths:u,nByteLength:h,wrapPrivateKey:d,n:b}=n;if(u&&typeof p!="bigint"){if(p instanceof Uint8Array&&(p=pt(p)),typeof p!="string"||!u.includes(p.length))throw new Error("Invalid key");p=p.padStart(h*2,"0")}let g;try{g=typeof p=="bigint"?p:Q(M("private key",p,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof p}`)}return d&&(g=K(g,b)),a(g),g}const f=new Map;function w(p){if(!(p instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(u,h,d){if(this.px=u,this.py=h,this.pz=d,u==null||!e.isValid(u))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(u){const{x:h,y:d}=u||{};if(!u||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const b=g=>e.eql(g,e.ZERO);return b(h)&&b(d)?l.ZERO:new l(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const h=e.invertBatch(u.map(d=>d.pz));return u.map((d,b)=>d.toAffine(h[b])).map(l.fromAffine)}static fromHex(u){const h=l.fromAffine(s(M("pointHex",u)));return h.assertValidity(),h}static fromPrivateKey(u){return l.BASE.multiply(c(u))}_setWindowSize(u){this._WINDOW_SIZE=u,f.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:h}=this.toAffine();if(!e.isValid(u)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),b=o(u);if(!e.eql(d,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){w(u);const{px:h,py:d,pz:b}=this,{px:g,py:B,pz:_}=u,x=e.eql(e.mul(h,_),e.mul(g,b)),v=e.eql(e.mul(d,_),e.mul(B,b));return x&&v}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:h}=n,d=e.mul(h,_t),{px:b,py:g,pz:B}=this;let _=e.ZERO,x=e.ZERO,v=e.ZERO,S=e.mul(b,b),R=e.mul(g,g),H=e.mul(B,B),I=e.mul(b,g);return I=e.add(I,I),v=e.mul(b,B),v=e.add(v,v),_=e.mul(u,v),x=e.mul(d,H),x=e.add(_,x),_=e.sub(R,x),x=e.add(R,x),x=e.mul(_,x),_=e.mul(I,_),v=e.mul(d,v),H=e.mul(u,H),I=e.sub(S,H),I=e.mul(u,I),I=e.add(I,v),v=e.add(S,S),S=e.add(v,S),S=e.add(S,H),S=e.mul(S,I),x=e.add(x,S),H=e.mul(g,B),H=e.add(H,H),S=e.mul(H,I),_=e.sub(_,S),v=e.mul(H,R),v=e.add(v,v),v=e.add(v,v),new l(_,x,v)}add(u){w(u);const{px:h,py:d,pz:b}=this,{px:g,py:B,pz:_}=u;let x=e.ZERO,v=e.ZERO,S=e.ZERO;const R=n.a,H=e.mul(n.b,_t);let I=e.mul(h,g),N=e.mul(d,B),k=e.mul(b,_),X=e.add(h,d),y=e.add(g,B);X=e.mul(X,y),y=e.add(I,N),X=e.sub(X,y),y=e.add(h,b);let m=e.add(g,_);return y=e.mul(y,m),m=e.add(I,k),y=e.sub(y,m),m=e.add(d,b),x=e.add(B,_),m=e.mul(m,x),x=e.add(N,k),m=e.sub(m,x),S=e.mul(R,y),x=e.mul(H,k),S=e.add(x,S),x=e.sub(N,S),S=e.add(N,S),v=e.mul(x,S),N=e.add(I,I),N=e.add(N,I),k=e.mul(R,k),y=e.mul(H,y),N=e.add(N,k),k=e.sub(I,k),k=e.mul(R,k),y=e.add(y,k),I=e.mul(N,y),v=e.add(v,I),I=e.mul(m,y),x=e.mul(X,x),x=e.sub(x,I),I=e.mul(X,N),S=e.mul(m,S),S=e.add(S,I),new l(x,v,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return A.wNAFCached(this,f,u,h=>{const d=e.invertBatch(h.map(b=>b.pz));return h.map((b,g)=>b.toAffine(d[g])).map(l.fromAffine)})}multiplyUnsafe(u){const h=l.ZERO;if(u===Y)return h;if(a(u),u===T)return this;const{endo:d}=n;if(!d)return A.unsafeLadder(this,u);let{k1neg:b,k1:g,k2neg:B,k2:_}=d.splitScalar(u),x=h,v=h,S=this;for(;g>Y||_>Y;)g&T&&(x=x.add(S)),_&T&&(v=v.add(S)),S=S.double(),g>>=T,_>>=T;return b&&(x=x.negate()),B&&(v=v.negate()),v=new l(e.mul(v.px,d.beta),v.py,v.pz),x.add(v)}multiply(u){a(u);let h=u,d,b;const{endo:g}=n;if(g){const{k1neg:B,k1:_,k2neg:x,k2:v}=g.splitScalar(h);let{p:S,f:R}=this.wNAF(_),{p:H,f:I}=this.wNAF(v);S=A.constTimeNegate(B,S),H=A.constTimeNegate(x,H),H=new l(e.mul(H.px,g.beta),H.py,H.pz),d=S.add(H),b=R.add(I)}else{const{p:B,f:_}=this.wNAF(h);d=B,b=_}return l.normalizeZ([d,b])[0]}multiplyAndAddUnsafe(u,h,d){const b=l.BASE,g=(_,x)=>x===Y||x===T||!_.equals(b)?_.multiplyUnsafe(x):_.multiply(x),B=g(this,h).add(g(u,d));return B.is0()?void 0:B}toAffine(u){const{px:h,py:d,pz:b}=this,g=this.is0();u==null&&(u=g?e.ONE:e.inv(b));const B=e.mul(h,u),_=e.mul(d,u),x=e.mul(b,u);if(g)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:B,y:_}}isTorsionFree(){const{h:u,isTorsionFree:h}=n;if(u===T)return!0;if(h)return h(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:h}=n;return u===T?this:h?h(l,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(l,this,u)}toHex(u=!0){return pt(this.toRawBytes(u))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const E=n.nBitLength,A=Je(l,n.endo?Math.ceil(E/2):E);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:i}}function rn(t){const n=pe(t);return mt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function sn(t){const n=rn(t),{Fp:e,n:r}=n,s=e.BYTES+1,o=2*e.BYTES+1;function i(y){return Y<y&&y<e.ORDER}function a(y){return K(y,r)}function c(y){return $t(y,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:w,weierstrassEquation:l,isWithinCurveOrder:E}=nn({...n,toBytes(y,m,U){const O=m.toAffine(),C=e.toBytes(O.x),$=V;return U?$(Uint8Array.from([m.hasEvenY()?2:3]),C):$(Uint8Array.from([4]),C,e.toBytes(O.y))},fromBytes(y){const m=y.length,U=y[0],O=y.subarray(1);if(m===s&&(U===2||U===3)){const C=Q(O);if(!i(C))throw new Error("Point is not on curve");const $=l(C);let Z=e.sqrt($);const j=(Z&T)===T;return(U&1)===1!==j&&(Z=e.neg(Z)),{x:C,y:Z}}else if(m===o&&U===4){const C=e.fromBytes(O.subarray(0,e.BYTES)),$=e.fromBytes(O.subarray(e.BYTES,2*e.BYTES));return{x:C,y:$}}else throw new Error(`Point of length ${m} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),A=y=>pt(F(y,n.nByteLength));function p(y){const m=r>>T;return y>m}function u(y){return p(y)?a(-y):y}const h=(y,m,U)=>Q(y.slice(m,U));class d{constructor(m,U,O){this.r=m,this.s=U,this.recovery=O,this.assertValidity()}static fromCompact(m){const U=n.nByteLength;return m=M("compactSignature",m,U*2),new d(h(m,0,U),h(m,U,2*U))}static fromDER(m){const{r:U,s:O}=lt.toSig(M("DER",m));return new d(U,O)}assertValidity(){if(!E(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!E(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:U,s:O,recovery:C}=this,$=v(M("msgHash",m));if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");const Z=C===2||C===3?U+n.n:U;if(Z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=C&1?"03":"02",tt=f.fromHex(j+A(Z)),et=c(Z),dt=a(-$*et),xt=a(O*et),nt=f.BASE.multiplyAndAddUnsafe(tt,dt,xt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return ut(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const b={isValidPrivateKey(y){try{return w(y),!0}catch{return!1}},normPrivateKeyToScalar:w,randomPrivateKey:()=>{const y=he(n.n);return Ke(n.randomBytes(y),n.n)},precompute(y=8,m=f.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}};function g(y,m=!0){return f.fromPrivateKey(y).toRawBytes(m)}function B(y){const m=y instanceof Uint8Array,U=typeof y=="string",O=(m||U)&&y.length;return m?O===s||O===o:U?O===2*s||O===2*o:y instanceof f}function _(y,m,U=!0){if(B(y))throw new Error("first arg must be private key");if(!B(m))throw new Error("second arg must be public key");return f.fromHex(m).multiply(w(y)).toRawBytes(U)}const x=n.bits2int||function(y){const m=Q(y),U=y.length*8-n.nBitLength;return U>0?m>>BigInt(U):m},v=n.bits2int_modN||function(y){return a(x(y))},S=Zt(n.nBitLength);function R(y){if(typeof y!="bigint")throw new Error("bigint expected");if(!(Y<=y&&y<S))throw new Error(`bigint expected < 2^${n.nBitLength}`);return F(y,n.nByteLength)}function H(y,m,U=I){if(["recovered","canonical"].some(ct=>ct in U))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:C}=n;let{lowS:$,prehash:Z,extraEntropy:j}=U;$==null&&($=!0),y=M("msgHash",y),Z&&(y=M("prehashed msgHash",O(y)));const tt=v(y),et=w(m),dt=[R(et),R(tt)];if(j!=null){const ct=j===!0?C(e.BYTES):j;dt.push(M("extraEntropy",ct))}const xt=V(...dt),nt=tt;function It(ct){const gt=x(ct);if(!E(gt))return;const Gt=c(gt),yt=f.BASE.multiply(gt).toAffine(),G=a(yt.x);if(G===Y)return;const wt=a(Gt*a(nt+G*et));if(wt===Y)return;let Mt=(yt.x===G?0:2)|Number(yt.y&T),Yt=wt;return $&&p(wt)&&(Yt=u(wt),Mt^=1),new d(G,Yt,Mt)}return{seed:xt,k2sig:It}}const I={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function k(y,m,U=I){const{seed:O,k2sig:C}=H(y,m,U),$=n;return ae($.hash.outputLen,$.nByteLength,$.hmac)(O,C)}f.BASE._setWindowSize(8);function X(y,m,U,O=N){var yt;const C=y;if(m=M("msgHash",m),U=M("publicKey",U),"strict"in O)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:Z}=O;let j,tt;try{if(typeof C=="string"||C instanceof Uint8Array)try{j=d.fromDER(C)}catch(G){if(!(G instanceof lt.Err))throw G;j=d.fromCompact(C)}else if(typeof C=="object"&&typeof C.r=="bigint"&&typeof C.s=="bigint"){const{r:G,s:wt}=C;j=new d(G,wt)}else throw new Error("PARSE");tt=f.fromHex(U)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;Z&&(m=n.hash(m));const{r:et,s:dt}=j,xt=v(m),nt=c(dt),It=a(xt*nt),ct=a(et*nt),gt=(yt=f.BASE.multiplyAndAddUnsafe(tt,It,ct))==null?void 0:yt.toAffine();return gt?a(gt.x)===et:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:_,sign:k,verify:X,ProjectivePoint:f,Signature:d,utils:b}}function on(t,n){const e=t.ORDER;let r=Y;for(let p=e-T;p%rt===Y;p/=rt)r+=T;const s=r,o=rt<<s-T-T,i=o*rt,a=(e-T)/i,c=(a-T)/rt,f=i-T,w=o,l=t.pow(n,a),E=t.pow(n,(a+T)/rt);let A=(p,u)=>{let h=l,d=t.pow(u,f),b=t.sqr(d);b=t.mul(b,u);let g=t.mul(p,b);g=t.pow(g,c),g=t.mul(g,d),d=t.mul(g,u),b=t.mul(g,p);let B=t.mul(b,d);g=t.pow(B,w);let _=t.eql(g,t.ONE);d=t.mul(b,E),g=t.mul(B,h),b=t.cmov(d,b,_),B=t.cmov(g,B,_);for(let x=s;x>T;x--){let v=x-rt;v=rt<<v-T;let S=t.pow(B,v);const R=t.eql(S,t.ONE);d=t.mul(b,h),h=t.mul(h,h),S=t.mul(B,h),b=t.cmov(d,b,R),B=t.cmov(S,B,R)}return{isValid:_,value:b}};if(t.ORDER%Ft===_t){const p=(t.ORDER-_t)/Ft,u=t.sqrt(t.neg(n));A=(h,d)=>{let b=t.sqr(d);const g=t.mul(h,d);b=t.mul(b,g);let B=t.pow(b,p);B=t.mul(B,g);const _=t.mul(B,u),x=t.mul(t.sqr(B),d),v=t.eql(x,h);let S=t.cmov(_,B,v);return{isValid:v,value:S}}}return A}function an(t,n){if(ce(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=on(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let s,o,i,a,c,f,w,l;s=t.sqr(r),s=t.mul(s,n.Z),o=t.sqr(s),o=t.add(o,s),i=t.add(o,t.ONE),i=t.mul(i,n.B),a=t.cmov(n.Z,t.neg(o),!t.eql(o,t.ZERO)),a=t.mul(a,n.A),o=t.sqr(i),f=t.sqr(a),c=t.mul(f,n.A),o=t.add(o,c),o=t.mul(o,i),f=t.mul(f,a),c=t.mul(f,n.B),o=t.add(o,c),w=t.mul(s,i);const{isValid:E,value:A}=e(o,f);l=t.mul(s,r),l=t.mul(l,A),w=t.cmov(w,i,E),l=t.cmov(l,A,E);const p=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,p),w=t.div(w,a),{x:w,y:l}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function cn(t){return{hash:t,hmac:(n,...e)=>be(t,n,Ye(...e)),randomBytes:Xe}}function fn(t,n){const e=r=>sn({...t,...cn(r)});return Object.freeze({...e(n),create:e})}function ln(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(e>>s&o),a=Number(e&o),c=r?4:0,f=r?0:4;t.setUint32(n+c,i,r),t.setUint32(n+f,a,r)}class un extends ye{constructor(n,e,r,s){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ot(this.buffer)}update(n){At(this);const{view:e,buffer:r,blockLen:s}=this;n=jt(n);const o=n.length;for(let i=0;i<o;){const a=Math.min(s-this.pos,o-i);if(a===s){const c=Ot(n);for(;s<=o-i;i+=s)this.process(c,i);continue}r.set(n.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===s&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){At(this),ze(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>s-i&&(this.process(r,0),i=0);for(let l=i;l<s;l++)e[l]=0;ln(r,s-8,BigInt(this.length*8),o),this.process(r,0);const a=Ot(n),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=c/4,w=this.get();if(f>w.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<f;l++)a.setUint32(4*l,w[l],o)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:s,finished:o,destroyed:i,pos:a}=this;return n.length=s,n.pos=a,n.finished=o,n.destroyed=i,s%e&&n.buffer.set(r),n}}const St=BigInt(2**32-1),kt=BigInt(32);function me(t,n=!1){return n?{h:Number(t&St),l:Number(t>>kt&St)}:{h:Number(t>>kt&St)|0,l:Number(t&St)|0}}function hn(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let s=0;s<t.length;s++){const{h:o,l:i}=me(t[s],n);[e[s],r[s]]=[o,i]}return[e,r]}const dn=(t,n)=>BigInt(t>>>0)<<kt|BigInt(n>>>0),gn=(t,n,e)=>t>>>e,yn=(t,n,e)=>t<<32-e|n>>>e,wn=(t,n,e)=>t>>>e|n<<32-e,bn=(t,n,e)=>t<<32-e|n>>>e,pn=(t,n,e)=>t<<64-e|n>>>e-32,mn=(t,n,e)=>t>>>e-32|n<<64-e,xn=(t,n)=>n,En=(t,n)=>t,vn=(t,n,e)=>t<<e|n>>>32-e,Sn=(t,n,e)=>n<<e|t>>>32-e,Bn=(t,n,e)=>n<<e-32|t>>>64-e,An=(t,n,e)=>t<<e-32|n>>>64-e;function _n(t,n,e,r){const s=(n>>>0)+(r>>>0);return{h:t+e+(s/2**32|0)|0,l:s|0}}const Ln=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),Un=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,In=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),Hn=(t,n,e,r,s)=>n+e+r+s+(t/2**32|0)|0,Cn=(t,n,e,r,s)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(s>>>0),Rn=(t,n,e,r,s,o)=>n+e+r+s+o+(t/2**32|0)|0,On={fromBig:me,split:hn,toBig:dn,shrSH:gn,shrSL:yn,rotrSH:wn,rotrSL:bn,rotrBH:pn,rotrBL:mn,rotr32H:xn,rotr32L:En,rotlSH:vn,rotlSL:Sn,rotlBH:Bn,rotlBL:An,add:_n,add3L:Ln,add3H:Un,add4L:In,add4H:Hn,add5H:Rn,add5L:Cn},L=On,[Tn,qn]=(()=>L.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),st=new Uint32Array(80),ot=new Uint32Array(80);class Nn extends un{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:s,Ch:o,Cl:i,Dh:a,Dl:c,Eh:f,El:w,Fh:l,Fl:E,Gh:A,Gl:p,Hh:u,Hl:h}=this;return[n,e,r,s,o,i,a,c,f,w,l,E,A,p,u,h]}set(n,e,r,s,o,i,a,c,f,w,l,E,A,p,u,h){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=f|0,this.El=w|0,this.Fh=l|0,this.Fl=E|0,this.Gh=A|0,this.Gl=p|0,this.Hh=u|0,this.Hl=h|0}process(n,e){for(let g=0;g<16;g++,e+=4)st[g]=n.getUint32(e),ot[g]=n.getUint32(e+=4);for(let g=16;g<80;g++){const B=st[g-15]|0,_=ot[g-15]|0,x=L.rotrSH(B,_,1)^L.rotrSH(B,_,8)^L.shrSH(B,_,7),v=L.rotrSL(B,_,1)^L.rotrSL(B,_,8)^L.shrSL(B,_,7),S=st[g-2]|0,R=ot[g-2]|0,H=L.rotrSH(S,R,19)^L.rotrBH(S,R,61)^L.shrSH(S,R,6),I=L.rotrSL(S,R,19)^L.rotrBL(S,R,61)^L.shrSL(S,R,6),N=L.add4L(v,I,ot[g-7],ot[g-16]),k=L.add4H(N,x,H,st[g-7],st[g-16]);st[g]=k|0,ot[g]=N|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:a,Cl:c,Dh:f,Dl:w,Eh:l,El:E,Fh:A,Fl:p,Gh:u,Gl:h,Hh:d,Hl:b}=this;for(let g=0;g<80;g++){const B=L.rotrSH(l,E,14)^L.rotrSH(l,E,18)^L.rotrBH(l,E,41),_=L.rotrSL(l,E,14)^L.rotrSL(l,E,18)^L.rotrBL(l,E,41),x=l&A^~l&u,v=E&p^~E&h,S=L.add5L(b,_,v,qn[g],ot[g]),R=L.add5H(S,d,B,x,Tn[g],st[g]),H=S|0,I=L.rotrSH(r,s,28)^L.rotrBH(r,s,34)^L.rotrBH(r,s,39),N=L.rotrSL(r,s,28)^L.rotrBL(r,s,34)^L.rotrBL(r,s,39),k=r&o^r&a^o&a,X=s&i^s&c^i&c;d=u|0,b=h|0,u=A|0,h=p|0,A=l|0,p=E|0,{h:l,l:E}=L.add(f|0,w|0,R|0,H|0),f=a|0,w=c|0,a=o|0,c=i|0,o=r|0,i=s|0;const y=L.add3L(H,N,X);r=L.add3H(y,R,I,k),s=y|0}({h:r,l:s}=L.add(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=L.add(this.Bh|0,this.Bl|0,o|0,i|0),{h:a,l:c}=L.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:f,l:w}=L.add(this.Dh|0,this.Dl|0,f|0,w|0),{h:l,l:E}=L.add(this.Eh|0,this.El|0,l|0,E|0),{h:A,l:p}=L.add(this.Fh|0,this.Fl|0,A|0,p|0),{h:u,l:h}=L.add(this.Gh|0,this.Gl|0,u|0,h|0),{h:d,l:b}=L.add(this.Hh|0,this.Hl|0,d|0,b|0),this.set(r,s,o,i,a,c,f,w,l,E,A,p,u,h,d,b)}roundClean(){st.fill(0),ot.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class $n extends Nn{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const xe=We(()=>new $n);function kn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return ht(t);throw new Error("DST must be Uint8Array or string")}const Dn=Q;function it(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Vn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function Et(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function zt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Pn(t,n,e,r){Et(t),Et(n),zt(e),n.length>255&&(n=r(V(ht("H2C-OVERSIZE-DST-"),n)));const{outputLen:s,blockLen:o}=r,i=Math.ceil(e/s);if(i>255)throw new Error("Invalid xmd length");const a=V(n,it(n.length,1)),c=it(0,o),f=it(e,2),w=new Array(i),l=r(V(c,t,f,it(0,1),a));w[0]=r(V(l,it(1,1),a));for(let A=1;A<=i;A++){const p=[Vn(l,w[A-1]),it(A+1,1),a];w[A]=r(V(...p))}return V(...w).slice(0,e)}function Kn(t,n,e,r,s){if(Et(t),Et(n),zt(e),n.length>255){const o=Math.ceil(2*r/8);n=s.create({dkLen:o}).update(ht("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:e}).update(t).update(it(e,2)).update(n).update(it(n.length,1)).digest()}function te(t,n,e){mt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:s,m:o,hash:i,expand:a,DST:c}=e;Et(t),zt(n);const f=kn(c),w=r.toString(2).length,l=Math.ceil((w+s)/8),E=n*o*l;let A;if(a==="xmd")A=Pn(t,f,E,i);else if(a==="xof")A=Kn(t,f,E,s,i);else if(a==="_internal_pass")A=t;else throw new Error('expand must be "xmd" or "xof"');const p=new Array(n);for(let u=0;u<n;u++){const h=new Array(o);for(let d=0;d<o;d++){const b=l*(d+u*o),g=A.subarray(b,b+l);h[d]=K(Dn(g),r)}p[u]=h}return p}function Zn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,s){const o=te(r,2,{...e,DST:e.DST,...s}),i=t.fromAffine(n(o[0])),a=t.fromAffine(n(o[1])),c=i.add(a).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,s){const o=te(r,1,{...e,DST:e.encodeDST,...s}),i=t.fromAffine(n(o[0])).clearCofactor();return i.assertValidity(),i}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const jn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),vt=le(jn),Ee=vt.create(BigInt("-3")),ve=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Dt=fn({a:Ee,b:ve,Fp:vt,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},xe),zn=Dt,Gn=(()=>an(vt,{A:Ee,B:ve,Z:vt.create(BigInt("-12"))}))(),Mn=(()=>Zn(zn.ProjectivePoint,t=>Gn(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:vt.ORDER,m:1,k:192,expand:"xmd",hash:xe}))(),Yn=(()=>Mn.hashToCurve)(),qt=t=>typeof t>"u";function W(t){if(!t)throw EvalError("Assertion failed")}function Wn(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),s=t.byteLength==n.byteLength,o=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let i=0;i<o;i++)s&&(s=e[i]===r[i]);return s}class Se extends Error{constructor(n){super(n),this.name="ValidationError"}}const ee=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},bt=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),ne=function(t){let n=new Uint8Array(t);return btoa(Array.from(n,e=>String.fromCharCode(e)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},re=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),s=new DataView(r),o=0;return n==="little"?[...atob(t)].slice().reverse().forEach(i=>s.setUint8(o++,i.codePointAt(0))):[...atob(t)].forEach(i=>s.setUint8(o++,i.codePointAt(0))),r.slice(0,o)},Xn=async(t,n="little")=>{W(t.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await P.hsm().exportKey("jwk",t);W(!qt(e.kty)&&!qt(e.e)&&!qt(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const r=re(e.e);return W(r.byteLength==1&&new DataView(r).getUint8(0)===3),re(e.n,n)},at=class at{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return at.CRYPTO.subtle}uuid(){return at.CRYPTO.randomUUID()}async sgx_rsa_key(){const n=new Uint8Array([3]),e=["sign","verify"],r={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:n,hash:"SHA-256"};return await at.hsm().generateKey(r,!0,e)}async sign_enclave(n,e){return W(e.type==="private"),W(e.algorithm.name==="RSASSA-PKCS1-v1_5"),at.hsm().sign(e.algorithm.name,e,n)}async verify_enclave(n,e,r){return W(r.algorithm.name==="RSASSA-PKCS1-v1_5"),W(r.type==="public"),at.hsm().verify(r.algorithm.name,r,e,n)}};z(at,"CRYPTO",globalThis.crypto);let P=at;const se={attestation:"/v0/admin/attestation",registration_init:"/v0/admin/reg_init",enclave_list:"/v0/admin/enclaves",registration_finish:"/v0/admin/reg_finish"};class Qn{constructor(n){z(this,"discoveryURL");z(this,"baseURL");z(this,"oprfClient");z(this,"oprfClientData",null);z(this,"urlDirectory",null);this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new Ze(Dt,Yn)}async computeOprfClientData(n,e){try{let r=P.CRYPTO.getRandomValues(new Uint8Array(32));e.salt=bt(r);const s=await tr(n,e,Dt.CURVE.nByteLength);return this.oprfClientData=this.oprfClient.blind(s),this.oprfClientData}catch(r){if(r instanceof Bt&&r.err()=="HashedToInifinity")return this.computeOprfClientData(n,e);throw r}}async parseServerResponse(n){if(n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`Server returned unexpected response with code: ${e.code} and message: ${e.message}`)}else{const e=await n.json();throw new Error(`Server error: ${e.code} => ${e.message}`)}}async fetchDirectory(){if(this.urlDirectory)return this.urlDirectory;try{const n=await fetch(this.discoveryURL,{mode:"cors"});if(n.status>=200&&n.status<300){let e=await n.json();this.urlDirectory=e.v0}else this.urlDirectory=se}catch{this.urlDirectory=se}return this.urlDirectory}async fetchEnclaveList(){let n=await this.fetchDirectory();const e=`${this.baseURL}${n.enclave_list}`,r=await fetch(e,{mode:"cors"});return await this.parseServerResponse(r)}async signEnclaves(n,e,r){const s=new P;W(n.type==="private"),W(e.type==="public");let o=await Xn(e,"big"),i={user_info:null,server_nonce:null,signer_modulus:bt(o),signed_enclaves:[]};for(let a of r.enclaves){const c=ee(a.tbs_data),f=ee(a.sighash),w=await P.hsm().digest("SHA-256",c);let l={is_ok:!1,signature:"",enclave_name:a.enclave_name,config:a.config};if(!Wn(f,w))l.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const E=await s.sign_enclave(c,n);l.is_ok=!0,l.signature=bt(E),i.signed_enclaves.push(l)}}return i}async pssSign(n,e,r,s){const o=await P.hsm().exportKey("pkcs8",s.privateKey),i=await P.hsm().importKey("pkcs8",o,{name:"RSA-PSS",hash:"SHA-256"},!1,["sign"]);let a=V(ht(n),ht(e),r),c=await P.hsm().sign({name:"RSA-PSS",saltLength:32},i,a);return new Uint8Array(c)}async regFinalMsg(n,e,r,s,o){const i=await this.pssSign(n.user_info.domain_name,n.user_info.email_addr,e,r),a=await P.hsm().sign({name:"ECDSA",hash:"SHA-384"},s,i);let c=globalThis.crypto.getRandomValues(new Uint8Array(12));const f=await P.hsm().wrapKey("pkcs8",r.privateKey,o,{name:"AES-GCM",iv:c}),w=`${ne(c)}.${ne(f)}`;return{server_nonce:n.server_nonce,aead_data:n.aead_data,user_pub:bt(e),user_pub_sig:bt(i),oprf_pop_sig:bt(a),aux_data:w}}async regInit(n,e,r){const{privateKey:s,publicKey:o}=r;W(s.type==="private"),W(o.type==="public");let i=await this.fetchDirectory(),a=await this.fetchEnclaveList(),c=await this.signEnclaves(s,o,a);await this.computeOprfClientData(n,e),e.auth_data=this.oprfClientData.clientRequestBytes,c.user_info=e,c.server_nonce=a.resp_challenge;let f=`${this.baseURL}${i.registration_init}`,w=await fetch(f,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});return this.parseServerResponse(w)}async regFinal(n,e){const r=await this.fetchDirectory(),s=await this.oprfClient.finalize(n.user_info.auth_data,this.oprfClientData),{loginKey:o,publicKey:i}=await this.oprfClient.login_key(s,this.oprfClientData.hashed_password),a=await this.oprfClient.lockbox_key(s,this.oprfClientData.hashed_password),c=await this.regFinalMsg(n,i,e,o,a);let f=`${this.baseURL}${r.registration_finish}`;const w=JSON.stringify(c);let l=await fetch(f,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:w});return this.parseServerResponse(l)}}function Jn(t){const n=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!t.match(n))throw new Se("Invalid domain prefix. Must be a valid domain component")}function Fn(t){if(t.length<8)throw new Se("Invalid password. Must be at least 8 characters")}async function tr(t,n,e){const r=t+n.domain_name+n.email_addr+t,s=await P.hsm().importKey("raw",new TextEncoder().encode(r),{name:"PBKDF2"},!1,["deriveBits"]);let o=ut(n.salt),i=await P.hsm().deriveBits({name:"PBKDF2",salt:o,iterations:1e6,hash:"SHA-256"},s,8*e);return new Uint8Array(i)}async function er(t,n,e,r,s){Jn(t),Fn(e);const o=s||await new P().sgx_rsa_key();let i={domain_name:t,email_addr:n,auth_algo:"OPRF.P384-SHA384",auth_data:null,salt:null},a=new Qn(r);const c=await a.regInit(e,i,o);await a.regFinal(c,o)}async function nr(t){let n=new FormData(t),e=n.get("domain"),r=n.get("email"),s=n.get("password");console.log(`FormData: ${e} => ${r} => ${s}`),await er(e,r,s,"https://registrar.pqkms.dev:8443")}const rr=t=>{if(t.preventDefault(),t.currentTarget)try{nr(t.currentTarget)}catch(n){alert(`Failed to register user ${n}`)}else alert("Invalid event target for registration form")},sr=()=>{const t=document.querySelector("body > div > form");t?t.addEventListener("submit",rr):alert("Invalid registration test configuration")};sr();

var Ce=Object.defineProperty;var Re=(t,n,e)=>n in t?Ce(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var z=(t,n,e)=>(Re(t,typeof n!="symbol"?n+"":n,e),e);(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const i of s.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&r(i)}).observe(document,{childList:!0,subtree:!0});function e(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=e(o);fetch(o.href,s)}})();/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ue=BigInt(0),Lt=BigInt(1),Oe=BigInt(2),Ut=t=>t instanceof Uint8Array,Te=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function bt(t){if(!Ut(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=Te[t[e]];return n}function de(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Kt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function ut(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,s=t.slice(o,o+2),i=Number.parseInt(s,16);if(Number.isNaN(i)||i<0)throw new Error("Invalid byte sequence");e[r]=i}return e}function Q(t){return Kt(bt(t))}function zt(t){if(!Ut(t))throw new Error("Uint8Array expected");return Kt(bt(Uint8Array.from(t).reverse()))}function F(t,n){return ut(t.toString(16).padStart(n*2,"0"))}function Mt(t,n){return F(t,n).reverse()}function qe(t){return ut(de(t))}function G(t,n,e){let r;if(typeof n=="string")try{r=ut(n)}catch(s){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${s}`)}else if(Ut(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function V(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!Ut(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function Ne(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function dt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function ke(t){let n;for(n=0;t>ue;t>>=Lt,n+=1);return n}function $e(t,n){return t>>BigInt(n)&Lt}const De=(t,n,e)=>t|(e?Lt:ue)<<BigInt(n),Gt=t=>(Oe<<BigInt(t-1))-Lt,Ct=t=>new Uint8Array(t),Ft=t=>Uint8Array.from(t);function he(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ct(t),o=Ct(t),s=0;const i=()=>{r.fill(1),o.fill(0),s=0},a=(...l)=>e(o,r,...l),c=(l=Ct())=>{o=a(Ft([0]),l),r=a(),l.length!==0&&(o=a(Ft([1]),l),r=a())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let l=0;const E=[];for(;l<n;){r=a();const B=r.slice();E.push(B),l+=r.length}return V(...E)};return(l,E)=>{i(),c(l);let B;for(;!(B=E(f()));)c();return i(),B}}const Ve={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function mt(t,n,e={}){const r=(o,s,i)=>{const a=Ve[s];if(typeof a!="function")throw new Error(`Invalid validator "${s}", expected function`);const c=t[o];if(!(i&&c===void 0)&&!a(c,t))throw new Error(`Invalid param ${String(o)}=${c} (${typeof c}), expected ${s}`)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}const Pe=Object.freeze(Object.defineProperty({__proto__:null,bitGet:$e,bitLen:ke,bitMask:Gt,bitSet:De,bytesToHex:bt,bytesToNumberBE:Q,bytesToNumberLE:zt,concatBytes:V,createHmacDrbg:he,ensureBytes:G,equalBytes:Ne,hexToBytes:ut,hexToNumber:Kt,numberToBytesBE:F,numberToBytesLE:Mt,numberToHexUnpadded:de,numberToVarBytesBE:qe,utf8ToBytes:dt,validateObject:mt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D=BigInt(0),q=BigInt(1),ft=BigInt(2),Ze=BigInt(3),$t=BigInt(4),te=BigInt(5),ee=BigInt(8);BigInt(9);BigInt(16);function Z(t,n){const e=t%n;return e>=D?e:n+e}function je(t,n,e){if(e<=D||n<D)throw new Error("Expected power/modulo > 0");if(e===q)return D;let r=q;for(;n>D;)n&q&&(r=r*t%e),t=t*t%e,n>>=q;return r}function Dt(t,n){if(t===D||n<=D)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=Z(t,n),r=n,o=D,s=q;for(;e!==D;){const a=r/e,c=r%e,f=o-s*a;r=e,e=c,o=s,s=f}if(r!==q)throw new Error("invert: does not exist");return Z(o,n)}function Ke(t){const n=(t-q)/ft;let e,r,o;for(e=t-q,r=0;e%ft===D;e/=ft,r++);for(o=ft;o<t&&je(o,n,t)!==t-q;o++);if(r===1){const i=(t+q)/$t;return function(c,f){const w=c.pow(f,i);if(!c.eql(c.sqr(w),f))throw new Error("Cannot find square root");return w}}const s=(e+q)/ft;return function(a,c){if(a.pow(c,n)===a.neg(a.ONE))throw new Error("Cannot find square root");let f=r,w=a.pow(a.mul(a.ONE,o),e),l=a.pow(c,s),E=a.pow(c,e);for(;!a.eql(E,a.ONE);){if(a.eql(E,a.ZERO))return a.ZERO;let B=1;for(let u=a.sqr(E);B<f&&!a.eql(u,a.ONE);B++)u=a.sqr(u);const b=a.pow(w,q<<BigInt(f-B-1));w=a.sqr(b),l=a.mul(l,b),E=a.mul(E,w),f=B}return l}}function ze(t){if(t%$t===Ze){const n=(t+q)/$t;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%ee===te){const n=(t-te)/ee;return function(r,o){const s=r.mul(o,ft),i=r.pow(s,n),a=r.mul(o,i),c=r.mul(r.mul(a,ft),i),f=r.mul(a,r.sub(c,r.ONE));if(!r.eql(r.sqr(f),o))throw new Error("Cannot find square root");return f}}return Ke(t)}const Me=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ge(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Me.reduce((r,o)=>(r[o]="function",r),n);return mt(t,e)}function Ge(t,n,e){if(e<D)throw new Error("Expected power > 0");if(e===D)return t.ONE;if(e===q)return n;let r=t.ONE,o=n;for(;e>D;)e&q&&(r=t.mul(r,o)),o=t.sqr(o),e>>=q;return r}function Ye(t,n){const e=new Array(n.length),r=n.reduce((s,i,a)=>t.is0(i)?s:(e[a]=s,t.mul(s,i)),t.ONE),o=t.inv(r);return n.reduceRight((s,i,a)=>t.is0(i)?s:(e[a]=t.mul(s,e[a]),t.mul(s,i)),o),e}function ye(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function we(t,n,e=!1,r={}){if(t<=D)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=ye(t,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const i=ze(t),a=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Gt(o),ZERO:D,ONE:q,create:c=>Z(c,t),isValid:c=>{if(typeof c!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof c}`);return D<=c&&c<t},is0:c=>c===D,isOdd:c=>(c&q)===q,neg:c=>Z(-c,t),eql:(c,f)=>c===f,sqr:c=>Z(c*c,t),add:(c,f)=>Z(c+f,t),sub:(c,f)=>Z(c-f,t),mul:(c,f)=>Z(c*f,t),pow:(c,f)=>Ge(a,c,f),div:(c,f)=>Z(c*Dt(f,t),t),sqrN:c=>c*c,addN:(c,f)=>c+f,subN:(c,f)=>c-f,mulN:(c,f)=>c*f,inv:c=>Dt(c,t),sqrt:r.sqrt||(c=>i(a,c)),invertBatch:c=>Ye(a,c),cmov:(c,f,w)=>w?f:c,toBytes:c=>e?Mt(c,s):F(c,s),fromBytes:c=>{if(c.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${c.length}`);return e?zt(c):Q(c)}});return Object.freeze(a)}function pe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function be(t){const n=pe(t);return n+Math.ceil(n/2)}function We(t,n,e=!1){const r=t.length,o=pe(n),s=be(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const i=e?Q(t):zt(t),a=Z(i,n-q)+q;return e?Mt(a,o):F(a,o)}function Vt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function me(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function Yt(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Vt(t.outputLen),Vt(t.blockLen)}function Bt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Xe(t,n){me(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Rt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const xe=t=>t instanceof Uint8Array,Ot=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),Qe=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!Qe)throw new Error("Non little-endian hardware is not supported");function Je(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Et(t){if(typeof t=="string"&&(t=Je(t)),!xe(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Fe(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!xe(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}class Ee{clone(){return this._cloneInto()}}function ve(t){const n=r=>t().update(Et(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function tn(t=32){if(Rt&&typeof Rt.getRandomValues=="function")return Rt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function en(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),i=Number(e>>o&s),a=Number(e&s),c=r?4:0,f=r?0:4;t.setUint32(n+c,i,r),t.setUint32(n+f,a,r)}class nn extends Ee{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ot(this.buffer)}update(n){Bt(this);const{view:e,buffer:r,blockLen:o}=this;n=Et(n);const s=n.length;for(let i=0;i<s;){const a=Math.min(o-this.pos,s-i);if(a===o){const c=Ot(n);for(;o<=s-i;i+=o)this.process(c,i);continue}r.set(n.subarray(i,i+a),this.pos),this.pos+=a,i+=a,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){Bt(this),Xe(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:i}=this;e[i++]=128,this.buffer.subarray(i).fill(0),this.padOffset>o-i&&(this.process(r,0),i=0);for(let l=i;l<o;l++)e[l]=0;en(r,o-8,BigInt(this.length*8),s),this.process(r,0);const a=Ot(n),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=c/4,w=this.get();if(f>w.length)throw new Error("_sha2: outputLen bigger than state");for(let l=0;l<f;l++)a.setUint32(4*l,w[l],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:i,pos:a}=this;return n.length=o,n.pos=a,n.finished=s,n.destroyed=i,o%e&&n.buffer.set(r),n}}const At=BigInt(2**32-1),Pt=BigInt(32);function Se(t,n=!1){return n?{h:Number(t&At),l:Number(t>>Pt&At)}:{h:Number(t>>Pt&At)|0,l:Number(t&At)|0}}function rn(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:s,l:i}=Se(t[o],n);[e[o],r[o]]=[s,i]}return[e,r]}const on=(t,n)=>BigInt(t>>>0)<<Pt|BigInt(n>>>0),sn=(t,n,e)=>t>>>e,an=(t,n,e)=>t<<32-e|n>>>e,cn=(t,n,e)=>t>>>e|n<<32-e,fn=(t,n,e)=>t<<32-e|n>>>e,ln=(t,n,e)=>t<<64-e|n>>>e-32,un=(t,n,e)=>t>>>e-32|n<<64-e,dn=(t,n)=>n,hn=(t,n)=>t,gn=(t,n,e)=>t<<e|n>>>32-e,yn=(t,n,e)=>n<<e|t>>>32-e,wn=(t,n,e)=>n<<e-32|t>>>64-e,pn=(t,n,e)=>t<<e-32|n>>>64-e;function bn(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const mn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),xn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,En=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),vn=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,Sn=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),An=(t,n,e,r,o,s)=>n+e+r+o+s+(t/2**32|0)|0,Bn={fromBig:Se,split:rn,toBig:on,shrSH:sn,shrSL:an,rotrSH:cn,rotrSL:fn,rotrBH:ln,rotrBL:un,rotr32H:dn,rotr32L:hn,rotlSH:gn,rotlSL:yn,rotlBH:wn,rotlBL:pn,add:bn,add3L:mn,add3H:xn,add4L:En,add4H:vn,add5H:An,add5L:Sn},L=Bn,[_n,Ln]=(()=>L.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),rt=new Uint32Array(80),ot=new Uint32Array(80);class Ae extends nn{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:s,Cl:i,Dh:a,Dl:c,Eh:f,El:w,Fh:l,Fl:E,Gh:B,Gl:b,Hh:u,Hl:d}=this;return[n,e,r,o,s,i,a,c,f,w,l,E,B,b,u,d]}set(n,e,r,o,s,i,a,c,f,w,l,E,B,b,u,d){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=i|0,this.Dh=a|0,this.Dl=c|0,this.Eh=f|0,this.El=w|0,this.Fh=l|0,this.Fl=E|0,this.Gh=B|0,this.Gl=b|0,this.Hh=u|0,this.Hl=d|0}process(n,e){for(let g=0;g<16;g++,e+=4)rt[g]=n.getUint32(e),ot[g]=n.getUint32(e+=4);for(let g=16;g<80;g++){const A=rt[g-15]|0,_=ot[g-15]|0,x=L.rotrSH(A,_,1)^L.rotrSH(A,_,8)^L.shrSH(A,_,7),v=L.rotrSL(A,_,1)^L.rotrSL(A,_,8)^L.shrSL(A,_,7),S=rt[g-2]|0,R=ot[g-2]|0,H=L.rotrSH(S,R,19)^L.rotrBH(S,R,61)^L.shrSH(S,R,6),I=L.rotrSL(S,R,19)^L.rotrBL(S,R,61)^L.shrSL(S,R,6),N=L.add4L(v,I,ot[g-7],ot[g-16]),$=L.add4H(N,x,H,rt[g-7],rt[g-16]);rt[g]=$|0,ot[g]=N|0}let{Ah:r,Al:o,Bh:s,Bl:i,Ch:a,Cl:c,Dh:f,Dl:w,Eh:l,El:E,Fh:B,Fl:b,Gh:u,Gl:d,Hh:h,Hl:p}=this;for(let g=0;g<80;g++){const A=L.rotrSH(l,E,14)^L.rotrSH(l,E,18)^L.rotrBH(l,E,41),_=L.rotrSL(l,E,14)^L.rotrSL(l,E,18)^L.rotrBL(l,E,41),x=l&B^~l&u,v=E&b^~E&d,S=L.add5L(p,_,v,Ln[g],ot[g]),R=L.add5H(S,h,A,x,_n[g],rt[g]),H=S|0,I=L.rotrSH(r,o,28)^L.rotrBH(r,o,34)^L.rotrBH(r,o,39),N=L.rotrSL(r,o,28)^L.rotrBL(r,o,34)^L.rotrBL(r,o,39),$=r&s^r&a^s&a,X=o&i^o&c^i&c;h=u|0,p=d|0,u=B|0,d=b|0,B=l|0,b=E|0,{h:l,l:E}=L.add(f|0,w|0,R|0,H|0),f=a|0,w=c|0,a=s|0,c=i|0,s=r|0,i=o|0;const y=L.add3L(H,N,X);r=L.add3H(y,R,I,$),o=y|0}({h:r,l:o}=L.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:i}=L.add(this.Bh|0,this.Bl|0,s|0,i|0),{h:a,l:c}=L.add(this.Ch|0,this.Cl|0,a|0,c|0),{h:f,l:w}=L.add(this.Dh|0,this.Dl|0,f|0,w|0),{h:l,l:E}=L.add(this.Eh|0,this.El|0,l|0,E|0),{h:B,l:b}=L.add(this.Fh|0,this.Fl|0,B|0,b|0),{h:u,l:d}=L.add(this.Gh|0,this.Gl|0,u|0,d|0),{h,l:p}=L.add(this.Hh|0,this.Hl|0,h|0,p|0),this.set(r,o,s,i,a,c,f,w,l,E,B,b,u,d,h,p)}roundClean(){rt.fill(0),ot.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Un extends Ae{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const ne=ve(()=>new Ae),Be=ve(()=>new Un);class _e extends Ee{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Yt(n);const r=Et(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let i=0;i<s.length;i++)s[i]^=54;this.iHash.update(s),this.oHash=n.create();for(let i=0;i<s.length;i++)s[i]^=106;this.oHash.update(s),s.fill(0)}update(n){return Bt(this),this.iHash.update(n),this}digestInto(n){Bt(this),me(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:i,outputLen:a}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=i,n.outputLen=a,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const It=(t,n,e)=>new _e(t,n).update(e).digest();It.create=(t,n)=>new _e(t,n);function In(t,n,e){return Yt(t),e===void 0&&(e=new Uint8Array(t.outputLen)),It(t,Et(e),Et(n))}const Tt=new Uint8Array([0]),re=new Uint8Array;function Hn(t,n,e,r=32){if(Yt(t),Vt(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/t.outputLen);e===void 0&&(e=re);const s=new Uint8Array(o*t.outputLen),i=It.create(t,n),a=i._cloneInto(),c=new Uint8Array(i.outputLen);for(let f=0;f<o;f++)Tt[0]=f+1,a.update(f===0?re:c).update(e).update(Tt).digestInto(c),s.set(c,t.outputLen*f),i._cloneInto(a);return i.destroy(),a.destroy(),c.fill(0),Tt.fill(0),s.slice(0,r)}const oe=(t,n,e,r,o)=>Hn(t,In(t,n,e),r,o);function qt(t,n){let e=F(t,n);return btoa(Array.from(e,r=>String.fromCharCode(r)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}class Zt extends Error{constructor(e){super(e);z(this,"error_type");this.error_type=e}err(){return this.error_type}}function J(t){return typeof t=="string"?dt(t):t}class Cn{constructor(n,e){z(this,"EcGroup");z(this,"Fq");z(this,"hashToCurve");z(this,"coordinateSize");this.EcGroup=n,this.Fq=we(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}curveName(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P-256";if(n===384)return"P-384";if(n===521)return"P-521";throw new Zt("UnknownCurveType")}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=Q(e);if(r===BigInt(0))return this.blind(n);let o=J(n),s=this.hashToCurve(o).multiply(r);if(s.equals(this.EcGroup.ProjectivePoint.ZERO))throw new Zt("HashedToInifinity");let i=this.EcGroup.ProjectivePoint.fromAffine(s.toAffine());return{hashed_password:n,blinder:r,clientRequestBytes:i.toHex(!1)}}async finalize(n,e){let r=this.EcGroup.ProjectivePoint.fromHex(n);if(r.assertValidity(),r.toHex(!1)==e.clientRequestBytes)throw Error("Server tried to attack the client during OPRF finalize step by replaying the client's request");let s=this.Fq.inv(e.blinder),i=r.multiply(s).toRawBytes(!1),a=V(F(e.hashed_password.length,2),J(e.hashed_password),F(i.length,2),i,J("Finalize")),c=await globalThis.crypto.subtle.digest("SHA-512",a.buffer);return new Uint8Array(c)}async login_key(n,e){const r=this.EcGroup.CURVE,o=this.EcGroup.ProjectivePoint,s=globalThis.crypto.subtle,i=V(J(e),J("LoginInfoSalt")),a=J("LoginInfo");let c=Q(oe(ne,n,i,a,512/8)),f=Z(c,r.n),w=o.fromPrivateKey(f),l={crv:this.curveName(),d:qt(f,r.nByteLength),ext:!0,key_ops:["sign"],kty:"EC",x:qt(w.x,r.Fp.BYTES),y:qt(w.y,r.Fp.BYTES)};return{loginKey:await s.importKey("jwk",l,{name:"ECDSA",namedCurve:this.curveName()},!0,["sign"]),publicKey:w.toRawBytes(!1)}}async lockbox_key(n,e){const r=globalThis.crypto.subtle,o=V(J(e),J("LockboxSalt")),s=J("LockboxKey");let i=oe(ne,n,o,s,256/8);return await r.importKey("raw",i,"AES-GCM",!1,["encrypt","decrypt","wrapKey","unwrapKey"])}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Rn=BigInt(0),Nt=BigInt(1);function On(t,n){const e=(o,s)=>{const i=s.negate();return o?i:s},r=o=>{const s=Math.ceil(n/o)+1,i=2**(o-1);return{windows:s,windowSize:i}};return{constTimeNegate:e,unsafeLadder(o,s){let i=t.ZERO,a=o;for(;s>Rn;)s&Nt&&(i=i.add(a)),a=a.double(),s>>=Nt;return i},precomputeWindow(o,s){const{windows:i,windowSize:a}=r(s),c=[];let f=o,w=f;for(let l=0;l<i;l++){w=f,c.push(w);for(let E=1;E<a;E++)w=w.add(f),c.push(w);f=w.double()}return c},wNAF(o,s,i){const{windows:a,windowSize:c}=r(o);let f=t.ZERO,w=t.BASE;const l=BigInt(2**o-1),E=2**o,B=BigInt(o);for(let b=0;b<a;b++){const u=b*c;let d=Number(i&l);i>>=B,d>c&&(d-=E,i+=Nt);const h=u,p=u+Math.abs(d)-1,g=b%2!==0,A=d<0;d===0?w=w.add(e(g,s[h])):f=f.add(e(A,s[p]))}return{p:f,f:w}},wNAFCached(o,s,i,a){const c=o._WINDOW_SIZE||1;let f=s.get(o);return f||(f=this.precomputeWindow(o,c),c!==1&&s.set(o,a(f))),this.wNAF(c,f,i)}}}function Le(t){return ge(t.Fp),mt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ye(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Tn(t){const n=Le(t);mt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:qn,hexToBytes:Nn}=Pe,lt={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=lt;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:qn(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=lt,e=typeof t=="string"?Nn(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:s}=lt._parseInt(e.subarray(2)),{d:i,l:a}=lt._parseInt(s);if(a.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:i}},hexFromSig(t){const n=f=>Number.parseInt(f[0],16)&8?"00"+f:f,e=f=>{const w=f.toString(16);return w.length&1?`0${w}`:w},r=n(e(t.s)),o=n(e(t.r)),s=r.length/2,i=o.length/2,a=e(s),c=e(i);return`30${e(i+s+4)}02${c}${o}02${a}${r}`}},Y=BigInt(0),T=BigInt(1),st=BigInt(2),_t=BigInt(3),se=BigInt(4);function kn(t){const n=Tn(t),{Fp:e}=n,r=n.toBytes||((b,u,d)=>{const h=u.toAffine();return V(Uint8Array.from([4]),e.toBytes(h.x),e.toBytes(h.y))}),o=n.fromBytes||(b=>{const u=b.subarray(1),d=e.fromBytes(u.subarray(0,e.BYTES)),h=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:d,y:h}});function s(b){const{a:u,b:d}=n,h=e.sqr(b),p=e.mul(h,b);return e.add(e.add(p,e.mul(b,u)),d)}if(!e.eql(e.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function i(b){return typeof b=="bigint"&&Y<b&&b<n.n}function a(b){if(!i(b))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(b){const{allowedPrivateKeyLengths:u,nByteLength:d,wrapPrivateKey:h,n:p}=n;if(u&&typeof b!="bigint"){if(b instanceof Uint8Array&&(b=bt(b)),typeof b!="string"||!u.includes(b.length))throw new Error("Invalid key");b=b.padStart(d*2,"0")}let g;try{g=typeof b=="bigint"?b:Q(G("private key",b,d))}catch{throw new Error(`private key must be ${d} bytes, hex or bigint, not ${typeof b}`)}return h&&(g=Z(g,p)),a(g),g}const f=new Map;function w(b){if(!(b instanceof l))throw new Error("ProjectivePoint expected")}class l{constructor(u,d,h){if(this.px=u,this.py=d,this.pz=h,u==null||!e.isValid(u))throw new Error("x required");if(d==null||!e.isValid(d))throw new Error("y required");if(h==null||!e.isValid(h))throw new Error("z required")}static fromAffine(u){const{x:d,y:h}=u||{};if(!u||!e.isValid(d)||!e.isValid(h))throw new Error("invalid affine point");if(u instanceof l)throw new Error("projective point not allowed");const p=g=>e.eql(g,e.ZERO);return p(d)&&p(h)?l.ZERO:new l(d,h,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const d=e.invertBatch(u.map(h=>h.pz));return u.map((h,p)=>h.toAffine(d[p])).map(l.fromAffine)}static fromHex(u){const d=l.fromAffine(o(G("pointHex",u)));return d.assertValidity(),d}static fromPrivateKey(u){return l.BASE.multiply(c(u))}_setWindowSize(u){this._WINDOW_SIZE=u,f.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:d}=this.toAffine();if(!e.isValid(u)||!e.isValid(d))throw new Error("bad point: x or y not FE");const h=e.sqr(d),p=s(u);if(!e.eql(h,p))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){w(u);const{px:d,py:h,pz:p}=this,{px:g,py:A,pz:_}=u,x=e.eql(e.mul(d,_),e.mul(g,p)),v=e.eql(e.mul(h,_),e.mul(A,p));return x&&v}negate(){return new l(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:d}=n,h=e.mul(d,_t),{px:p,py:g,pz:A}=this;let _=e.ZERO,x=e.ZERO,v=e.ZERO,S=e.mul(p,p),R=e.mul(g,g),H=e.mul(A,A),I=e.mul(p,g);return I=e.add(I,I),v=e.mul(p,A),v=e.add(v,v),_=e.mul(u,v),x=e.mul(h,H),x=e.add(_,x),_=e.sub(R,x),x=e.add(R,x),x=e.mul(_,x),_=e.mul(I,_),v=e.mul(h,v),H=e.mul(u,H),I=e.sub(S,H),I=e.mul(u,I),I=e.add(I,v),v=e.add(S,S),S=e.add(v,S),S=e.add(S,H),S=e.mul(S,I),x=e.add(x,S),H=e.mul(g,A),H=e.add(H,H),S=e.mul(H,I),_=e.sub(_,S),v=e.mul(H,R),v=e.add(v,v),v=e.add(v,v),new l(_,x,v)}add(u){w(u);const{px:d,py:h,pz:p}=this,{px:g,py:A,pz:_}=u;let x=e.ZERO,v=e.ZERO,S=e.ZERO;const R=n.a,H=e.mul(n.b,_t);let I=e.mul(d,g),N=e.mul(h,A),$=e.mul(p,_),X=e.add(d,h),y=e.add(g,A);X=e.mul(X,y),y=e.add(I,N),X=e.sub(X,y),y=e.add(d,p);let m=e.add(g,_);return y=e.mul(y,m),m=e.add(I,$),y=e.sub(y,m),m=e.add(h,p),x=e.add(A,_),m=e.mul(m,x),x=e.add(N,$),m=e.sub(m,x),S=e.mul(R,y),x=e.mul(H,$),S=e.add(x,S),x=e.sub(N,S),S=e.add(N,S),v=e.mul(x,S),N=e.add(I,I),N=e.add(N,I),$=e.mul(R,$),y=e.mul(H,y),N=e.add(N,$),$=e.sub(I,$),$=e.mul(R,$),y=e.add(y,$),I=e.mul(N,y),v=e.add(v,I),I=e.mul(m,y),x=e.mul(X,x),x=e.sub(x,I),I=e.mul(X,N),S=e.mul(m,S),S=e.add(S,I),new l(x,v,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(l.ZERO)}wNAF(u){return B.wNAFCached(this,f,u,d=>{const h=e.invertBatch(d.map(p=>p.pz));return d.map((p,g)=>p.toAffine(h[g])).map(l.fromAffine)})}multiplyUnsafe(u){const d=l.ZERO;if(u===Y)return d;if(a(u),u===T)return this;const{endo:h}=n;if(!h)return B.unsafeLadder(this,u);let{k1neg:p,k1:g,k2neg:A,k2:_}=h.splitScalar(u),x=d,v=d,S=this;for(;g>Y||_>Y;)g&T&&(x=x.add(S)),_&T&&(v=v.add(S)),S=S.double(),g>>=T,_>>=T;return p&&(x=x.negate()),A&&(v=v.negate()),v=new l(e.mul(v.px,h.beta),v.py,v.pz),x.add(v)}multiply(u){a(u);let d=u,h,p;const{endo:g}=n;if(g){const{k1neg:A,k1:_,k2neg:x,k2:v}=g.splitScalar(d);let{p:S,f:R}=this.wNAF(_),{p:H,f:I}=this.wNAF(v);S=B.constTimeNegate(A,S),H=B.constTimeNegate(x,H),H=new l(e.mul(H.px,g.beta),H.py,H.pz),h=S.add(H),p=R.add(I)}else{const{p:A,f:_}=this.wNAF(d);h=A,p=_}return l.normalizeZ([h,p])[0]}multiplyAndAddUnsafe(u,d,h){const p=l.BASE,g=(_,x)=>x===Y||x===T||!_.equals(p)?_.multiplyUnsafe(x):_.multiply(x),A=g(this,d).add(g(u,h));return A.is0()?void 0:A}toAffine(u){const{px:d,py:h,pz:p}=this,g=this.is0();u==null&&(u=g?e.ONE:e.inv(p));const A=e.mul(d,u),_=e.mul(h,u),x=e.mul(p,u);if(g)return{x:e.ZERO,y:e.ZERO};if(!e.eql(x,e.ONE))throw new Error("invZ was invalid");return{x:A,y:_}}isTorsionFree(){const{h:u,isTorsionFree:d}=n;if(u===T)return!0;if(d)return d(l,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:d}=n;return u===T?this:d?d(l,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(l,this,u)}toHex(u=!0){return bt(this.toRawBytes(u))}}l.BASE=new l(n.Gx,n.Gy,e.ONE),l.ZERO=new l(e.ZERO,e.ONE,e.ZERO);const E=n.nBitLength,B=On(l,n.endo?Math.ceil(E/2):E);return{CURVE:n,ProjectivePoint:l,normPrivateKeyToScalar:c,weierstrassEquation:s,isWithinCurveOrder:i}}function $n(t){const n=Le(t);return mt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Dn(t){const n=$n(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function i(y){return Y<y&&y<e.ORDER}function a(y){return Z(y,r)}function c(y){return Dt(y,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:w,weierstrassEquation:l,isWithinCurveOrder:E}=kn({...n,toBytes(y,m,U){const O=m.toAffine(),C=e.toBytes(O.x),k=V;return U?k(Uint8Array.from([m.hasEvenY()?2:3]),C):k(Uint8Array.from([4]),C,e.toBytes(O.y))},fromBytes(y){const m=y.length,U=y[0],O=y.subarray(1);if(m===o&&(U===2||U===3)){const C=Q(O);if(!i(C))throw new Error("Point is not on curve");const k=l(C);let j=e.sqrt(k);const K=(j&T)===T;return(U&1)===1!==K&&(j=e.neg(j)),{x:C,y:j}}else if(m===s&&U===4){const C=e.fromBytes(O.subarray(0,e.BYTES)),k=e.fromBytes(O.subarray(e.BYTES,2*e.BYTES));return{x:C,y:k}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),B=y=>bt(F(y,n.nByteLength));function b(y){const m=r>>T;return y>m}function u(y){return b(y)?a(-y):y}const d=(y,m,U)=>Q(y.slice(m,U));class h{constructor(m,U,O){this.r=m,this.s=U,this.recovery=O,this.assertValidity()}static fromCompact(m){const U=n.nByteLength;return m=G("compactSignature",m,U*2),new h(d(m,0,U),d(m,U,2*U))}static fromDER(m){const{r:U,s:O}=lt.toSig(G("DER",m));return new h(U,O)}assertValidity(){if(!E(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!E(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new h(this.r,this.s,m)}recoverPublicKey(m){const{r:U,s:O,recovery:C}=this,k=v(G("msgHash",m));if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");const j=C===2||C===3?U+n.n:U;if(j>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const K=C&1?"03":"02",tt=f.fromHex(K+B(j)),et=c(j),ht=a(-k*et),xt=a(O*et),nt=f.BASE.multiplyAndAddUnsafe(tt,ht,xt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return b(this.s)}normalizeS(){return this.hasHighS()?new h(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return ut(this.toDERHex())}toDERHex(){return lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return ut(this.toCompactHex())}toCompactHex(){return B(this.r)+B(this.s)}}const p={isValidPrivateKey(y){try{return w(y),!0}catch{return!1}},normPrivateKeyToScalar:w,randomPrivateKey:()=>{const y=be(n.n);return We(n.randomBytes(y),n.n)},precompute(y=8,m=f.BASE){return m._setWindowSize(y),m.multiply(BigInt(3)),m}};function g(y,m=!0){return f.fromPrivateKey(y).toRawBytes(m)}function A(y){const m=y instanceof Uint8Array,U=typeof y=="string",O=(m||U)&&y.length;return m?O===o||O===s:U?O===2*o||O===2*s:y instanceof f}function _(y,m,U=!0){if(A(y))throw new Error("first arg must be private key");if(!A(m))throw new Error("second arg must be public key");return f.fromHex(m).multiply(w(y)).toRawBytes(U)}const x=n.bits2int||function(y){const m=Q(y),U=y.length*8-n.nBitLength;return U>0?m>>BigInt(U):m},v=n.bits2int_modN||function(y){return a(x(y))},S=Gt(n.nBitLength);function R(y){if(typeof y!="bigint")throw new Error("bigint expected");if(!(Y<=y&&y<S))throw new Error(`bigint expected < 2^${n.nBitLength}`);return F(y,n.nByteLength)}function H(y,m,U=I){if(["recovered","canonical"].some(ct=>ct in U))throw new Error("sign() legacy options not supported");const{hash:O,randomBytes:C}=n;let{lowS:k,prehash:j,extraEntropy:K}=U;k==null&&(k=!0),y=G("msgHash",y),j&&(y=G("prehashed msgHash",O(y)));const tt=v(y),et=w(m),ht=[R(et),R(tt)];if(K!=null){const ct=K===!0?C(e.BYTES):K;ht.push(G("extraEntropy",ct))}const xt=V(...ht),nt=tt;function Ht(ct){const gt=x(ct);if(!E(gt))return;const Xt=c(gt),yt=f.BASE.multiply(gt).toAffine(),M=a(yt.x);if(M===Y)return;const wt=a(Xt*a(nt+M*et));if(wt===Y)return;let Qt=(yt.x===M?0:2)|Number(yt.y&T),Jt=wt;return k&&b(wt)&&(Jt=u(wt),Qt^=1),new h(M,Jt,Qt)}return{seed:xt,k2sig:Ht}}const I={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function $(y,m,U=I){const{seed:O,k2sig:C}=H(y,m,U),k=n;return he(k.hash.outputLen,k.nByteLength,k.hmac)(O,C)}f.BASE._setWindowSize(8);function X(y,m,U,O=N){var yt;const C=y;if(m=G("msgHash",m),U=G("publicKey",U),"strict"in O)throw new Error("options.strict was renamed to lowS");const{lowS:k,prehash:j}=O;let K,tt;try{if(typeof C=="string"||C instanceof Uint8Array)try{K=h.fromDER(C)}catch(M){if(!(M instanceof lt.Err))throw M;K=h.fromCompact(C)}else if(typeof C=="object"&&typeof C.r=="bigint"&&typeof C.s=="bigint"){const{r:M,s:wt}=C;K=new h(M,wt)}else throw new Error("PARSE");tt=f.fromHex(U)}catch(M){if(M.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(k&&K.hasHighS())return!1;j&&(m=n.hash(m));const{r:et,s:ht}=K,xt=v(m),nt=c(ht),Ht=a(xt*nt),ct=a(et*nt),gt=(yt=f.BASE.multiplyAndAddUnsafe(tt,Ht,ct))==null?void 0:yt.toAffine();return gt?a(gt.x)===et:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:_,sign:$,verify:X,ProjectivePoint:f,Signature:h,utils:p}}function Vn(t,n){const e=t.ORDER;let r=Y;for(let b=e-T;b%st===Y;b/=st)r+=T;const o=r,s=st<<o-T-T,i=s*st,a=(e-T)/i,c=(a-T)/st,f=i-T,w=s,l=t.pow(n,a),E=t.pow(n,(a+T)/st);let B=(b,u)=>{let d=l,h=t.pow(u,f),p=t.sqr(h);p=t.mul(p,u);let g=t.mul(b,p);g=t.pow(g,c),g=t.mul(g,h),h=t.mul(g,u),p=t.mul(g,b);let A=t.mul(p,h);g=t.pow(A,w);let _=t.eql(g,t.ONE);h=t.mul(p,E),g=t.mul(A,d),p=t.cmov(h,p,_),A=t.cmov(g,A,_);for(let x=o;x>T;x--){let v=x-st;v=st<<v-T;let S=t.pow(A,v);const R=t.eql(S,t.ONE);h=t.mul(p,d),d=t.mul(d,d),S=t.mul(A,d),p=t.cmov(h,p,R),A=t.cmov(S,A,R)}return{isValid:_,value:p}};if(t.ORDER%se===_t){const b=(t.ORDER-_t)/se,u=t.sqrt(t.neg(n));B=(d,h)=>{let p=t.sqr(h);const g=t.mul(d,h);p=t.mul(p,g);let A=t.pow(p,b);A=t.mul(A,g);const _=t.mul(A,u),x=t.mul(t.sqr(A),h),v=t.eql(x,d);let S=t.cmov(_,A,v);return{isValid:v,value:S}}}return B}function Pn(t,n){if(ge(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Vn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,i,a,c,f,w,l;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),i=t.add(s,t.ONE),i=t.mul(i,n.B),a=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),a=t.mul(a,n.A),s=t.sqr(i),f=t.sqr(a),c=t.mul(f,n.A),s=t.add(s,c),s=t.mul(s,i),f=t.mul(f,a),c=t.mul(f,n.B),s=t.add(s,c),w=t.mul(o,i);const{isValid:E,value:B}=e(s,f);l=t.mul(o,r),l=t.mul(l,B),w=t.cmov(w,i,E),l=t.cmov(l,B,E);const b=t.isOdd(r)===t.isOdd(l);return l=t.cmov(t.neg(l),l,b),w=t.div(w,a),{x:w,y:l}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Zn(t){return{hash:t,hmac:(n,...e)=>It(t,n,Fe(...e)),randomBytes:tn}}function jn(t,n){const e=r=>Dn({...t,...Zn(r)});return Object.freeze({...e(n),create:e})}function Kn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return dt(t);throw new Error("DST must be Uint8Array or string")}const zn=Q;function it(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Mn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function vt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Wt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Gn(t,n,e,r){vt(t),vt(n),Wt(e),n.length>255&&(n=r(V(dt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=r,i=Math.ceil(e/o);if(i>255)throw new Error("Invalid xmd length");const a=V(n,it(n.length,1)),c=it(0,s),f=it(e,2),w=new Array(i),l=r(V(c,t,f,it(0,1),a));w[0]=r(V(l,it(1,1),a));for(let B=1;B<=i;B++){const b=[Mn(l,w[B-1]),it(B+1,1),a];w[B]=r(V(...b))}return V(...w).slice(0,e)}function Yn(t,n,e,r,o){if(vt(t),vt(n),Wt(e),n.length>255){const s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(dt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(it(e,2)).update(n).update(it(n.length,1)).digest()}function ie(t,n,e){mt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:i,expand:a,DST:c}=e;vt(t),Wt(n);const f=Kn(c),w=r.toString(2).length,l=Math.ceil((w+o)/8),E=n*s*l;let B;if(a==="xmd")B=Gn(t,f,E,i);else if(a==="xof")B=Yn(t,f,E,o,i);else if(a==="_internal_pass")B=t;else throw new Error('expand must be "xmd" or "xof"');const b=new Array(n);for(let u=0;u<n;u++){const d=new Array(s);for(let h=0;h<s;h++){const p=l*(h+u*s),g=B.subarray(p,p+l);d[h]=Z(zn(g),r)}b[u]=d}return b}function Wn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=ie(r,2,{...e,DST:e.DST,...o}),i=t.fromAffine(n(s[0])),a=t.fromAffine(n(s[1])),c=i.add(a).clearCofactor();return c.assertValidity(),c},encodeToCurve(r,o){const s=ie(r,1,{...e,DST:e.encodeDST,...o}),i=t.fromAffine(n(s[0])).clearCofactor();return i.assertValidity(),i}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),St=we(Xn),Ue=St.create(BigInt("-3")),Ie=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),jt=jn({a:Ue,b:Ie,Fp:St,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},Be),Qn=jt,Jn=(()=>Pn(St,{A:Ue,B:Ie,Z:St.create(BigInt("-12"))}))(),Fn=(()=>Wn(Qn.ProjectivePoint,t=>Jn(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:St.ORDER,m:1,k:192,expand:"xmd",hash:Be}))(),tr=(()=>Fn.hashToCurve)(),kt=t=>typeof t>"u";function W(t){if(!t)throw EvalError("Assertion failed")}function er(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),o=t.byteLength==n.byteLength,s=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let i=0;i<s;i++)o&&(o=e[i]===r[i]);return o}class He extends Error{constructor(n){super(n),this.name="ValidationError"}}const ae=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},pt=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),ce=function(t){let n=new Uint8Array(t);return btoa(Array.from(n,e=>String.fromCharCode(e)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},fe=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),o=new DataView(r),s=0;return n==="little"?[...atob(t)].slice().reverse().forEach(i=>o.setUint8(s++,i.codePointAt(0))):[...atob(t)].forEach(i=>o.setUint8(s++,i.codePointAt(0))),r.slice(0,s)},nr=async(t,n="little")=>{W(t.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await P.hsm().exportKey("jwk",t);W(!kt(e.kty)&&!kt(e.e)&&!kt(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const r=fe(e.e);return W(r.byteLength==1&&new DataView(r).getUint8(0)===3),fe(e.n,n)},at=class at{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return at.CRYPTO.subtle}uuid(){return at.CRYPTO.randomUUID()}async sgx_rsa_key(){const n=new Uint8Array([3]),e=["sign","verify"],r={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:n,hash:"SHA-256"};return await at.hsm().generateKey(r,!0,e)}async sign_enclave(n,e){return W(e.type==="private"),W(e.algorithm.name==="RSASSA-PKCS1-v1_5"),at.hsm().sign(e.algorithm.name,e,n)}async verify_enclave(n,e,r){return W(r.algorithm.name==="RSASSA-PKCS1-v1_5"),W(r.type==="public"),at.hsm().verify(r.algorithm.name,r,e,n)}};z(at,"CRYPTO",globalThis.crypto);let P=at;const le={attestation:"/v0/admin/attestation",registration_init:"/v0/admin/reg_init",enclave_list:"/v0/admin/enclaves",registration_finish:"/v0/admin/reg_finish"};class rr{constructor(n){z(this,"discoveryURL");z(this,"baseURL");z(this,"oprfClient");z(this,"oprfClientData",null);z(this,"urlDirectory",null);this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new Cn(jt,tr)}async computeOprfClientData(n,e){try{let r=P.CRYPTO.getRandomValues(new Uint8Array(32));e.salt=pt(r);const o=await ir(n,e,jt.CURVE.nByteLength);return this.oprfClientData=this.oprfClient.blind(o),this.oprfClientData}catch(r){if(r instanceof Zt&&r.err()=="HashedToInifinity")return this.computeOprfClientData(n,e);throw r}}async parseServerResponse(n){if(n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`Server returned unexpected response with code: ${e.code} and message: ${e.message}`)}else{const e=await n.json();throw new Error(`Server error: ${e.code} => ${e.message}`)}}async fetchDirectory(){if(this.urlDirectory)return this.urlDirectory;try{const n=await fetch(this.discoveryURL,{mode:"cors"});if(n.status>=200&&n.status<300){let e=await n.json();this.urlDirectory=e.v0}else this.urlDirectory=le}catch{this.urlDirectory=le}return this.urlDirectory}async fetchEnclaveList(){let n=await this.fetchDirectory();const e=`${this.baseURL}${n.enclave_list}`,r=await fetch(e,{mode:"cors"});return await this.parseServerResponse(r)}async signEnclaves(n,e,r){const o=new P;W(n.type==="private"),W(e.type==="public");let s=await nr(e,"big"),i={user_info:null,server_nonce:null,signer_modulus:pt(s),signed_enclaves:[]};for(let a of r.enclaves){const c=ae(a.tbs_data),f=ae(a.sighash),w=await P.hsm().digest("SHA-256",c);let l={is_ok:!1,signature:"",enclave_name:a.enclave_name,config:a.config};if(!er(f,w))l.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const E=await o.sign_enclave(c,n);l.is_ok=!0,l.signature=pt(E),i.signed_enclaves.push(l)}}return i}async pssSign(n,e,r,o){const s=await P.hsm().exportKey("pkcs8",o.privateKey),i=await P.hsm().importKey("pkcs8",s,{name:"RSA-PSS",hash:"SHA-256"},!1,["sign"]);let a=V(dt(n),dt(e),r),c=await P.hsm().sign({name:"RSA-PSS",saltLength:32},i,a);return new Uint8Array(c)}async regFinalMsg(n,e,r,o,s){const i=await this.pssSign(n.user_info.domain_name,n.user_info.email_addr,e,r),a=await P.hsm().sign({name:"ECDSA",hash:"SHA-384"},o,i);let c=globalThis.crypto.getRandomValues(new Uint8Array(12));const f=await P.hsm().wrapKey("pkcs8",r.privateKey,s,{name:"AES-GCM",iv:c}),w=`${ce(c)}.${ce(f)}`;return{server_nonce:n.server_nonce,aead_data:n.aead_data,user_pub:pt(e),user_pub_sig:pt(i),oprf_pop_sig:pt(a),aux_data:w}}async regInit(n,e,r){const{privateKey:o,publicKey:s}=r;W(o.type==="private"),W(s.type==="public");let i=await this.fetchDirectory(),a=await this.fetchEnclaveList(),c=await this.signEnclaves(o,s,a);await this.computeOprfClientData(n,e),e.auth_data=this.oprfClientData.clientRequestBytes,c.user_info=e,c.server_nonce=a.resp_challenge;let f=`${this.baseURL}${i.registration_init}`,w=await fetch(f,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});return this.parseServerResponse(w)}async regFinal(n,e){const r=await this.fetchDirectory(),o=await this.oprfClient.finalize(n.user_info.auth_data,this.oprfClientData),{loginKey:s,publicKey:i}=await this.oprfClient.login_key(o,this.oprfClientData.hashed_password),a=await this.oprfClient.lockbox_key(o,this.oprfClientData.hashed_password),c=await this.regFinalMsg(n,i,e,s,a);let f=`${this.baseURL}${r.registration_finish}`;const w=JSON.stringify(c);let l=await fetch(f,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:w});return this.parseServerResponse(l)}}function or(t){const n=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!t.match(n))throw new He("Invalid domain prefix. Must be a valid domain component")}function sr(t){if(t.length<8)throw new He("Invalid password. Must be at least 8 characters")}async function ir(t,n,e){const r=t+n.domain_name+n.email_addr+t,o=await P.hsm().importKey("raw",new TextEncoder().encode(r),{name:"PBKDF2"},!0,["deriveBits"]);let s=ut(n.salt),i=await P.hsm().deriveBits({name:"PBKDF2",salt:s,iterations:1e6,hash:"SHA-256"},o,8*e);return new Uint8Array(i)}async function ar(t,n,e,r,o){or(t),sr(e);const s=o||await new P().sgx_rsa_key();let i={domain_name:t,email_addr:n,auth_algo:"OPRF.P384-SHA384",auth_data:null,salt:null},a=new rr(r);const c=await a.regInit(e,i,s);await a.regFinal(c,s)}async function cr(t){let n=new FormData(t),e=n.get("domain"),r=n.get("email"),o=n.get("password");console.log(`FormData: ${e} => ${r} => ${o}`),await ar(e,r,o,"https://registrar.pqkms.dev:8443")}const fr=t=>{if(t.preventDefault(),t.currentTarget)try{cr(t.currentTarget)}catch(n){alert(`Failed to register user ${n}`)}else alert("Invalid event target for registration form")},lr=()=>{const t=document.querySelector("body > div > form");t?t.addEventListener("submit",fr):alert("Invalid registration test configuration")};lr();

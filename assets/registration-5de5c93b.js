var k=Object.defineProperty;var x=(s,a,e)=>a in s?k(s,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[a]=e;var f=(s,a,e)=>(x(s,typeof a!="symbol"?a+"":a,e),e);import{a as u,i as m,b as v,U,t as y,f as w,e as D,c as T,u as S,d as b,V as R}from"./auth_base-0ccf5998.js";const P=async(s,a="little")=>{u(s.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await h.hsm().exportKey("jwk",s);u(!m(e.kty)&&!m(e.e)&&!m(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const t=v(e.e);return u(t.byteLength==1&&new DataView(t).getUint8(0)===3),v(e.n,a)},p=class p{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return p.CRYPTO.subtle}uuid(){return p.CRYPTO.randomUUID()}async sgx_rsa_key(){const a=new Uint8Array([3]),e=["sign","verify"],t={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:a,hash:"SHA-256"};return await p.hsm().generateKey(t,!0,e)}async sign_enclave(a,e){return u(e.type==="private"),u(e.algorithm.name==="RSASSA-PKCS1-v1_5"),p.hsm().sign(e.algorithm.name,e,a)}async verify_enclave(a,e,t){return u(t.algorithm.name==="RSASSA-PKCS1-v1_5"),u(t.type==="public"),p.hsm().verify(t.algorithm.name,t,e,a)}};f(p,"CRYPTO",globalThis.crypto);let h=p;const A={attestation:"/v0/admin/attestation",registration_init:"/v0/admin/reg_init",enclave_list:"/v0/admin/enclaves",registration_finish:"/v0/admin/reg_finish",user_info:"/v0/admin/user_info"};class E extends U{constructor(e){super(e);f(this,"directory",null)}async fetchDirectory(){if(this.directory)return this.directory;try{const e=await fetch(this.discoveryURL,{mode:"cors"});if(e.ok){let t=await e.json();this.directory=t.v0}else this.directory=A}catch{this.directory=A}return this.directory}async fetchEnclaveList(){let e=await this.fetchDirectory();const t=`${this.baseURL}${e.enclave_list}`,n=await fetch(t,{mode:"cors"});return await this.parseServerResponse(n)}async signEnclaves(e,t,n){const i=new h;u(e.type==="private"),u(t.type==="public");let l=await P(t,"big"),o={user_info:null,server_nonce:null,signer_modulus:y(l),signed_enclaves:[]};for(let r of n.enclaves){const c=w(r.tbs_data),d=w(r.sighash),_=await h.hsm().digest("SHA-256",c);let g={is_ok:!1,signature:"",enclave_name:r.enclave_name,config:r.config};if(!D(d,_))g.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const C=await i.sign_enclave(c,e);g.is_ok=!0,g.signature=y(C),o.signed_enclaves.push(g)}}return o}async pssSign(e,t,n,i){const l=await h.hsm().exportKey("pkcs8",i.privateKey),o=await h.hsm().importKey("pkcs8",l,{name:"RSA-PSS",hash:"SHA-256"},!1,["sign"]);let r=T(S(e),S(t),n),c=await h.hsm().sign({name:"RSA-PSS",saltLength:32},o,r);return new Uint8Array(c)}async regFinalMsg(e,t,n,i,l){const o=await this.pssSign(e.user_info.domain_name,e.user_info.user_name,t,n),r=await h.hsm().sign({name:"ECDSA",hash:"SHA-384"},i,o);let c=globalThis.crypto.getRandomValues(new Uint8Array(12));const d=await h.hsm().wrapKey("pkcs8",n.privateKey,l,{name:"AES-GCM",iv:c}),_=`${b(c)}.${b(d)}`;return{server_nonce:e.server_nonce,aead_data:e.aead_data,user_pub:y(t),user_pub_sig:y(o),oprf_pop_sig:y(r),aux_data:_}}async regInit(e,t,n){const{privateKey:i,publicKey:l}=n;u(i.type==="private"),u(l.type==="public");let o=await this.fetchDirectory(),r=await this.fetchEnclaveList(),c=await this.signEnclaves(i,l,r);await this.computeOprfClientData(e,t),t.auth_data=this.oprfClientData.clientRequestBytes,c.user_info=t,c.server_nonce=r.resp_challenge;let d=`${this.baseURL}${o.registration_init}`,_=await fetch(d,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});return this.parseServerResponse(_)}async regFinal(e,t){const n=await this.fetchDirectory(),i=await this.oprfClient.finalize(e.user_info.auth_data,this.oprfClientData),{loginKey:l,publicKey:o}=await this.oprfClient.login_key(i,this.oprfClientData.hashed_password),r=await this.oprfClient.lockbox_key(i,this.oprfClientData.hashed_password),c=await this.regFinalMsg(e,o,t,l,r);let d=`${this.baseURL}${n.registration_finish}`;const _=JSON.stringify(c);let g=await fetch(d,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:_});return this.parseServerResponse(g)}}function L(s){const a=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!s.match(a))throw new R("Invalid domain prefix. Must be a valid domain component")}function O(s){if(s.length<8)throw new R("Invalid password. Must be at least 8 characters")}function K(s){}async function M(s,a,e,t,n){L(s),O(e);const i=n||await new h().sgx_rsa_key();let l={domain_name:s,user_name:a,auth_algo:"OPRF.P384-SHA384",auth_data:null,salt:null},o=new E(t);const r=await o.regInit(e,l,i);return o.regFinal(r,i)}export{E as default,M as register_user,L as validateDomainStr,O as validateRawPasswordStr,K as validateUsernameStr};

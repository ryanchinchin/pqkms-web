var Re=Object.defineProperty;var Te=(t,n,e)=>n in t?Re(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var K=(t,n,e)=>(Te(t,typeof n!="symbol"?n+"":n,e),e);(function(){const n=document.createElement("link").relList;if(n&&n.supports&&n.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const s of o)if(s.type==="childList")for(const c of s.addedNodes)c.tagName==="LINK"&&c.rel==="modulepreload"&&r(c)}).observe(document,{childList:!0,subtree:!0});function e(o){const s={};return o.integrity&&(s.integrity=o.integrity),o.referrerPolicy&&(s.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?s.credentials="include":o.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(o){if(o.ep)return;o.ep=!0;const s=e(o);fetch(o.href,s)}})();const Oe="modulepreload",Ne=function(t){return"/pqkms-web/"+t},Jt={},qe=function(n,e,r){if(!e||e.length===0)return n();const o=document.getElementsByTagName("link");return Promise.all(e.map(s=>{if(s=Ne(s),s in Jt)return;Jt[s]=!0;const c=s.endsWith(".css"),i=c?'[rel="stylesheet"]':"";if(!!r)for(let d=o.length-1;d>=0;d--){const f=o[d];if(f.href===s&&(!c||f.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${s}"]${i}`))return;const l=document.createElement("link");if(l.rel=c?"stylesheet":Oe,c||(l.as="script",l.crossOrigin=""),l.href=s,document.head.appendChild(l),c)return new Promise((d,f)=>{l.addEventListener("load",d),l.addEventListener("error",()=>f(new Error(`Unable to preload CSS for ${s}`)))})})).then(()=>n()).catch(s=>{const c=new Event("vite:preloadError",{cancelable:!0});if(c.payload=s,window.dispatchEvent(c),!c.defaultPrevented)throw s})},ke=function(){const t={argon2d:0,argon2i:1,argon2id:2};function n(i){if(n._promise)return n._promise;if(n._module)return Promise.resolve(n._module);let a=e().then(l=>new Promise(d=>{l.postRun.push(()=>d(l))}));return n._promise=a,a.then(l=>(n._module=l,delete n._promise,l))}function e(){return qe(()=>import("./argon2-89744aa5.js"),[]).then(i=>i.default)}function r(i,a){const l=a instanceof Uint8Array||a instanceof Array?a:o(a),d=new Uint8Array([...l,0]);return i.allocate(d,"i8",i.ALLOC_NORMAL)}function o(i){if(typeof TextEncoder=="function")return new TextEncoder().encode(i);if(typeof Buffer=="function")return Buffer.from(i);throw new Error("Don't know how to decode UTF8")}function s(i){const a=i.mem||1024;return n().then(l=>{const d=i.time||1,f=i.parallelism||1,x=r(l,i.pass),v=i.pass.length,p=r(l,i.salt),u=i.salt.length,h=l.allocate(new Array(i.hashLen||24),"i8",l.ALLOC_NORMAL),g=i.hashLen||24,b=l.allocate(new Array(512),"i8",l.ALLOC_NORMAL),y=512,A=i.type||t.argon2d,B=19;let m,_;try{_=l._argon2_hash(d,a,f,x,v,p,u,h,g,b,y,A,B)}catch(H){m=H}let S;if(_===0&&!m){let H="";const C=new Uint8Array(g);for(let O=0;O<g;O++){const k=l.HEAP8[h+O];C[O]=k,H+=("0"+(255&k).toString(16)).slice(-2)}const I=l.UTF8ToString(b);S={hash:C,hashHex:H,encoded:I}}else{try{m||(m=l.UTF8ToString(l._argon2_error_message(_)))}catch{}S={message:m,code:_}}try{l._free(x),l._free(p),l._free(h),l._free(b)}catch{}if(m)throw S;return S})}function c(i){return n().then(a=>{const l=r(a,i.pass),d=i.pass.length,f=r(a,i.encoded);let x=i.type;if(x===void 0){let h=i.encoded.split("$")[1];h&&(h=h.replace("a","A"),x=t[h]||t.argon2d)}let v,p;try{p=a._argon2_verify(f,l,d,x)}catch(h){v=h}let u;if(p||v){try{v||(v=a.UTF8ToString(a._argon2_error_message(p)))}catch{}u={message:v,code:p}}try{a._free(l),a._free(f)}catch{}if(v)throw u;return u})}return{ArgonType:t,hash:s,verify:c}}(),{ArgonType:$e,hash:De,verify:Er}=ke;/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ue=BigInt(0),Lt=BigInt(1),Pe=BigInt(2),Ut=t=>t instanceof Uint8Array,Ve=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function wt(t){if(!Ut(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=Ve[t[e]];return n}function he(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function jt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function pt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,s=t.slice(o,o+2),c=Number.parseInt(s,16);if(Number.isNaN(c)||c<0)throw new Error("Invalid byte sequence");e[r]=c}return e}function Q(t){return jt(wt(t))}function Kt(t){if(!Ut(t))throw new Error("Uint8Array expected");return jt(wt(Uint8Array.from(t).reverse()))}function F(t,n){return pt(t.toString(16).padStart(n*2,"0"))}function zt(t,n){return F(t,n).reverse()}function Ze(t){return pt(he(t))}function Y(t,n,e){let r;if(typeof n=="string")try{r=pt(n)}catch(s){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${s}`)}else if(Ut(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function P(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!Ut(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function je(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function ut(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ke(t){let n;for(n=0;t>ue;t>>=Lt,n+=1);return n}function ze(t,n){return t>>BigInt(n)&Lt}const Ge=(t,n,e)=>t|(e?Lt:ue)<<BigInt(n),Gt=t=>(Pe<<BigInt(t-1))-Lt,Ct=t=>new Uint8Array(t),Ft=t=>Uint8Array.from(t);function de(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ct(t),o=Ct(t),s=0;const c=()=>{r.fill(1),o.fill(0),s=0},i=(...f)=>e(o,r,...f),a=(f=Ct())=>{o=i(Ft([0]),f),r=i(),f.length!==0&&(o=i(Ft([1]),f),r=i())},l=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let f=0;const x=[];for(;f<n;){r=i();const v=r.slice();x.push(v),f+=r.length}return P(...x)};return(f,x)=>{c(),a(f);let v;for(;!(v=x(l()));)a();return c(),v}}const Ye={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function bt(t,n,e={}){const r=(o,s,c)=>{const i=Ye[s];if(typeof i!="function")throw new Error(`Invalid validator "${s}", expected function`);const a=t[o];if(!(c&&a===void 0)&&!i(a,t))throw new Error(`Invalid param ${String(o)}=${a} (${typeof a}), expected ${s}`)};for(const[o,s]of Object.entries(n))r(o,s,!1);for(const[o,s]of Object.entries(e))r(o,s,!0);return t}const We=Object.freeze(Object.defineProperty({__proto__:null,bitGet:ze,bitLen:Ke,bitMask:Gt,bitSet:Ge,bytesToHex:wt,bytesToNumberBE:Q,bytesToNumberLE:Kt,concatBytes:P,createHmacDrbg:de,ensureBytes:Y,equalBytes:je,hexToBytes:pt,hexToNumber:jt,numberToBytesBE:F,numberToBytesLE:zt,numberToHexUnpadded:he,numberToVarBytesBE:Ze,utf8ToBytes:ut,validateObject:bt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const D=BigInt(0),q=BigInt(1),lt=BigInt(2),Me=BigInt(3),$t=BigInt(4),te=BigInt(5),ee=BigInt(8);BigInt(9);BigInt(16);function V(t,n){const e=t%n;return e>=D?e:n+e}function Xe(t,n,e){if(e<=D||n<D)throw new Error("Expected power/modulo > 0");if(e===q)return D;let r=q;for(;n>D;)n&q&&(r=r*t%e),t=t*t%e,n>>=q;return r}function Dt(t,n){if(t===D||n<=D)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=V(t,n),r=n,o=D,s=q;for(;e!==D;){const i=r/e,a=r%e,l=o-s*i;r=e,e=a,o=s,s=l}if(r!==q)throw new Error("invert: does not exist");return V(o,n)}function Qe(t){const n=(t-q)/lt;let e,r,o;for(e=t-q,r=0;e%lt===D;e/=lt,r++);for(o=lt;o<t&&Xe(o,n,t)!==t-q;o++);if(r===1){const c=(t+q)/$t;return function(a,l){const d=a.pow(l,c);if(!a.eql(a.sqr(d),l))throw new Error("Cannot find square root");return d}}const s=(e+q)/lt;return function(i,a){if(i.pow(a,n)===i.neg(i.ONE))throw new Error("Cannot find square root");let l=r,d=i.pow(i.mul(i.ONE,o),e),f=i.pow(a,s),x=i.pow(a,e);for(;!i.eql(x,i.ONE);){if(i.eql(x,i.ZERO))return i.ZERO;let v=1;for(let u=i.sqr(x);v<l&&!i.eql(u,i.ONE);v++)u=i.sqr(u);const p=i.pow(d,q<<BigInt(l-v-1));d=i.sqr(p),f=i.mul(f,p),x=i.mul(x,d),l=v}return f}}function Je(t){if(t%$t===Me){const n=(t+q)/$t;return function(r,o){const s=r.pow(o,n);if(!r.eql(r.sqr(s),o))throw new Error("Cannot find square root");return s}}if(t%ee===te){const n=(t-te)/ee;return function(r,o){const s=r.mul(o,lt),c=r.pow(s,n),i=r.mul(o,c),a=r.mul(r.mul(i,lt),c),l=r.mul(i,r.sub(a,r.ONE));if(!r.eql(r.sqr(l),o))throw new Error("Cannot find square root");return l}}return Qe(t)}const Fe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ge(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Fe.reduce((r,o)=>(r[o]="function",r),n);return bt(t,e)}function tn(t,n,e){if(e<D)throw new Error("Expected power > 0");if(e===D)return t.ONE;if(e===q)return n;let r=t.ONE,o=n;for(;e>D;)e&q&&(r=t.mul(r,o)),o=t.sqr(o),e>>=q;return r}function en(t,n){const e=new Array(n.length),r=n.reduce((s,c,i)=>t.is0(c)?s:(e[i]=s,t.mul(s,c)),t.ONE),o=t.inv(r);return n.reduceRight((s,c,i)=>t.is0(c)?s:(e[i]=t.mul(s,e[i]),t.mul(s,c)),o),e}function ye(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function we(t,n,e=!1,r={}){if(t<=D)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:s}=ye(t,n);if(s>2048)throw new Error("Field lengths over 2048 bytes are not supported");const c=Je(t),i=Object.freeze({ORDER:t,BITS:o,BYTES:s,MASK:Gt(o),ZERO:D,ONE:q,create:a=>V(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return D<=a&&a<t},is0:a=>a===D,isOdd:a=>(a&q)===q,neg:a=>V(-a,t),eql:(a,l)=>a===l,sqr:a=>V(a*a,t),add:(a,l)=>V(a+l,t),sub:(a,l)=>V(a-l,t),mul:(a,l)=>V(a*l,t),pow:(a,l)=>tn(i,a,l),div:(a,l)=>V(a*Dt(l,t),t),sqrN:a=>a*a,addN:(a,l)=>a+l,subN:(a,l)=>a-l,mulN:(a,l)=>a*l,inv:a=>Dt(a,t),sqrt:r.sqrt||(a=>c(i,a)),invertBatch:a=>en(i,a),cmov:(a,l,d)=>d?l:a,toBytes:a=>e?zt(a,s):F(a,s),fromBytes:a=>{if(a.length!==s)throw new Error(`Fp.fromBytes: expected ${s}, got ${a.length}`);return e?Kt(a):Q(a)}});return Object.freeze(i)}function pe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function be(t){const n=pe(t);return n+Math.ceil(n/2)}function nn(t,n,e=!1){const r=t.length,o=pe(n),s=be(n);if(r<16||r<s||r>1024)throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);const c=e?Q(t):Kt(t),i=V(c,n-q)+q;return e?zt(i,o):F(i,o)}function Pt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function me(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function Yt(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Pt(t.outputLen),Pt(t.blockLen)}function At(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function rn(t,n){me(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Rt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ee=t=>t instanceof Uint8Array,Tt=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),on=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!on)throw new Error("Non little-endian hardware is not supported");function sn(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function xt(t){if(typeof t=="string"&&(t=sn(t)),!Ee(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function cn(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!Ee(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}class xe{clone(){return this._cloneInto()}}function ve(t){const n=r=>t().update(xt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function an(t=32){if(Rt&&typeof Rt.getRandomValues=="function")return Rt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function ln(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),s=BigInt(4294967295),c=Number(e>>o&s),i=Number(e&s),a=r?4:0,l=r?0:4;t.setUint32(n+a,c,r),t.setUint32(n+l,i,r)}class fn extends xe{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Tt(this.buffer)}update(n){At(this);const{view:e,buffer:r,blockLen:o}=this;n=xt(n);const s=n.length;for(let c=0;c<s;){const i=Math.min(o-this.pos,s-c);if(i===o){const a=Tt(n);for(;o<=s-c;c+=o)this.process(a,c);continue}r.set(n.subarray(c,c+i),this.pos),this.pos+=i,c+=i,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){At(this),rn(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:s}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>o-c&&(this.process(r,0),c=0);for(let f=c;f<o;f++)e[f]=0;ln(r,o-8,BigInt(this.length*8),s),this.process(r,0);const i=Tt(n),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=a/4,d=this.get();if(l>d.length)throw new Error("_sha2: outputLen bigger than state");for(let f=0;f<l;f++)i.setUint32(4*f,d[f],s)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:s,destroyed:c,pos:i}=this;return n.length=o,n.pos=i,n.finished=s,n.destroyed=c,o%e&&n.buffer.set(r),n}}const St=BigInt(2**32-1),Vt=BigInt(32);function _e(t,n=!1){return n?{h:Number(t&St),l:Number(t>>Vt&St)}:{h:Number(t>>Vt&St)|0,l:Number(t&St)|0}}function un(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:s,l:c}=_e(t[o],n);[e[o],r[o]]=[s,c]}return[e,r]}const hn=(t,n)=>BigInt(t>>>0)<<Vt|BigInt(n>>>0),dn=(t,n,e)=>t>>>e,gn=(t,n,e)=>t<<32-e|n>>>e,yn=(t,n,e)=>t>>>e|n<<32-e,wn=(t,n,e)=>t<<32-e|n>>>e,pn=(t,n,e)=>t<<64-e|n>>>e-32,bn=(t,n,e)=>t>>>e-32|n<<64-e,mn=(t,n)=>n,En=(t,n)=>t,xn=(t,n,e)=>t<<e|n>>>32-e,vn=(t,n,e)=>n<<e|t>>>32-e,_n=(t,n,e)=>n<<e-32|t>>>64-e,Sn=(t,n,e)=>t<<e-32|n>>>64-e;function An(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const Bn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),Ln=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,Un=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),In=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,Hn=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),Cn=(t,n,e,r,o,s)=>n+e+r+o+s+(t/2**32|0)|0,Rn={fromBig:_e,split:un,toBig:hn,shrSH:dn,shrSL:gn,rotrSH:yn,rotrSL:wn,rotrBH:pn,rotrBL:bn,rotr32H:mn,rotr32L:En,rotlSH:xn,rotlSL:vn,rotlBH:_n,rotlBL:Sn,add:An,add3L:Bn,add3H:Ln,add4L:Un,add4H:In,add5H:Cn,add5L:Hn},L=Rn,[Tn,On]=(()=>L.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),rt=new Uint32Array(80),ot=new Uint32Array(80);class Se extends fn{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:s,Cl:c,Dh:i,Dl:a,Eh:l,El:d,Fh:f,Fl:x,Gh:v,Gl:p,Hh:u,Hl:h}=this;return[n,e,r,o,s,c,i,a,l,d,f,x,v,p,u,h]}set(n,e,r,o,s,c,i,a,l,d,f,x,v,p,u,h){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=s|0,this.Cl=c|0,this.Dh=i|0,this.Dl=a|0,this.Eh=l|0,this.El=d|0,this.Fh=f|0,this.Fl=x|0,this.Gh=v|0,this.Gl=p|0,this.Hh=u|0,this.Hl=h|0}process(n,e){for(let y=0;y<16;y++,e+=4)rt[y]=n.getUint32(e),ot[y]=n.getUint32(e+=4);for(let y=16;y<80;y++){const A=rt[y-15]|0,B=ot[y-15]|0,m=L.rotrSH(A,B,1)^L.rotrSH(A,B,8)^L.shrSH(A,B,7),_=L.rotrSL(A,B,1)^L.rotrSL(A,B,8)^L.shrSL(A,B,7),S=rt[y-2]|0,H=ot[y-2]|0,C=L.rotrSH(S,H,19)^L.rotrBH(S,H,61)^L.shrSH(S,H,6),I=L.rotrSL(S,H,19)^L.rotrBL(S,H,61)^L.shrSL(S,H,6),O=L.add4L(_,I,ot[y-7],ot[y-16]),k=L.add4H(O,m,C,rt[y-7],rt[y-16]);rt[y]=k|0,ot[y]=O|0}let{Ah:r,Al:o,Bh:s,Bl:c,Ch:i,Cl:a,Dh:l,Dl:d,Eh:f,El:x,Fh:v,Fl:p,Gh:u,Gl:h,Hh:g,Hl:b}=this;for(let y=0;y<80;y++){const A=L.rotrSH(f,x,14)^L.rotrSH(f,x,18)^L.rotrBH(f,x,41),B=L.rotrSL(f,x,14)^L.rotrSL(f,x,18)^L.rotrBL(f,x,41),m=f&v^~f&u,_=x&p^~x&h,S=L.add5L(b,B,_,On[y],ot[y]),H=L.add5H(S,g,A,m,Tn[y],rt[y]),C=S|0,I=L.rotrSH(r,o,28)^L.rotrBH(r,o,34)^L.rotrBH(r,o,39),O=L.rotrSL(r,o,28)^L.rotrBL(r,o,34)^L.rotrBL(r,o,39),k=r&s^r&i^s&i,X=o&c^o&a^c&a;g=u|0,b=h|0,u=v|0,h=p|0,v=f|0,p=x|0,{h:f,l:x}=L.add(l|0,d|0,H|0,C|0),l=i|0,d=a|0,i=s|0,a=c|0,s=r|0,c=o|0;const w=L.add3L(C,O,X);r=L.add3H(w,H,I,k),o=w|0}({h:r,l:o}=L.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:s,l:c}=L.add(this.Bh|0,this.Bl|0,s|0,c|0),{h:i,l:a}=L.add(this.Ch|0,this.Cl|0,i|0,a|0),{h:l,l:d}=L.add(this.Dh|0,this.Dl|0,l|0,d|0),{h:f,l:x}=L.add(this.Eh|0,this.El|0,f|0,x|0),{h:v,l:p}=L.add(this.Fh|0,this.Fl|0,v|0,p|0),{h:u,l:h}=L.add(this.Gh|0,this.Gl|0,u|0,h|0),{h:g,l:b}=L.add(this.Hh|0,this.Hl|0,g|0,b|0),this.set(r,o,s,c,i,a,l,d,f,x,v,p,u,h,g,b)}roundClean(){rt.fill(0),ot.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Nn extends Se{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const ne=ve(()=>new Se),Ae=ve(()=>new Nn);class Be extends xe{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,Yt(n);const r=xt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,s=new Uint8Array(o);s.set(r.length>o?n.create().update(r).digest():r);for(let c=0;c<s.length;c++)s[c]^=54;this.iHash.update(s),this.oHash=n.create();for(let c=0;c<s.length;c++)s[c]^=106;this.oHash.update(s),s.fill(0)}update(n){return At(this),this.iHash.update(n),this}digestInto(n){At(this),me(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:s,blockLen:c,outputLen:i}=this;return n=n,n.finished=o,n.destroyed=s,n.blockLen=c,n.outputLen=i,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const It=(t,n,e)=>new Be(t,n).update(e).digest();It.create=(t,n)=>new Be(t,n);function qn(t,n,e){return Yt(t),e===void 0&&(e=new Uint8Array(t.outputLen)),It(t,xt(e),xt(n))}const Ot=new Uint8Array([0]),re=new Uint8Array;function kn(t,n,e,r=32){if(Yt(t),Pt(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const o=Math.ceil(r/t.outputLen);e===void 0&&(e=re);const s=new Uint8Array(o*t.outputLen),c=It.create(t,n),i=c._cloneInto(),a=new Uint8Array(c.outputLen);for(let l=0;l<o;l++)Ot[0]=l+1,i.update(l===0?re:a).update(e).update(Ot).digestInto(a),s.set(a,t.outputLen*l),c._cloneInto(i);return c.destroy(),i.destroy(),a.fill(0),Ot.fill(0),s.slice(0,r)}const oe=(t,n,e,r,o)=>kn(t,qn(t,n,e),r,o);function Nt(t,n){let e=F(t,n);return btoa(Array.from(e,r=>String.fromCharCode(r)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}class Zt extends Error{constructor(e){super(e);K(this,"error_type");this.error_type=e}err(){return this.error_type}}function J(t){return typeof t=="string"?ut(t):t}class $n{constructor(n,e){K(this,"EcGroup");K(this,"Fq");K(this,"hashToCurve");K(this,"coordinateSize");this.EcGroup=n,this.Fq=we(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}curveName(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P-256";if(n===384)return"P-384";if(n===521)return"P-521";throw new Zt("UnknownCurveType")}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=Q(e);if(r===BigInt(0))return this.blind(n);let o=J(n),s=this.hashToCurve(o).multiply(r);if(s.equals(this.EcGroup.ProjectivePoint.ZERO))throw new Zt("HashedToInifinity");let c=this.EcGroup.ProjectivePoint.fromAffine(s.toAffine());return{hashed_password:n,blinder:r,clientRequestBytes:c.toHex(!1)}}async finalize(n,e){let r=this.EcGroup.ProjectivePoint.fromHex(n);if(r.assertValidity(),r.toHex(!1)==e.clientRequestBytes)throw Error("Server tried to attack the client during OPRF finalize step by replaying the client's request");let s=this.Fq.inv(e.blinder),c=r.multiply(s).toRawBytes(!1),i=P(F(e.hashed_password.length,2),J(e.hashed_password),F(c.length,2),c,J("Finalize")),a=await globalThis.crypto.subtle.digest("SHA-512",i.buffer);return new Uint8Array(a)}async login_key(n,e){const r=this.EcGroup.CURVE,o=this.EcGroup.ProjectivePoint,s=globalThis.crypto.subtle,c=P(J(e),J("LoginInfoSalt")),i=J("LoginInfo");let a=Q(oe(ne,n,c,i,512/8)),l=V(a,r.n),d=o.fromPrivateKey(l),f={crv:this.curveName(),d:Nt(l,r.nByteLength),ext:!0,key_ops:["sign"],kty:"EC",x:Nt(d.x,r.Fp.BYTES),y:Nt(d.y,r.Fp.BYTES)};return{loginKey:await s.importKey("jwk",f,{name:"ECDSA",namedCurve:this.curveName()},!0,["sign"]),publicKey:d.toRawBytes(!1)}}async lockbox_key(n,e){const r=globalThis.crypto.subtle,o=P(J(e),J("LockboxSalt")),s=J("LockboxKey");let c=oe(ne,n,o,s,256/8);return await r.importKey("raw",c,"AES-GCM",!1,["encrypt","decrypt","wrapKey","unwrapKey"])}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Dn=BigInt(0),qt=BigInt(1);function Pn(t,n){const e=(o,s)=>{const c=s.negate();return o?c:s},r=o=>{const s=Math.ceil(n/o)+1,c=2**(o-1);return{windows:s,windowSize:c}};return{constTimeNegate:e,unsafeLadder(o,s){let c=t.ZERO,i=o;for(;s>Dn;)s&qt&&(c=c.add(i)),i=i.double(),s>>=qt;return c},precomputeWindow(o,s){const{windows:c,windowSize:i}=r(s),a=[];let l=o,d=l;for(let f=0;f<c;f++){d=l,a.push(d);for(let x=1;x<i;x++)d=d.add(l),a.push(d);l=d.double()}return a},wNAF(o,s,c){const{windows:i,windowSize:a}=r(o);let l=t.ZERO,d=t.BASE;const f=BigInt(2**o-1),x=2**o,v=BigInt(o);for(let p=0;p<i;p++){const u=p*a;let h=Number(c&f);c>>=v,h>a&&(h-=x,c+=qt);const g=u,b=u+Math.abs(h)-1,y=p%2!==0,A=h<0;h===0?d=d.add(e(y,s[g])):l=l.add(e(A,s[b]))}return{p:l,f:d}},wNAFCached(o,s,c,i){const a=o._WINDOW_SIZE||1;let l=s.get(o);return l||(l=this.precomputeWindow(o,a),a!==1&&s.set(o,i(l))),this.wNAF(a,l,c)}}}function Le(t){return ge(t.Fp),bt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ye(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Vn(t){const n=Le(t);bt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Zn,hexToBytes:jn}=We,ft={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ft;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:Zn(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ft,e=typeof t=="string"?jn(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:s}=ft._parseInt(e.subarray(2)),{d:c,l:i}=ft._parseInt(s);if(i.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s:c}},hexFromSig(t){const n=l=>Number.parseInt(l[0],16)&8?"00"+l:l,e=l=>{const d=l.toString(16);return d.length&1?`0${d}`:d},r=n(e(t.s)),o=n(e(t.r)),s=r.length/2,c=o.length/2,i=e(s),a=e(c);return`30${e(c+s+4)}02${a}${o}02${i}${r}`}},W=BigInt(0),N=BigInt(1),st=BigInt(2),Bt=BigInt(3),se=BigInt(4);function Kn(t){const n=Vn(t),{Fp:e}=n,r=n.toBytes||((p,u,h)=>{const g=u.toAffine();return P(Uint8Array.from([4]),e.toBytes(g.x),e.toBytes(g.y))}),o=n.fromBytes||(p=>{const u=p.subarray(1),h=e.fromBytes(u.subarray(0,e.BYTES)),g=e.fromBytes(u.subarray(e.BYTES,2*e.BYTES));return{x:h,y:g}});function s(p){const{a:u,b:h}=n,g=e.sqr(p),b=e.mul(g,p);return e.add(e.add(b,e.mul(p,u)),h)}if(!e.eql(e.sqr(n.Gy),s(n.Gx)))throw new Error("bad generator point: equation left != right");function c(p){return typeof p=="bigint"&&W<p&&p<n.n}function i(p){if(!c(p))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(p){const{allowedPrivateKeyLengths:u,nByteLength:h,wrapPrivateKey:g,n:b}=n;if(u&&typeof p!="bigint"){if(p instanceof Uint8Array&&(p=wt(p)),typeof p!="string"||!u.includes(p.length))throw new Error("Invalid key");p=p.padStart(h*2,"0")}let y;try{y=typeof p=="bigint"?p:Q(Y("private key",p,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof p}`)}return g&&(y=V(y,b)),i(y),y}const l=new Map;function d(p){if(!(p instanceof f))throw new Error("ProjectivePoint expected")}class f{constructor(u,h,g){if(this.px=u,this.py=h,this.pz=g,u==null||!e.isValid(u))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(g==null||!e.isValid(g))throw new Error("z required")}static fromAffine(u){const{x:h,y:g}=u||{};if(!u||!e.isValid(h)||!e.isValid(g))throw new Error("invalid affine point");if(u instanceof f)throw new Error("projective point not allowed");const b=y=>e.eql(y,e.ZERO);return b(h)&&b(g)?f.ZERO:new f(h,g,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(u){const h=e.invertBatch(u.map(g=>g.pz));return u.map((g,b)=>g.toAffine(h[b])).map(f.fromAffine)}static fromHex(u){const h=f.fromAffine(o(Y("pointHex",u)));return h.assertValidity(),h}static fromPrivateKey(u){return f.BASE.multiply(a(u))}_setWindowSize(u){this._WINDOW_SIZE=u,l.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:u,y:h}=this.toAffine();if(!e.isValid(u)||!e.isValid(h))throw new Error("bad point: x or y not FE");const g=e.sqr(h),b=s(u);if(!e.eql(g,b))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:u}=this.toAffine();if(e.isOdd)return!e.isOdd(u);throw new Error("Field doesn't support isOdd")}equals(u){d(u);const{px:h,py:g,pz:b}=this,{px:y,py:A,pz:B}=u,m=e.eql(e.mul(h,B),e.mul(y,b)),_=e.eql(e.mul(g,B),e.mul(A,b));return m&&_}negate(){return new f(this.px,e.neg(this.py),this.pz)}double(){const{a:u,b:h}=n,g=e.mul(h,Bt),{px:b,py:y,pz:A}=this;let B=e.ZERO,m=e.ZERO,_=e.ZERO,S=e.mul(b,b),H=e.mul(y,y),C=e.mul(A,A),I=e.mul(b,y);return I=e.add(I,I),_=e.mul(b,A),_=e.add(_,_),B=e.mul(u,_),m=e.mul(g,C),m=e.add(B,m),B=e.sub(H,m),m=e.add(H,m),m=e.mul(B,m),B=e.mul(I,B),_=e.mul(g,_),C=e.mul(u,C),I=e.sub(S,C),I=e.mul(u,I),I=e.add(I,_),_=e.add(S,S),S=e.add(_,S),S=e.add(S,C),S=e.mul(S,I),m=e.add(m,S),C=e.mul(y,A),C=e.add(C,C),S=e.mul(C,I),B=e.sub(B,S),_=e.mul(C,H),_=e.add(_,_),_=e.add(_,_),new f(B,m,_)}add(u){d(u);const{px:h,py:g,pz:b}=this,{px:y,py:A,pz:B}=u;let m=e.ZERO,_=e.ZERO,S=e.ZERO;const H=n.a,C=e.mul(n.b,Bt);let I=e.mul(h,y),O=e.mul(g,A),k=e.mul(b,B),X=e.add(h,g),w=e.add(y,A);X=e.mul(X,w),w=e.add(I,O),X=e.sub(X,w),w=e.add(h,b);let E=e.add(y,B);return w=e.mul(w,E),E=e.add(I,k),w=e.sub(w,E),E=e.add(g,b),m=e.add(A,B),E=e.mul(E,m),m=e.add(O,k),E=e.sub(E,m),S=e.mul(H,w),m=e.mul(C,k),S=e.add(m,S),m=e.sub(O,S),S=e.add(O,S),_=e.mul(m,S),O=e.add(I,I),O=e.add(O,I),k=e.mul(H,k),w=e.mul(C,w),O=e.add(O,k),k=e.sub(I,k),k=e.mul(H,k),w=e.add(w,k),I=e.mul(O,w),_=e.add(_,I),I=e.mul(E,w),m=e.mul(X,m),m=e.sub(m,I),I=e.mul(X,O),S=e.mul(E,S),S=e.add(S,I),new f(m,_,S)}subtract(u){return this.add(u.negate())}is0(){return this.equals(f.ZERO)}wNAF(u){return v.wNAFCached(this,l,u,h=>{const g=e.invertBatch(h.map(b=>b.pz));return h.map((b,y)=>b.toAffine(g[y])).map(f.fromAffine)})}multiplyUnsafe(u){const h=f.ZERO;if(u===W)return h;if(i(u),u===N)return this;const{endo:g}=n;if(!g)return v.unsafeLadder(this,u);let{k1neg:b,k1:y,k2neg:A,k2:B}=g.splitScalar(u),m=h,_=h,S=this;for(;y>W||B>W;)y&N&&(m=m.add(S)),B&N&&(_=_.add(S)),S=S.double(),y>>=N,B>>=N;return b&&(m=m.negate()),A&&(_=_.negate()),_=new f(e.mul(_.px,g.beta),_.py,_.pz),m.add(_)}multiply(u){i(u);let h=u,g,b;const{endo:y}=n;if(y){const{k1neg:A,k1:B,k2neg:m,k2:_}=y.splitScalar(h);let{p:S,f:H}=this.wNAF(B),{p:C,f:I}=this.wNAF(_);S=v.constTimeNegate(A,S),C=v.constTimeNegate(m,C),C=new f(e.mul(C.px,y.beta),C.py,C.pz),g=S.add(C),b=H.add(I)}else{const{p:A,f:B}=this.wNAF(h);g=A,b=B}return f.normalizeZ([g,b])[0]}multiplyAndAddUnsafe(u,h,g){const b=f.BASE,y=(B,m)=>m===W||m===N||!B.equals(b)?B.multiplyUnsafe(m):B.multiply(m),A=y(this,h).add(y(u,g));return A.is0()?void 0:A}toAffine(u){const{px:h,py:g,pz:b}=this,y=this.is0();u==null&&(u=y?e.ONE:e.inv(b));const A=e.mul(h,u),B=e.mul(g,u),m=e.mul(b,u);if(y)return{x:e.ZERO,y:e.ZERO};if(!e.eql(m,e.ONE))throw new Error("invZ was invalid");return{x:A,y:B}}isTorsionFree(){const{h:u,isTorsionFree:h}=n;if(u===N)return!0;if(h)return h(f,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:u,clearCofactor:h}=n;return u===N?this:h?h(f,this):this.multiplyUnsafe(n.h)}toRawBytes(u=!0){return this.assertValidity(),r(f,this,u)}toHex(u=!0){return wt(this.toRawBytes(u))}}f.BASE=new f(n.Gx,n.Gy,e.ONE),f.ZERO=new f(e.ZERO,e.ONE,e.ZERO);const x=n.nBitLength,v=Pn(f,n.endo?Math.ceil(x/2):x);return{CURVE:n,ProjectivePoint:f,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder:c}}function zn(t){const n=Le(t);return bt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Gn(t){const n=zn(t),{Fp:e,n:r}=n,o=e.BYTES+1,s=2*e.BYTES+1;function c(w){return W<w&&w<e.ORDER}function i(w){return V(w,r)}function a(w){return Dt(w,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:d,weierstrassEquation:f,isWithinCurveOrder:x}=Kn({...n,toBytes(w,E,U){const T=E.toAffine(),R=e.toBytes(T.x),$=P;return U?$(Uint8Array.from([E.hasEvenY()?2:3]),R):$(Uint8Array.from([4]),R,e.toBytes(T.y))},fromBytes(w){const E=w.length,U=w[0],T=w.subarray(1);if(E===o&&(U===2||U===3)){const R=Q(T);if(!c(R))throw new Error("Point is not on curve");const $=f(R);let Z=e.sqrt($);const j=(Z&N)===N;return(U&1)===1!==j&&(Z=e.neg(Z)),{x:R,y:Z}}else if(E===s&&U===4){const R=e.fromBytes(T.subarray(0,e.BYTES)),$=e.fromBytes(T.subarray(e.BYTES,2*e.BYTES));return{x:R,y:$}}else throw new Error(`Point of length ${E} was invalid. Expected ${o} compressed bytes or ${s} uncompressed bytes`)}}),v=w=>wt(F(w,n.nByteLength));function p(w){const E=r>>N;return w>E}function u(w){return p(w)?i(-w):w}const h=(w,E,U)=>Q(w.slice(E,U));class g{constructor(E,U,T){this.r=E,this.s=U,this.recovery=T,this.assertValidity()}static fromCompact(E){const U=n.nByteLength;return E=Y("compactSignature",E,U*2),new g(h(E,0,U),h(E,U,2*U))}static fromDER(E){const{r:U,s:T}=ft.toSig(Y("DER",E));return new g(U,T)}assertValidity(){if(!x(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!x(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(E){return new g(this.r,this.s,E)}recoverPublicKey(E){const{r:U,s:T,recovery:R}=this,$=_(Y("msgHash",E));if(R==null||![0,1,2,3].includes(R))throw new Error("recovery id invalid");const Z=R===2||R===3?U+n.n:U;if(Z>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=R&1?"03":"02",tt=l.fromHex(j+v(Z)),et=a(Z),ht=i(-$*et),mt=i(T*et),nt=l.BASE.multiplyAndAddUnsafe(tt,ht,mt);if(!nt)throw new Error("point at infinify");return nt.assertValidity(),nt}hasHighS(){return p(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,i(-this.s),this.recovery):this}toDERRawBytes(){return pt(this.toDERHex())}toDERHex(){return ft.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return pt(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}const b={isValidPrivateKey(w){try{return d(w),!0}catch{return!1}},normPrivateKeyToScalar:d,randomPrivateKey:()=>{const w=be(n.n);return nn(n.randomBytes(w),n.n)},precompute(w=8,E=l.BASE){return E._setWindowSize(w),E.multiply(BigInt(3)),E}};function y(w,E=!0){return l.fromPrivateKey(w).toRawBytes(E)}function A(w){const E=w instanceof Uint8Array,U=typeof w=="string",T=(E||U)&&w.length;return E?T===o||T===s:U?T===2*o||T===2*s:w instanceof l}function B(w,E,U=!0){if(A(w))throw new Error("first arg must be private key");if(!A(E))throw new Error("second arg must be public key");return l.fromHex(E).multiply(d(w)).toRawBytes(U)}const m=n.bits2int||function(w){const E=Q(w),U=w.length*8-n.nBitLength;return U>0?E>>BigInt(U):E},_=n.bits2int_modN||function(w){return i(m(w))},S=Gt(n.nBitLength);function H(w){if(typeof w!="bigint")throw new Error("bigint expected");if(!(W<=w&&w<S))throw new Error(`bigint expected < 2^${n.nBitLength}`);return F(w,n.nByteLength)}function C(w,E,U=I){if(["recovered","canonical"].some(at=>at in U))throw new Error("sign() legacy options not supported");const{hash:T,randomBytes:R}=n;let{lowS:$,prehash:Z,extraEntropy:j}=U;$==null&&($=!0),w=Y("msgHash",w),Z&&(w=Y("prehashed msgHash",T(w)));const tt=_(w),et=d(E),ht=[H(et),H(tt)];if(j!=null){const at=j===!0?R(e.BYTES):j;ht.push(Y("extraEntropy",at))}const mt=P(...ht),nt=tt;function Ht(at){const dt=m(at);if(!x(dt))return;const Mt=a(dt),gt=l.BASE.multiply(dt).toAffine(),G=i(gt.x);if(G===W)return;const yt=i(Mt*i(nt+G*et));if(yt===W)return;let Xt=(gt.x===G?0:2)|Number(gt.y&N),Qt=yt;return $&&p(yt)&&(Qt=u(yt),Xt^=1),new g(G,Qt,Xt)}return{seed:mt,k2sig:Ht}}const I={lowS:n.lowS,prehash:!1},O={lowS:n.lowS,prehash:!1};function k(w,E,U=I){const{seed:T,k2sig:R}=C(w,E,U),$=n;return de($.hash.outputLen,$.nByteLength,$.hmac)(T,R)}l.BASE._setWindowSize(8);function X(w,E,U,T=O){var gt;const R=w;if(E=Y("msgHash",E),U=Y("publicKey",U),"strict"in T)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:Z}=T;let j,tt;try{if(typeof R=="string"||R instanceof Uint8Array)try{j=g.fromDER(R)}catch(G){if(!(G instanceof ft.Err))throw G;j=g.fromCompact(R)}else if(typeof R=="object"&&typeof R.r=="bigint"&&typeof R.s=="bigint"){const{r:G,s:yt}=R;j=new g(G,yt)}else throw new Error("PARSE");tt=l.fromHex(U)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;Z&&(E=n.hash(E));const{r:et,s:ht}=j,mt=_(E),nt=a(ht),Ht=i(mt*nt),at=i(et*nt),dt=(gt=l.BASE.multiplyAndAddUnsafe(tt,Ht,at))==null?void 0:gt.toAffine();return dt?i(dt.x)===et:!1}return{CURVE:n,getPublicKey:y,getSharedSecret:B,sign:k,verify:X,ProjectivePoint:l,Signature:g,utils:b}}function Yn(t,n){const e=t.ORDER;let r=W;for(let p=e-N;p%st===W;p/=st)r+=N;const o=r,s=st<<o-N-N,c=s*st,i=(e-N)/c,a=(i-N)/st,l=c-N,d=s,f=t.pow(n,i),x=t.pow(n,(i+N)/st);let v=(p,u)=>{let h=f,g=t.pow(u,l),b=t.sqr(g);b=t.mul(b,u);let y=t.mul(p,b);y=t.pow(y,a),y=t.mul(y,g),g=t.mul(y,u),b=t.mul(y,p);let A=t.mul(b,g);y=t.pow(A,d);let B=t.eql(y,t.ONE);g=t.mul(b,x),y=t.mul(A,h),b=t.cmov(g,b,B),A=t.cmov(y,A,B);for(let m=o;m>N;m--){let _=m-st;_=st<<_-N;let S=t.pow(A,_);const H=t.eql(S,t.ONE);g=t.mul(b,h),h=t.mul(h,h),S=t.mul(A,h),b=t.cmov(g,b,H),A=t.cmov(S,A,H)}return{isValid:B,value:b}};if(t.ORDER%se===Bt){const p=(t.ORDER-Bt)/se,u=t.sqrt(t.neg(n));v=(h,g)=>{let b=t.sqr(g);const y=t.mul(h,g);b=t.mul(b,y);let A=t.pow(b,p);A=t.mul(A,y);const B=t.mul(A,u),m=t.mul(t.sqr(A),g),_=t.eql(m,h);let S=t.cmov(B,A,_);return{isValid:_,value:S}}}return v}function Wn(t,n){if(ge(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Yn(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,s,c,i,a,l,d,f;o=t.sqr(r),o=t.mul(o,n.Z),s=t.sqr(o),s=t.add(s,o),c=t.add(s,t.ONE),c=t.mul(c,n.B),i=t.cmov(n.Z,t.neg(s),!t.eql(s,t.ZERO)),i=t.mul(i,n.A),s=t.sqr(c),l=t.sqr(i),a=t.mul(l,n.A),s=t.add(s,a),s=t.mul(s,c),l=t.mul(l,i),a=t.mul(l,n.B),s=t.add(s,a),d=t.mul(o,c);const{isValid:x,value:v}=e(s,l);f=t.mul(o,r),f=t.mul(f,v),d=t.cmov(d,c,x),f=t.cmov(f,v,x);const p=t.isOdd(r)===t.isOdd(f);return f=t.cmov(t.neg(f),f,p),d=t.div(d,i),{x:d,y:f}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Mn(t){return{hash:t,hmac:(n,...e)=>It(t,n,cn(...e)),randomBytes:an}}function Xn(t,n){const e=r=>Gn({...t,...Mn(r)});return Object.freeze({...e(n),create:e})}function Qn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return ut(t);throw new Error("DST must be Uint8Array or string")}const Jn=Q;function it(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function Fn(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function vt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Wt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function tr(t,n,e,r){vt(t),vt(n),Wt(e),n.length>255&&(n=r(P(ut("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:s}=r,c=Math.ceil(e/o);if(c>255)throw new Error("Invalid xmd length");const i=P(n,it(n.length,1)),a=it(0,s),l=it(e,2),d=new Array(c),f=r(P(a,t,l,it(0,1),i));d[0]=r(P(f,it(1,1),i));for(let v=1;v<=c;v++){const p=[Fn(f,d[v-1]),it(v+1,1),i];d[v]=r(P(...p))}return P(...d).slice(0,e)}function er(t,n,e,r,o){if(vt(t),vt(n),Wt(e),n.length>255){const s=Math.ceil(2*r/8);n=o.create({dkLen:s}).update(ut("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(it(e,2)).update(n).update(it(n.length,1)).digest()}function ie(t,n,e){bt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:s,hash:c,expand:i,DST:a}=e;vt(t),Wt(n);const l=Qn(a),d=r.toString(2).length,f=Math.ceil((d+o)/8),x=n*s*f;let v;if(i==="xmd")v=tr(t,l,x,c);else if(i==="xof")v=er(t,l,x,o,c);else if(i==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');const p=new Array(n);for(let u=0;u<n;u++){const h=new Array(s);for(let g=0;g<s;g++){const b=f*(g+u*s),y=v.subarray(b,b+f);h[g]=V(Jn(y),r)}p[u]=h}return p}function nr(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const s=ie(r,2,{...e,DST:e.DST,...o}),c=t.fromAffine(n(s[0])),i=t.fromAffine(n(s[1])),a=c.add(i).clearCofactor();return a.assertValidity(),a},encodeToCurve(r,o){const s=ie(r,1,{...e,DST:e.encodeDST,...o}),c=t.fromAffine(n(s[0])).clearCofactor();return c.assertValidity(),c}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const rr=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),_t=we(rr),Ue=_t.create(BigInt("-3")),Ie=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),He=Xn({a:Ue,b:Ie,Fp:_t,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},Ae),or=He,sr=(()=>Wn(_t,{A:Ue,B:Ie,Z:_t.create(BigInt("-12"))}))(),ir=(()=>nr(or.ProjectivePoint,t=>sr(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:_t.ORDER,m:1,k:192,expand:"xmd",hash:Ae}))(),cr=(()=>ir.hashToCurve)(),ar={time:2,mem:19456,parallelism:1,type:$e.Argon2di},kt=t=>typeof t>"u";function M(t){if(!t)throw EvalError("Assertion failed")}function lr(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),o=t.byteLength==n.byteLength,s=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let c=0;c<s;c++)o&&(o=e[c]===r[c]);return o}class Ce extends Error{constructor(n){super(n),this.name="ValidationError"}}const ce=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},Et=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),ae=function(t){let n=new Uint8Array(t);return btoa(Array.from(n,e=>String.fromCharCode(e)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},le=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),o=new DataView(r),s=0;return n==="little"?[...atob(t)].slice().reverse().forEach(c=>o.setUint8(s++,c.codePointAt(0))):[...atob(t)].forEach(c=>o.setUint8(s++,c.codePointAt(0))),r.slice(0,s)},fr=async(t,n="little")=>{M(t.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await z.hsm().exportKey("jwk",t);M(!kt(e.kty)&&!kt(e.e)&&!kt(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const r=le(e.e);return M(r.byteLength==1&&new DataView(r).getUint8(0)===3),le(e.n,n)},ct=class ct{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return ct.CRYPTO.subtle}uuid(){return ct.CRYPTO.randomUUID()}async sgx_rsa_key(){const n=new Uint8Array([3]),e=["sign","verify"],r={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:n,hash:"SHA-256"};return await ct.hsm().generateKey(r,!0,e)}async sign_enclave(n,e){return M(e.type==="private"),M(e.algorithm.name==="RSASSA-PKCS1-v1_5"),ct.hsm().sign(e.algorithm.name,e,n)}async verify_enclave(n,e,r){return M(r.algorithm.name==="RSASSA-PKCS1-v1_5"),M(r.type==="public"),ct.hsm().verify(r.algorithm.name,r,e,n)}};K(ct,"CRYPTO",globalThis.crypto);let z=ct;const fe={attestation:"/v0/admin/attestation",registration_init:"/v0/admin/reg_init",enclave_list:"/v0/admin/enclaves",registration_finish:"/v0/admin/reg_finish"};class ur{constructor(n){K(this,"discoveryURL");K(this,"baseURL");K(this,"oprfClient");K(this,"oprfClientData",null);K(this,"urlDirectory",null);this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new $n(He,cr)}async computeOprfClientData(n,e){for(let r=0;r<5;r++){let o=await gr(e.domain_name,e.email_addr,n,r);try{return this.oprfClientData=this.oprfClient.blind(o),this.oprfClientData}catch(s){if(s instanceof Zt&&s.err()=="HashedToInifinity")continue;throw s}}throw new Error("Unusable password!")}async parseServerResponse(n){if(n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`Server returned unexpected response with code: ${e.code} and message: ${e.message}`)}else{const e=await n.json();throw new Error(`Server error: ${e.code} => ${e.message}`)}}async fetchDirectory(){if(this.urlDirectory)return this.urlDirectory;try{const n=await fetch(this.discoveryURL,{mode:"cors"});if(n.status>=200&&n.status<300){let e=await n.json();this.urlDirectory=e.v0}else this.urlDirectory=fe}catch{this.urlDirectory=fe}return this.urlDirectory}async fetchEnclaveList(){let n=await this.fetchDirectory();const e=`${this.baseURL}${n.enclave_list}`,r=await fetch(e,{mode:"cors"});return await this.parseServerResponse(r)}async signEnclaves(n,e,r){const o=new z;M(n.type==="private"),M(e.type==="public");let s=await fr(e,"big"),c={user_info:null,server_nonce:null,signer_modulus:Et(s),signed_enclaves:[]};for(let i of r.enclaves){const a=ce(i.tbs_data),l=ce(i.sighash),d=await z.hsm().digest("SHA-256",a);let f={is_ok:!1,signature:"",enclave_name:i.enclave_name,config:i.config};if(!lr(l,d))f.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const x=await o.sign_enclave(a,n);f.is_ok=!0,f.signature=Et(x),c.signed_enclaves.push(f)}}return c}async pssSign(n,e,r,o){const s=await z.hsm().exportKey("pkcs8",o.privateKey),c=await z.hsm().importKey("pkcs8",s,{name:"RSA-PSS",hash:"SHA-256"},!1,["sign"]);let i=P(ut(n),ut(e),r),a=await z.hsm().sign({name:"RSA-PSS",saltLength:32},c,i);return new Uint8Array(a)}async regFinalMsg(n,e,r,o,s){const c=await this.pssSign(n.user_info.domain_name,n.user_info.email_addr,e,r),i=await z.hsm().sign({name:"ECDSA",hash:"SHA-384"},o,c);let a=globalThis.crypto.getRandomValues(new Uint8Array(12));const l=await z.hsm().wrapKey("pkcs8",r.privateKey,s,{name:"AES-GCM",iv:a}),d=`${ae(a)}.${ae(l)}`;return{server_nonce:n.server_nonce,aead_data:n.aead_data,user_pub:Et(e),user_pub_sig:Et(c),oprf_pop_sig:Et(i),aux_data:d}}async regInit(n,e,r){const{privateKey:o,publicKey:s}=r;M(o.type==="private"),M(s.type==="public");let c=await this.fetchDirectory(),i=await this.fetchEnclaveList(),a=await this.signEnclaves(o,s,i);await this.computeOprfClientData(n,e),e.auth_data=this.oprfClientData.clientRequestBytes,a.user_info=e,a.server_nonce=i.resp_challenge;let l=`${this.baseURL}${c.registration_init}`,d=await fetch(l,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});return this.parseServerResponse(d)}async regFinal(n,e){const r=await this.fetchDirectory(),o=await this.oprfClient.finalize(n.user_info.auth_data,this.oprfClientData),{loginKey:s,publicKey:c}=await this.oprfClient.login_key(o,this.oprfClientData.hashed_password),i=await this.oprfClient.lockbox_key(o,this.oprfClientData.hashed_password),a=await this.regFinalMsg(n,c,e,s,i);let l=`${this.baseURL}${r.registration_finish}`;const d=JSON.stringify(a);let f=await fetch(l,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:d});return this.parseServerResponse(f)}}function hr(t){const n=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!t.match(n))throw new Ce("Invalid domain prefix. Must be a valid domain component")}function dr(t){if(t.length<8)throw new Ce("Invalid password. Must be at least 8 characters")}async function gr(t,n,e,r){let o=e+t+n+e;if(r!=null)for(let a=0;a<r;a++)o=`${e}${o}${e}`;const s=new TextEncoder().encode(o),c=new Uint8Array(await z.hsm().digest("SHA-256",s));return(await De({pass:e,salt:c,...ar})).hash}async function yr(t,n,e,r,o){hr(t),dr(e);const s=o||await new z().sgx_rsa_key();let c={domain_name:t,email_addr:n,auth_algo:"OPRF.P384-SHA384",auth_data:null},i=new ur(r);const a=await i.regInit(e,c,s);await i.regFinal(a,s)}async function wr(t){let n=new FormData(t),e=n.get("domain"),r=n.get("email"),o=n.get("password");console.log(`FormData: ${e} => ${r} => ${o}`),await yr(e,r,o,"https://registrar.pqkms.dev:8443")}const pr=t=>{if(t.preventDefault(),t.currentTarget)try{wr(t.currentTarget)}catch(n){alert(`Failed to register user ${n}`)}else alert("Invalid event target for registration form")},br=()=>{const t=document.querySelector("body > div > form");t?t.addEventListener("submit",pr):alert("Invalid registration test configuration")};br();

var ge=Object.defineProperty;var be=(t,n,e)=>n in t?ge(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var P=(t,n,e)=>(be(t,typeof n!="symbol"?n+"":n,e),e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=BigInt(0),At=BigInt(1),we=BigInt(2),vt=t=>t instanceof Uint8Array,ye=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function dt(t){if(!vt(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=ye[t[e]];return n}function Qt(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function qt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function at(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,i=t.slice(o,o+2),s=Number.parseInt(i,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");e[r]=s}return e}function Y(t){return qt(dt(t))}function Nt(t){if(!vt(t))throw new Error("Uint8Array expected");return qt(dt(Uint8Array.from(t).reverse()))}function Q(t,n){return at(t.toString(16).padStart(n*2,"0"))}function $t(t,n){return Q(t,n).reverse()}function pe(t){return at(Qt(t))}function z(t,n,e){let r;if(typeof n=="string")try{r=at(n)}catch(i){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${i}`)}else if(vt(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function D(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!vt(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function me(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function pt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ee(t){let n;for(n=0;t>Xt;t>>=At,n+=1);return n}function xe(t,n){return t>>BigInt(n)&At}const Be=(t,n,e)=>t|(e?At:Xt)<<BigInt(n),kt=t=>(we<<BigInt(t-1))-At,Ut=t=>new Uint8Array(t),Pt=t=>Uint8Array.from(t);function Jt(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Ut(t),o=Ut(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...u)=>e(o,r,...u),a=(u=Ut())=>{o=c(Pt([0]),u),r=c(),u.length!==0&&(o=c(Pt([1]),u),r=c())},f=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const A=[];for(;u<n;){r=c();const S=r.slice();A.push(S),u+=r.length}return D(...A)};return(u,A)=>{s(),a(u);let S;for(;!(S=A(f()));)a();return s(),S}}const Ae={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function gt(t,n,e={}){const r=(o,i,s)=>{const c=Ae[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const a=t[o];if(!(s&&a===void 0)&&!c(a,t))throw new Error(`Invalid param ${String(o)}=${a} (${typeof a}), expected ${i}`)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}const ve=Object.freeze(Object.defineProperty({__proto__:null,bitGet:xe,bitLen:Ee,bitMask:kt,bitSet:Be,bytesToHex:dt,bytesToNumberBE:Y,bytesToNumberLE:Nt,concatBytes:D,createHmacDrbg:Jt,ensureBytes:z,equalBytes:me,hexToBytes:at,hexToNumber:qt,numberToBytesBE:Q,numberToBytesLE:$t,numberToHexUnpadded:Qt,numberToVarBytesBE:pe,utf8ToBytes:pt,validateObject:gt},Symbol.toStringTag,{value:"Module"})),Kn=t=>typeof t>"u";function jn(t){if(!t)throw EvalError("Assertion failed")}function Pn(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),o=t.byteLength==n.byteLength,i=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let s=0;s<i;s++)o&&(o=e[s]===r[s]);return o}class Gn extends Error{constructor(n){super(n),this.name="ValidationError"}}class zn extends Error{constructor(n){super(n),this.name="InvalidRequest"}}class Mn extends Error{constructor(e,r,o){const i=`Authentication failed for user '${r}', project '${o}'. Reason: ${e}`;super(i);P(this,"reason");P(this,"user_name");P(this,"domain");this.reason=e,this.user_name=r,this.domain=o,this.name="AuthenticationFailed"}}const Wn=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},Se=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),Yn=function(t){let n=new Uint8Array(t);return btoa(Array.from(n,e=>String.fromCharCode(e)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},Xn=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),o=new DataView(r),i=0;return n==="little"?[...atob(t)].slice().reverse().forEach(s=>o.setUint8(i++,s.codePointAt(0))):[...atob(t)].forEach(s=>o.setUint8(i++,s.codePointAt(0))),r.slice(0,i)};function Qn(){return(navigator.userAgent.indexOf("Opera")||navigator.userAgent.indexOf("OPR"))!=-1?"Opera":navigator.userAgent.indexOf("Edg")!=-1?"Edge":navigator.userAgent.indexOf("Chrome")!=-1?"Chrome":navigator.userAgent.indexOf("Safari")!=-1?"Safari":navigator.userAgent.indexOf("Firefox")!=-1?"Firefox":navigator.userAgent.indexOf("MSIE")!=-1?"MSIE":"Unknown"}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const V=BigInt(0),q=BigInt(1),st=BigInt(2),Ue=BigInt(3),Ot=BigInt(4),Gt=BigInt(5),zt=BigInt(8);BigInt(9);BigInt(16);function Z(t,n){const e=t%n;return e>=V?e:n+e}function Ie(t,n,e){if(e<=V||n<V)throw new Error("Expected power/modulo > 0");if(e===q)return V;let r=q;for(;n>V;)n&q&&(r=r*t%e),t=t*t%e,n>>=q;return r}function Ct(t,n){if(t===V||n<=V)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=Z(t,n),r=n,o=V,i=q;for(;e!==V;){const c=r/e,a=r%e,f=o-i*c;r=e,e=a,o=i,i=f}if(r!==q)throw new Error("invert: does not exist");return Z(o,n)}function Le(t){const n=(t-q)/st;let e,r,o;for(e=t-q,r=0;e%st===V;e/=st,r++);for(o=st;o<t&&Ie(o,n,t)!==t-q;o++);if(r===1){const s=(t+q)/Ot;return function(a,f){const p=a.pow(f,s);if(!a.eql(a.sqr(p),f))throw new Error("Cannot find square root");return p}}const i=(e+q)/st;return function(c,a){if(c.pow(a,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let f=r,p=c.pow(c.mul(c.ONE,o),e),u=c.pow(a,i),A=c.pow(a,e);for(;!c.eql(A,c.ONE);){if(c.eql(A,c.ZERO))return c.ZERO;let S=1;for(let l=c.sqr(A);S<f&&!c.eql(l,c.ONE);S++)l=c.sqr(l);const y=c.pow(p,q<<BigInt(f-S-1));p=c.sqr(y),u=c.mul(u,y),A=c.mul(A,p),f=S}return u}}function He(t){if(t%Ot===Ue){const n=(t+q)/Ot;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%zt===Gt){const n=(t-Gt)/zt;return function(r,o){const i=r.mul(o,st),s=r.pow(i,n),c=r.mul(o,s),a=r.mul(r.mul(c,st),s),f=r.mul(c,r.sub(a,r.ONE));if(!r.eql(r.sqr(f),o))throw new Error("Cannot find square root");return f}}return Le(t)}const _e=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ft(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=_e.reduce((r,o)=>(r[o]="function",r),n);return gt(t,e)}function Oe(t,n,e){if(e<V)throw new Error("Expected power > 0");if(e===V)return t.ONE;if(e===q)return n;let r=t.ONE,o=n;for(;e>V;)e&q&&(r=t.mul(r,o)),o=t.sqr(o),e>>=q;return r}function Ce(t,n){const e=new Array(n.length),r=n.reduce((i,s,c)=>t.is0(s)?i:(e[c]=i,t.mul(i,s)),t.ONE),o=t.inv(r);return n.reduceRight((i,s,c)=>t.is0(s)?i:(e[c]=t.mul(i,e[c]),t.mul(i,s)),o),e}function te(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function ee(t,n,e=!1,r={}){if(t<=V)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=te(t,n);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=He(t),c=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:kt(o),ZERO:V,ONE:q,create:a=>Z(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof a}`);return V<=a&&a<t},is0:a=>a===V,isOdd:a=>(a&q)===q,neg:a=>Z(-a,t),eql:(a,f)=>a===f,sqr:a=>Z(a*a,t),add:(a,f)=>Z(a+f,t),sub:(a,f)=>Z(a-f,t),mul:(a,f)=>Z(a*f,t),pow:(a,f)=>Oe(c,a,f),div:(a,f)=>Z(a*Ct(f,t),t),sqrN:a=>a*a,addN:(a,f)=>a+f,subN:(a,f)=>a-f,mulN:(a,f)=>a*f,inv:a=>Ct(a,t),sqrt:r.sqrt||(a=>s(c,a)),invertBatch:a=>Ce(c,a),cmov:(a,f,p)=>p?f:a,toBytes:a=>e?$t(a,i):Q(a,i),fromBytes:a=>{if(a.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${a.length}`);return e?Nt(a):Y(a)}});return Object.freeze(c)}function ne(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function re(t){const n=ne(t);return n+Math.ceil(n/2)}function Re(t,n,e=!1){const r=t.length,o=ne(n),i=re(n);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const s=e?Y(t):Nt(t),c=Z(s,n-q)+q;return e?$t(c,o):Q(c,o)}function It(t,n){let e=Q(t,n);return btoa(Array.from(e,r=>String.fromCharCode(r)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}class Et extends Error{constructor(e){super(e);P(this,"error_type");this.error_type=e}err(){return this.error_type}}function X(t){return typeof t=="string"?pt(t):t}class Te{constructor(n,e){P(this,"EcGroup");P(this,"Fq");P(this,"hashToCurve");P(this,"coordinateSize");this.EcGroup=n,this.Fq=ee(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}curveName(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P-256";if(n===384)return"P-384";if(n===521)return"P-521";throw new Et("UnknownCurveType")}hashAlgo(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"SHA-256";if(n===384)return"SHA-384";if(n===521)return"SHA-512";throw new Et("UnknownCurveType")}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=Y(e);if(r===BigInt(0))return this.blind(n);let o=X(n),i=this.hashToCurve(o).multiply(r);if(i.equals(this.EcGroup.ProjectivePoint.ZERO))throw new Et("HashedToInifinity");let s=this.EcGroup.ProjectivePoint.fromAffine(i.toAffine());return{hashed_password:n,blinder:r,clientRequestBytes:s.toHex(!1)}}async finalize(n,e){const r=globalThis.crypto.subtle;let o=this.EcGroup.ProjectivePoint.fromHex(n);if(o.assertValidity(),o.toHex(!1)===e.clientRequestBytes)throw Error("Server tried to attack the client during OPRF finalize step by replaying the client's request");let s=this.Fq.inv(e.blinder),c=o.multiply(s).toRawBytes(!0);const a=D(Q(e.hashed_password.length,2),X(e.hashed_password),Q(c.length,2),c,X("Finalize")),f=await r.digest(this.hashAlgo(),a);return r.importKey("raw",f,"HKDF",!1,["deriveBits","deriveKey"])}async login_key(n,e){const r=this.EcGroup.CURVE,o=this.EcGroup.ProjectivePoint,i=globalThis.crypto.subtle,s=D(X(e),X("LoginKeySalt")),c=X("LoginKey"),a=await i.deriveBits({name:"HKDF",hash:"SHA-512",salt:s.buffer,info:c.buffer},n,8*(3*r.nByteLength/2));let f=Y(new Uint8Array(a)),p=Z(f,r.n),u=o.fromPrivateKey(p),A={crv:this.curveName(),d:It(p,r.nByteLength),ext:!0,key_ops:["sign"],kty:"EC",x:It(u.x,r.Fp.BYTES),y:It(u.y,r.Fp.BYTES)};return{loginKey:await i.importKey("jwk",A,{name:"ECDSA",namedCurve:this.curveName()},!0,["sign"]),publicKey:u.toRawBytes(!1)}}async lockbox_key(n,e){const r=globalThis.crypto.subtle,o=D(X(e),X("LockboxSalt")),i=X("LockboxKey");return r.deriveKey({name:"HKDF",hash:"SHA-512",salt:o.buffer,info:i.buffer},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}}function Mt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function oe(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function qe(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Mt(t.outputLen),Mt(t.blockLen)}function xt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Ne(t,n){oe(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}const Lt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ie=t=>t instanceof Uint8Array,Ht=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),$e=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!$e)throw new Error("Non little-endian hardware is not supported");function ke(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Vt(t){if(typeof t=="string"&&(t=ke(t)),!ie(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function Ve(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!ie(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}class se{clone(){return this._cloneInto()}}function Ze(t){const n=r=>t().update(Vt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function De(t=32){if(Lt&&typeof Lt.getRandomValues=="function")return Lt.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}class ce extends se{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,qe(n);const r=Vt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=n.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(n){return xt(this),this.iHash.update(n),this}digestInto(n){xt(this),oe(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=s,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ae=(t,n,e)=>new ce(t,n).update(e).digest();ae.create=(t,n)=>new ce(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ke=BigInt(0),_t=BigInt(1);function je(t,n){const e=(o,i)=>{const s=i.negate();return o?s:i},r=o=>{const i=Math.ceil(n/o)+1,s=2**(o-1);return{windows:i,windowSize:s}};return{constTimeNegate:e,unsafeLadder(o,i){let s=t.ZERO,c=o;for(;i>Ke;)i&_t&&(s=s.add(c)),c=c.double(),i>>=_t;return s},precomputeWindow(o,i){const{windows:s,windowSize:c}=r(i),a=[];let f=o,p=f;for(let u=0;u<s;u++){p=f,a.push(p);for(let A=1;A<c;A++)p=p.add(f),a.push(p);f=p.double()}return a},wNAF(o,i,s){const{windows:c,windowSize:a}=r(o);let f=t.ZERO,p=t.BASE;const u=BigInt(2**o-1),A=2**o,S=BigInt(o);for(let y=0;y<c;y++){const l=y*a;let h=Number(s&u);s>>=S,h>a&&(h-=A,s+=_t);const d=l,w=l+Math.abs(h)-1,g=y%2!==0,v=h<0;h===0?p=p.add(e(g,i[d])):f=f.add(e(v,i[w]))}return{p:f,f:p}},wNAFCached(o,i,s,c){const a=o._WINDOW_SIZE||1;let f=i.get(o);return f||(f=this.precomputeWindow(o,a),a!==1&&i.set(o,c(f))),this.wNAF(a,f,s)}}}function fe(t){return Ft(t.Fp),gt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...te(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Pe(t){const n=fe(t);gt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:Ge,hexToBytes:ze}=ve,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ct;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:Ge(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ct,e=typeof t=="string"?ze(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:i}=ct._parseInt(e.subarray(2)),{d:s,l:c}=ct._parseInt(i);if(c.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const n=f=>Number.parseInt(f[0],16)&8?"00"+f:f,e=f=>{const p=f.toString(16);return p.length&1?`0${p}`:p},r=n(e(t.s)),o=n(e(t.r)),i=r.length/2,s=o.length/2,c=e(i),a=e(s);return`30${e(s+i+4)}02${a}${o}02${c}${r}`}},M=BigInt(0),T=BigInt(1),et=BigInt(2),Bt=BigInt(3),Wt=BigInt(4);function Me(t){const n=Pe(t),{Fp:e}=n,r=n.toBytes||((y,l,h)=>{const d=l.toAffine();return D(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(y=>{const l=y.subarray(1),h=e.fromBytes(l.subarray(0,e.BYTES)),d=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function i(y){const{a:l,b:h}=n,d=e.sqr(y),w=e.mul(d,y);return e.add(e.add(w,e.mul(y,l)),h)}if(!e.eql(e.sqr(n.Gy),i(n.Gx)))throw new Error("bad generator point: equation left != right");function s(y){return typeof y=="bigint"&&M<y&&y<n.n}function c(y){if(!s(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function a(y){const{allowedPrivateKeyLengths:l,nByteLength:h,wrapPrivateKey:d,n:w}=n;if(l&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=dt(y)),typeof y!="string"||!l.includes(y.length))throw new Error("Invalid key");y=y.padStart(h*2,"0")}let g;try{g=typeof y=="bigint"?y:Y(z("private key",y,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof y}`)}return d&&(g=Z(g,w)),c(g),g}const f=new Map;function p(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,h,d){if(this.px=l,this.py=h,this.pz=d,l==null||!e.isValid(l))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(l){const{x:h,y:d}=l||{};if(!l||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const w=g=>e.eql(g,e.ZERO);return w(h)&&w(d)?u.ZERO:new u(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const h=e.invertBatch(l.map(d=>d.pz));return l.map((d,w)=>d.toAffine(h[w])).map(u.fromAffine)}static fromHex(l){const h=u.fromAffine(o(z("pointHex",l)));return h.assertValidity(),h}static fromPrivateKey(l){return u.BASE.multiply(a(l))}_setWindowSize(l){this._WINDOW_SIZE=l,f.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:h}=this.toAffine();if(!e.isValid(l)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),w=i(l);if(!e.eql(d,w))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){p(l);const{px:h,py:d,pz:w}=this,{px:g,py:v,pz:U}=l,E=e.eql(e.mul(h,U),e.mul(g,w)),x=e.eql(e.mul(d,U),e.mul(v,w));return E&&x}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){const{a:l,b:h}=n,d=e.mul(h,Bt),{px:w,py:g,pz:v}=this;let U=e.ZERO,E=e.ZERO,x=e.ZERO,B=e.mul(w,w),C=e.mul(g,g),_=e.mul(v,v),H=e.mul(w,g);return H=e.add(H,H),x=e.mul(w,v),x=e.add(x,x),U=e.mul(l,x),E=e.mul(d,_),E=e.add(U,E),U=e.sub(C,E),E=e.add(C,E),E=e.mul(U,E),U=e.mul(H,U),x=e.mul(d,x),_=e.mul(l,_),H=e.sub(B,_),H=e.mul(l,H),H=e.add(H,x),x=e.add(B,B),B=e.add(x,B),B=e.add(B,_),B=e.mul(B,H),E=e.add(E,B),_=e.mul(g,v),_=e.add(_,_),B=e.mul(_,H),U=e.sub(U,B),x=e.mul(_,C),x=e.add(x,x),x=e.add(x,x),new u(U,E,x)}add(l){p(l);const{px:h,py:d,pz:w}=this,{px:g,py:v,pz:U}=l;let E=e.ZERO,x=e.ZERO,B=e.ZERO;const C=n.a,_=e.mul(n.b,Bt);let H=e.mul(h,g),N=e.mul(d,v),k=e.mul(w,U),W=e.add(h,d),b=e.add(g,v);W=e.mul(W,b),b=e.add(H,N),W=e.sub(W,b),b=e.add(h,w);let m=e.add(g,U);return b=e.mul(b,m),m=e.add(H,k),b=e.sub(b,m),m=e.add(d,w),E=e.add(v,U),m=e.mul(m,E),E=e.add(N,k),m=e.sub(m,E),B=e.mul(C,b),E=e.mul(_,k),B=e.add(E,B),E=e.sub(N,B),B=e.add(N,B),x=e.mul(E,B),N=e.add(H,H),N=e.add(N,H),k=e.mul(C,k),b=e.mul(_,b),N=e.add(N,k),k=e.sub(H,k),k=e.mul(C,k),b=e.add(b,k),H=e.mul(N,b),x=e.add(x,H),H=e.mul(m,b),E=e.mul(W,E),E=e.sub(E,H),H=e.mul(W,N),B=e.mul(m,B),B=e.add(B,H),new u(E,x,B)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return S.wNAFCached(this,f,l,h=>{const d=e.invertBatch(h.map(w=>w.pz));return h.map((w,g)=>w.toAffine(d[g])).map(u.fromAffine)})}multiplyUnsafe(l){const h=u.ZERO;if(l===M)return h;if(c(l),l===T)return this;const{endo:d}=n;if(!d)return S.unsafeLadder(this,l);let{k1neg:w,k1:g,k2neg:v,k2:U}=d.splitScalar(l),E=h,x=h,B=this;for(;g>M||U>M;)g&T&&(E=E.add(B)),U&T&&(x=x.add(B)),B=B.double(),g>>=T,U>>=T;return w&&(E=E.negate()),v&&(x=x.negate()),x=new u(e.mul(x.px,d.beta),x.py,x.pz),E.add(x)}multiply(l){c(l);let h=l,d,w;const{endo:g}=n;if(g){const{k1neg:v,k1:U,k2neg:E,k2:x}=g.splitScalar(h);let{p:B,f:C}=this.wNAF(U),{p:_,f:H}=this.wNAF(x);B=S.constTimeNegate(v,B),_=S.constTimeNegate(E,_),_=new u(e.mul(_.px,g.beta),_.py,_.pz),d=B.add(_),w=C.add(H)}else{const{p:v,f:U}=this.wNAF(h);d=v,w=U}return u.normalizeZ([d,w])[0]}multiplyAndAddUnsafe(l,h,d){const w=u.BASE,g=(U,E)=>E===M||E===T||!U.equals(w)?U.multiplyUnsafe(E):U.multiply(E),v=g(this,h).add(g(l,d));return v.is0()?void 0:v}toAffine(l){const{px:h,py:d,pz:w}=this,g=this.is0();l==null&&(l=g?e.ONE:e.inv(w));const v=e.mul(h,l),U=e.mul(d,l),E=e.mul(w,l);if(g)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:v,y:U}}isTorsionFree(){const{h:l,isTorsionFree:h}=n;if(l===T)return!0;if(h)return h(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:h}=n;return l===T?this:h?h(u,this):this.multiplyUnsafe(n.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return dt(this.toRawBytes(l))}}u.BASE=new u(n.Gx,n.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);const A=n.nBitLength,S=je(u,n.endo?Math.ceil(A/2):A);return{CURVE:n,ProjectivePoint:u,normPrivateKeyToScalar:a,weierstrassEquation:i,isWithinCurveOrder:s}}function We(t){const n=fe(t);return gt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Ye(t){const n=We(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function s(b){return M<b&&b<e.ORDER}function c(b){return Z(b,r)}function a(b){return Ct(b,r)}const{ProjectivePoint:f,normPrivateKeyToScalar:p,weierstrassEquation:u,isWithinCurveOrder:A}=Me({...n,toBytes(b,m,L){const R=m.toAffine(),O=e.toBytes(R.x),$=D;return L?$(Uint8Array.from([m.hasEvenY()?2:3]),O):$(Uint8Array.from([4]),O,e.toBytes(R.y))},fromBytes(b){const m=b.length,L=b[0],R=b.subarray(1);if(m===o&&(L===2||L===3)){const O=Y(R);if(!s(O))throw new Error("Point is not on curve");const $=u(O);let K=e.sqrt($);const j=(K&T)===T;return(L&1)===1!==j&&(K=e.neg(K)),{x:O,y:K}}else if(m===i&&L===4){const O=e.fromBytes(R.subarray(0,e.BYTES)),$=e.fromBytes(R.subarray(e.BYTES,2*e.BYTES));return{x:O,y:$}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}}),S=b=>dt(Q(b,n.nByteLength));function y(b){const m=r>>T;return b>m}function l(b){return y(b)?c(-b):b}const h=(b,m,L)=>Y(b.slice(m,L));class d{constructor(m,L,R){this.r=m,this.s=L,this.recovery=R,this.assertValidity()}static fromCompact(m){const L=n.nByteLength;return m=z("compactSignature",m,L*2),new d(h(m,0,L),h(m,L,2*L))}static fromDER(m){const{r:L,s:R}=ct.toSig(z("DER",m));return new d(L,R)}assertValidity(){if(!A(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!A(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:L,s:R,recovery:O}=this,$=x(z("msgHash",m));if(O==null||![0,1,2,3].includes(O))throw new Error("recovery id invalid");const K=O===2||O===3?L+n.n:L;if(K>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=O&1?"03":"02",J=f.fromHex(j+S(K)),F=a(K),ft=c(-$*F),bt=c(R*F),tt=f.BASE.multiplyAndAddUnsafe(J,ft,bt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return at(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return at(this.toCompactHex())}toCompactHex(){return S(this.r)+S(this.s)}}const w={isValidPrivateKey(b){try{return p(b),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const b=re(n.n);return Re(n.randomBytes(b),n.n)},precompute(b=8,m=f.BASE){return m._setWindowSize(b),m.multiply(BigInt(3)),m}};function g(b,m=!0){return f.fromPrivateKey(b).toRawBytes(m)}function v(b){const m=b instanceof Uint8Array,L=typeof b=="string",R=(m||L)&&b.length;return m?R===o||R===i:L?R===2*o||R===2*i:b instanceof f}function U(b,m,L=!0){if(v(b))throw new Error("first arg must be private key");if(!v(m))throw new Error("second arg must be public key");return f.fromHex(m).multiply(p(b)).toRawBytes(L)}const E=n.bits2int||function(b){const m=Y(b),L=b.length*8-n.nBitLength;return L>0?m>>BigInt(L):m},x=n.bits2int_modN||function(b){return c(E(b))},B=kt(n.nBitLength);function C(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(M<=b&&b<B))throw new Error(`bigint expected < 2^${n.nBitLength}`);return Q(b,n.nByteLength)}function _(b,m,L=H){if(["recovered","canonical"].some(it=>it in L))throw new Error("sign() legacy options not supported");const{hash:R,randomBytes:O}=n;let{lowS:$,prehash:K,extraEntropy:j}=L;$==null&&($=!0),b=z("msgHash",b),K&&(b=z("prehashed msgHash",R(b)));const J=x(b),F=p(m),ft=[C(F),C(J)];if(j!=null){const it=j===!0?O(e.BYTES):j;ft.push(z("extraEntropy",it))}const bt=D(...ft),tt=J;function St(it){const lt=E(it);if(!A(lt))return;const Dt=a(lt),ut=f.BASE.multiply(lt).toAffine(),G=c(ut.x);if(G===M)return;const ht=c(Dt*c(tt+G*F));if(ht===M)return;let Kt=(ut.x===G?0:2)|Number(ut.y&T),jt=ht;return $&&y(ht)&&(jt=l(ht),Kt^=1),new d(G,jt,Kt)}return{seed:bt,k2sig:St}}const H={lowS:n.lowS,prehash:!1},N={lowS:n.lowS,prehash:!1};function k(b,m,L=H){const{seed:R,k2sig:O}=_(b,m,L),$=n;return Jt($.hash.outputLen,$.nByteLength,$.hmac)(R,O)}f.BASE._setWindowSize(8);function W(b,m,L,R=N){var ut;const O=b;if(m=z("msgHash",m),L=z("publicKey",L),"strict"in R)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:K}=R;let j,J;try{if(typeof O=="string"||O instanceof Uint8Array)try{j=d.fromDER(O)}catch(G){if(!(G instanceof ct.Err))throw G;j=d.fromCompact(O)}else if(typeof O=="object"&&typeof O.r=="bigint"&&typeof O.s=="bigint"){const{r:G,s:ht}=O;j=new d(G,ht)}else throw new Error("PARSE");J=f.fromHex(L)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;K&&(m=n.hash(m));const{r:F,s:ft}=j,bt=x(m),tt=a(ft),St=c(bt*tt),it=c(F*tt),lt=(ut=f.BASE.multiplyAndAddUnsafe(J,St,it))==null?void 0:ut.toAffine();return lt?c(lt.x)===F:!1}return{CURVE:n,getPublicKey:g,getSharedSecret:U,sign:k,verify:W,ProjectivePoint:f,Signature:d,utils:w}}function Xe(t,n){const e=t.ORDER;let r=M;for(let y=e-T;y%et===M;y/=et)r+=T;const o=r,i=et<<o-T-T,s=i*et,c=(e-T)/s,a=(c-T)/et,f=s-T,p=i,u=t.pow(n,c),A=t.pow(n,(c+T)/et);let S=(y,l)=>{let h=u,d=t.pow(l,f),w=t.sqr(d);w=t.mul(w,l);let g=t.mul(y,w);g=t.pow(g,a),g=t.mul(g,d),d=t.mul(g,l),w=t.mul(g,y);let v=t.mul(w,d);g=t.pow(v,p);let U=t.eql(g,t.ONE);d=t.mul(w,A),g=t.mul(v,h),w=t.cmov(d,w,U),v=t.cmov(g,v,U);for(let E=o;E>T;E--){let x=E-et;x=et<<x-T;let B=t.pow(v,x);const C=t.eql(B,t.ONE);d=t.mul(w,h),h=t.mul(h,h),B=t.mul(v,h),w=t.cmov(d,w,C),v=t.cmov(B,v,C)}return{isValid:U,value:w}};if(t.ORDER%Wt===Bt){const y=(t.ORDER-Bt)/Wt,l=t.sqrt(t.neg(n));S=(h,d)=>{let w=t.sqr(d);const g=t.mul(h,d);w=t.mul(w,g);let v=t.pow(w,y);v=t.mul(v,g);const U=t.mul(v,l),E=t.mul(t.sqr(v),d),x=t.eql(E,h);let B=t.cmov(U,v,x);return{isValid:x,value:B}}}return S}function Qe(t,n){if(Ft(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Xe(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,s,c,a,f,p,u;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,n.B),c=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),c=t.mul(c,n.A),i=t.sqr(s),f=t.sqr(c),a=t.mul(f,n.A),i=t.add(i,a),i=t.mul(i,s),f=t.mul(f,c),a=t.mul(f,n.B),i=t.add(i,a),p=t.mul(o,s);const{isValid:A,value:S}=e(i,f);u=t.mul(o,r),u=t.mul(u,S),p=t.cmov(p,s,A),u=t.cmov(u,S,A);const y=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,y),p=t.div(p,c),{x:p,y:u}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Je(t){return{hash:t,hmac:(n,...e)=>ae(t,n,Ve(...e)),randomBytes:De}}function Fe(t,n){const e=r=>Ye({...t,...Je(r)});return Object.freeze({...e(n),create:e})}function tn(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(e>>o&i),c=Number(e&i),a=r?4:0,f=r?0:4;t.setUint32(n+a,s,r),t.setUint32(n+f,c,r)}class en extends se{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=Ht(this.buffer)}update(n){xt(this);const{view:e,buffer:r,blockLen:o}=this;n=Vt(n);const i=n.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const a=Ht(n);for(;o<=i-s;s+=o)this.process(a,s);continue}r.set(n.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){xt(this),Ne(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let u=s;u<o;u++)e[u]=0;tn(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=Ht(n),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=a/4,p=this.get();if(f>p.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<f;u++)c.setUint32(4*u,p[u],i)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return n.length=o,n.pos=c,n.finished=i,n.destroyed=s,o%e&&n.buffer.set(r),n}}const mt=BigInt(2**32-1),Rt=BigInt(32);function le(t,n=!1){return n?{h:Number(t&mt),l:Number(t>>Rt&mt)}:{h:Number(t>>Rt&mt)|0,l:Number(t&mt)|0}}function nn(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=le(t[o],n);[e[o],r[o]]=[i,s]}return[e,r]}const rn=(t,n)=>BigInt(t>>>0)<<Rt|BigInt(n>>>0),on=(t,n,e)=>t>>>e,sn=(t,n,e)=>t<<32-e|n>>>e,cn=(t,n,e)=>t>>>e|n<<32-e,an=(t,n,e)=>t<<32-e|n>>>e,fn=(t,n,e)=>t<<64-e|n>>>e-32,ln=(t,n,e)=>t>>>e-32|n<<64-e,un=(t,n)=>n,hn=(t,n)=>t,dn=(t,n,e)=>t<<e|n>>>32-e,gn=(t,n,e)=>n<<e|t>>>32-e,bn=(t,n,e)=>n<<e-32|t>>>64-e,wn=(t,n,e)=>t<<e-32|n>>>64-e;function yn(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const pn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),mn=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,En=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),xn=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,Bn=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),An=(t,n,e,r,o,i)=>n+e+r+o+i+(t/2**32|0)|0,vn={fromBig:le,split:nn,toBig:rn,shrSH:on,shrSL:sn,rotrSH:cn,rotrSL:an,rotrBH:fn,rotrBL:ln,rotr32H:un,rotr32L:hn,rotlSH:dn,rotlSL:gn,rotlBH:bn,rotlBL:wn,add:yn,add3L:pn,add3H:mn,add4L:En,add4H:xn,add5H:An,add5L:Bn},I=vn,[Sn,Un]=(()=>I.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),nt=new Uint32Array(80),rt=new Uint32Array(80);class In extends en{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:i,Cl:s,Dh:c,Dl:a,Eh:f,El:p,Fh:u,Fl:A,Gh:S,Gl:y,Hh:l,Hl:h}=this;return[n,e,r,o,i,s,c,a,f,p,u,A,S,y,l,h]}set(n,e,r,o,i,s,c,a,f,p,u,A,S,y,l,h){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=i|0,this.Cl=s|0,this.Dh=c|0,this.Dl=a|0,this.Eh=f|0,this.El=p|0,this.Fh=u|0,this.Fl=A|0,this.Gh=S|0,this.Gl=y|0,this.Hh=l|0,this.Hl=h|0}process(n,e){for(let g=0;g<16;g++,e+=4)nt[g]=n.getUint32(e),rt[g]=n.getUint32(e+=4);for(let g=16;g<80;g++){const v=nt[g-15]|0,U=rt[g-15]|0,E=I.rotrSH(v,U,1)^I.rotrSH(v,U,8)^I.shrSH(v,U,7),x=I.rotrSL(v,U,1)^I.rotrSL(v,U,8)^I.shrSL(v,U,7),B=nt[g-2]|0,C=rt[g-2]|0,_=I.rotrSH(B,C,19)^I.rotrBH(B,C,61)^I.shrSH(B,C,6),H=I.rotrSL(B,C,19)^I.rotrBL(B,C,61)^I.shrSL(B,C,6),N=I.add4L(x,H,rt[g-7],rt[g-16]),k=I.add4H(N,E,_,nt[g-7],nt[g-16]);nt[g]=k|0,rt[g]=N|0}let{Ah:r,Al:o,Bh:i,Bl:s,Ch:c,Cl:a,Dh:f,Dl:p,Eh:u,El:A,Fh:S,Fl:y,Gh:l,Gl:h,Hh:d,Hl:w}=this;for(let g=0;g<80;g++){const v=I.rotrSH(u,A,14)^I.rotrSH(u,A,18)^I.rotrBH(u,A,41),U=I.rotrSL(u,A,14)^I.rotrSL(u,A,18)^I.rotrBL(u,A,41),E=u&S^~u&l,x=A&y^~A&h,B=I.add5L(w,U,x,Un[g],rt[g]),C=I.add5H(B,d,v,E,Sn[g],nt[g]),_=B|0,H=I.rotrSH(r,o,28)^I.rotrBH(r,o,34)^I.rotrBH(r,o,39),N=I.rotrSL(r,o,28)^I.rotrBL(r,o,34)^I.rotrBL(r,o,39),k=r&i^r&c^i&c,W=o&s^o&a^s&a;d=l|0,w=h|0,l=S|0,h=y|0,S=u|0,y=A|0,{h:u,l:A}=I.add(f|0,p|0,C|0,_|0),f=c|0,p=a|0,c=i|0,a=s|0,i=r|0,s=o|0;const b=I.add3L(_,N,W);r=I.add3H(b,C,H,k),o=b|0}({h:r,l:o}=I.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:i,l:s}=I.add(this.Bh|0,this.Bl|0,i|0,s|0),{h:c,l:a}=I.add(this.Ch|0,this.Cl|0,c|0,a|0),{h:f,l:p}=I.add(this.Dh|0,this.Dl|0,f|0,p|0),{h:u,l:A}=I.add(this.Eh|0,this.El|0,u|0,A|0),{h:S,l:y}=I.add(this.Fh|0,this.Fl|0,S|0,y|0),{h:l,l:h}=I.add(this.Gh|0,this.Gl|0,l|0,h|0),{h:d,l:w}=I.add(this.Hh|0,this.Hl|0,d|0,w|0),this.set(r,o,i,s,c,a,f,p,u,A,S,y,l,h,d,w)}roundClean(){nt.fill(0),rt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Ln extends In{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const ue=Ze(()=>new Ln);function Hn(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return pt(t);throw new Error("DST must be Uint8Array or string")}const _n=Y;function ot(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function On(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function wt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Zt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Cn(t,n,e,r){wt(t),wt(n),Zt(e),n.length>255&&(n=r(D(pt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(e/o);if(s>255)throw new Error("Invalid xmd length");const c=D(n,ot(n.length,1)),a=ot(0,i),f=ot(e,2),p=new Array(s),u=r(D(a,t,f,ot(0,1),c));p[0]=r(D(u,ot(1,1),c));for(let S=1;S<=s;S++){const y=[On(u,p[S-1]),ot(S+1,1),c];p[S]=r(D(...y))}return D(...p).slice(0,e)}function Rn(t,n,e,r,o){if(wt(t),wt(n),Zt(e),n.length>255){const i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(pt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(ot(e,2)).update(n).update(ot(n.length,1)).digest()}function Yt(t,n,e){gt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:c,DST:a}=e;wt(t),Zt(n);const f=Hn(a),p=r.toString(2).length,u=Math.ceil((p+o)/8),A=n*i*u;let S;if(c==="xmd")S=Cn(t,f,A,s);else if(c==="xof")S=Rn(t,f,A,o,s);else if(c==="_internal_pass")S=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(n);for(let l=0;l<n;l++){const h=new Array(i);for(let d=0;d<i;d++){const w=u*(d+l*i),g=S.subarray(w,w+u);h[d]=Z(_n(g),r)}y[l]=h}return y}function Tn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=Yt(r,2,{...e,DST:e.DST,...o}),s=t.fromAffine(n(i[0])),c=t.fromAffine(n(i[1])),a=s.add(c).clearCofactor();return a.assertValidity(),a},encodeToCurve(r,o){const i=Yt(r,1,{...e,DST:e.encodeDST,...o}),s=t.fromAffine(n(i[0])).clearCofactor();return s.assertValidity(),s}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),yt=ee(qn),he=yt.create(BigInt("-3")),de=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Tt=Fe({a:he,b:de,Fp:yt,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},ue),Nn=Tt,$n=(()=>Qe(yt,{A:he,B:de,Z:yt.create(BigInt("-12"))}))(),kn=(()=>Tn(Nn.ProjectivePoint,t=>$n(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:yt.ORDER,m:1,k:192,expand:"xmd",hash:ue}))(),Vn=(()=>kn.hashToCurve)();class Fn{constructor(n){P(this,"discoveryURL");P(this,"baseURL");P(this,"oprfClient");P(this,"oprfClientData",null);if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto");this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new Te(Tt,Vn)}async computeOprfClientData(n,e){try{e.salt||(e.salt=Se(globalThis.crypto.getRandomValues(new Uint8Array(32))));const r=await Zn(n,e,Tt.CURVE.nByteLength);return this.oprfClientData=this.oprfClient.blind(r),this.oprfClientData}catch(r){if(r instanceof Et&&r.err()=="HashedToInifinity")return this.computeOprfClientData(n,e);throw r}}async parseServerResponse(n){if(n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`${e.message}`)}else{const e=await n.json();throw new Error(`${JSON.stringify(e)}`)}}async fetchUserInfo(n,e,r){const o=await this.fetchDirectory();let i=`${this.discoveryURL}${o.user_info}?user_name=${n}`;e&&(i=`${i}&domain=${e}`),r&&(i=`${i}&domain=${r}`);const s=await fetch(i,{keepalive:!0,mode:"cors",cache:"no-store"});return this.parseServerResponse(s)}}async function Zn(t,n,e){const r=t+n.domain_name+n.user_name+t,o=await globalThis.crypto.subtle.importKey("raw",new TextEncoder().encode(r),{name:"PBKDF2"},!1,["deriveBits"]);let i=at(n.salt),s=await globalThis.crypto.subtle.deriveBits({name:"PBKDF2",salt:i,iterations:1e6,hash:"SHA-256"},o,8*e);return new Uint8Array(s)}export{Mn as A,zn as I,Fn as U,Gn as V,jn as a,Xn as b,Qn as c,D as d,Pn as e,Wn as f,Yn as g,Y as h,Kn as i,Z as m,pe as n,Ie as p,Se as t,pt as u};

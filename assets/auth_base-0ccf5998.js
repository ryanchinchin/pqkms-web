var we=Object.defineProperty;var be=(t,n,e)=>n in t?we(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e;var W=(t,n,e)=>(be(t,typeof n!="symbol"?n+"":n,e),e);const Ut=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Xt=t=>t instanceof Uint8Array,It=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),ge=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!ge)throw new Error("Non little-endian hardware is not supported");function ye(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,i=t.slice(o,o+2),s=Number.parseInt(i,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");e[r]=s}return e}function pe(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Rt(t){if(typeof t=="string"&&(t=pe(t)),!Xt(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function me(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!Xt(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}class Qt{clone(){return this._cloneInto()}}function Ee(t){const n=r=>t().update(Rt(r)).digest(),e=t();return n.outputLen=e.outputLen,n.blockLen=e.blockLen,n.create=()=>t(),n}function xe(t=32){if(Ut&&typeof Ut.getRandomValues=="function")return Ut.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}const jn=t=>typeof t>"u";function Gn(t){if(!t)throw EvalError("Assertion failed")}function Pn(t,n){let e=new Uint8Array(t),r=new Uint8Array(n),o=t.byteLength==n.byteLength,i=t.byteLength<n.byteLength?t.byteLength:n.byteLength;for(let s=0;s<i;s++)o&&(o=e[s]===r[s]);return o}class zn extends Error{constructor(n){super(n),this.name="ValidationError"}}const Mn=t=>{(t.startsWith("0x")||t.startsWith("0X"))&&(t=t.substring(2)),t.length%2!==0&&(t=`0${t}`);let n=t.match(/.{1,2}/g);return n?Uint8Array.from(n.map(e=>parseInt(e,16))):Uint8Array.from([])},Be=t=>new Uint8Array(t).reduce((n,e)=>n+e.toString(16).padStart(2,"0"),""),Wn=function(t){let n=new Uint8Array(t);return btoa(Array.from(n,e=>String.fromCharCode(e)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")},Yn=function(t,n="little"){t=t.replace(/-/g,"+").replace(/_/g,"/");var e=t.length%4;if(e){if(e===1)throw new Error("InvalidLengthError: Input base64url string is the wrong length to determine padding");t+=new Array(5-e).join("=")}let r=new ArrayBuffer(t.length),o=new DataView(r),i=0;return n==="little"?[...atob(t)].slice().reverse().forEach(s=>o.setUint8(i++,s.codePointAt(0))):[...atob(t)].forEach(s=>o.setUint8(i++,s.codePointAt(0))),r.slice(0,i)};/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Jt=BigInt(0),St=BigInt(1),Se=BigInt(2),At=t=>t instanceof Uint8Array,Ae=Array.from({length:256},(t,n)=>n.toString(16).padStart(2,"0"));function ht(t){if(!At(t))throw new Error("Uint8Array expected");let n="";for(let e=0;e<t.length;e++)n+=Ae[t[e]];return n}function Ft(t){const n=t.toString(16);return n.length&1?`0${n}`:n}function Tt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function dt(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const n=t.length;if(n%2)throw new Error("padded hex string expected, got unpadded hex of length "+n);const e=new Uint8Array(n/2);for(let r=0;r<e.length;r++){const o=r*2,i=t.slice(o,o+2),s=Number.parseInt(i,16);if(Number.isNaN(s)||s<0)throw new Error("Invalid byte sequence");e[r]=s}return e}function Y(t){return Tt(ht(t))}function $t(t){if(!At(t))throw new Error("Uint8Array expected");return Tt(ht(Uint8Array.from(t).reverse()))}function Q(t,n){return dt(t.toString(16).padStart(n*2,"0"))}function Vt(t,n){return Q(t,n).reverse()}function ve(t){return dt(Ft(t))}function P(t,n,e){let r;if(typeof n=="string")try{r=dt(n)}catch(i){throw new Error(`${t} must be valid hex string, got "${n}". Cause: ${i}`)}else if(At(n))r=Uint8Array.from(n);else throw new Error(`${t} must be hex string or Uint8Array`);const o=r.length;if(typeof e=="number"&&o!==e)throw new Error(`${t} expected ${e} bytes, got ${o}`);return r}function D(...t){const n=new Uint8Array(t.reduce((r,o)=>r+o.length,0));let e=0;return t.forEach(r=>{if(!At(r))throw new Error("Uint8Array expected");n.set(r,e),e+=r.length}),n}function Ue(t,n){if(t.length!==n.length)return!1;for(let e=0;e<t.length;e++)if(t[e]!==n[e])return!1;return!0}function pt(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function Ie(t){let n;for(n=0;t>Jt;t>>=St,n+=1);return n}function Le(t,n){return t>>BigInt(n)&St}const He=(t,n,e)=>t|(e?St:Jt)<<BigInt(n),kt=t=>(Se<<BigInt(t-1))-St,Lt=t=>new Uint8Array(t),Gt=t=>Uint8Array.from(t);function te(t,n,e){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof n!="number"||n<2)throw new Error("qByteLen must be a number");if(typeof e!="function")throw new Error("hmacFn must be a function");let r=Lt(t),o=Lt(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},c=(...u)=>e(o,r,...u),f=(u=Lt())=>{o=c(Gt([0]),u),r=c(),u.length!==0&&(o=c(Gt([1]),u),r=c())},a=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const S=[];for(;u<n;){r=c();const v=r.slice();S.push(v),u+=r.length}return D(...S)};return(u,S)=>{s(),f(u);let v;for(;!(v=S(a()));)f();return s(),v}}const _e={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,n)=>n.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function wt(t,n,e={}){const r=(o,i,s)=>{const c=_e[i];if(typeof c!="function")throw new Error(`Invalid validator "${i}", expected function`);const f=t[o];if(!(s&&f===void 0)&&!c(f,t))throw new Error(`Invalid param ${String(o)}=${f} (${typeof f}), expected ${i}`)};for(const[o,i]of Object.entries(n))r(o,i,!1);for(const[o,i]of Object.entries(e))r(o,i,!0);return t}const Ce=Object.freeze(Object.defineProperty({__proto__:null,bitGet:Le,bitLen:Ie,bitMask:kt,bitSet:He,bytesToHex:ht,bytesToNumberBE:Y,bytesToNumberLE:$t,concatBytes:D,createHmacDrbg:te,ensureBytes:P,equalBytes:Ue,hexToBytes:dt,hexToNumber:Tt,numberToBytesBE:Q,numberToBytesLE:Vt,numberToHexUnpadded:Ft,numberToVarBytesBE:ve,utf8ToBytes:pt,validateObject:wt},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const k=BigInt(0),R=BigInt(1),st=BigInt(2),Oe=BigInt(3),Ct=BigInt(4),Pt=BigInt(5),zt=BigInt(8);BigInt(9);BigInt(16);function Z(t,n){const e=t%n;return e>=k?e:n+e}function qe(t,n,e){if(e<=k||n<k)throw new Error("Expected power/modulo > 0");if(e===R)return k;let r=R;for(;n>k;)n&R&&(r=r*t%e),t=t*t%e,n>>=R;return r}function Ot(t,n){if(t===k||n<=k)throw new Error(`invert: expected positive integers, got n=${t} mod=${n}`);let e=Z(t,n),r=n,o=k,i=R;for(;e!==k;){const c=r/e,f=r%e,a=o-i*c;r=e,e=f,o=i,i=a}if(r!==R)throw new Error("invert: does not exist");return Z(o,n)}function Ne(t){const n=(t-R)/st;let e,r,o;for(e=t-R,r=0;e%st===k;e/=st,r++);for(o=st;o<t&&qe(o,n,t)!==t-R;o++);if(r===1){const s=(t+R)/Ct;return function(f,a){const p=f.pow(a,s);if(!f.eql(f.sqr(p),a))throw new Error("Cannot find square root");return p}}const i=(e+R)/st;return function(c,f){if(c.pow(f,n)===c.neg(c.ONE))throw new Error("Cannot find square root");let a=r,p=c.pow(c.mul(c.ONE,o),e),u=c.pow(f,i),S=c.pow(f,e);for(;!c.eql(S,c.ONE);){if(c.eql(S,c.ZERO))return c.ZERO;let v=1;for(let l=c.sqr(S);v<a&&!c.eql(l,c.ONE);v++)l=c.sqr(l);const y=c.pow(p,R<<BigInt(a-v-1));p=c.sqr(y),u=c.mul(u,y),S=c.mul(S,p),a=v}return u}}function Re(t){if(t%Ct===Oe){const n=(t+R)/Ct;return function(r,o){const i=r.pow(o,n);if(!r.eql(r.sqr(i),o))throw new Error("Cannot find square root");return i}}if(t%zt===Pt){const n=(t-Pt)/zt;return function(r,o){const i=r.mul(o,st),s=r.pow(i,n),c=r.mul(o,s),f=r.mul(r.mul(c,st),s),a=r.mul(c,r.sub(f,r.ONE));if(!r.eql(r.sqr(a),o))throw new Error("Cannot find square root");return a}}return Ne(t)}const Te=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function ee(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},e=Te.reduce((r,o)=>(r[o]="function",r),n);return wt(t,e)}function $e(t,n,e){if(e<k)throw new Error("Expected power > 0");if(e===k)return t.ONE;if(e===R)return n;let r=t.ONE,o=n;for(;e>k;)e&R&&(r=t.mul(r,o)),o=t.sqr(o),e>>=R;return r}function Ve(t,n){const e=new Array(n.length),r=n.reduce((i,s,c)=>t.is0(s)?i:(e[c]=i,t.mul(i,s)),t.ONE),o=t.inv(r);return n.reduceRight((i,s,c)=>t.is0(s)?i:(e[c]=t.mul(i,e[c]),t.mul(i,s)),o),e}function ne(t,n){const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function re(t,n,e=!1,r={}){if(t<=k)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:o,nByteLength:i}=ne(t,n);if(i>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Re(t),c=Object.freeze({ORDER:t,BITS:o,BYTES:i,MASK:kt(o),ZERO:k,ONE:R,create:f=>Z(f,t),isValid:f=>{if(typeof f!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof f}`);return k<=f&&f<t},is0:f=>f===k,isOdd:f=>(f&R)===R,neg:f=>Z(-f,t),eql:(f,a)=>f===a,sqr:f=>Z(f*f,t),add:(f,a)=>Z(f+a,t),sub:(f,a)=>Z(f-a,t),mul:(f,a)=>Z(f*a,t),pow:(f,a)=>$e(c,f,a),div:(f,a)=>Z(f*Ot(a,t),t),sqrN:f=>f*f,addN:(f,a)=>f+a,subN:(f,a)=>f-a,mulN:(f,a)=>f*a,inv:f=>Ot(f,t),sqrt:r.sqrt||(f=>s(c,f)),invertBatch:f=>Ve(c,f),cmov:(f,a,p)=>p?a:f,toBytes:f=>e?Vt(f,i):Q(f,i),fromBytes:f=>{if(f.length!==i)throw new Error(`Fp.fromBytes: expected ${i}, got ${f.length}`);return e?$t(f):Y(f)}});return Object.freeze(c)}function oe(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const n=t.toString(2).length;return Math.ceil(n/8)}function ie(t){const n=oe(t);return n+Math.ceil(n/2)}function ke(t,n,e=!1){const r=t.length,o=oe(n),i=ie(n);if(r<16||r<i||r>1024)throw new Error(`expected ${i}-1024 bytes of input, got ${r}`);const s=e?Y(t):$t(t),c=Z(s,n-R)+R;return e?Vt(c,o):Q(c,o)}function Ht(t,n){let e=Q(t,n);return btoa(Array.from(e,r=>String.fromCharCode(r)).join("")).replace(/\+/g,"-").replace(/\//g,"_").replace(/=+$/,"")}class Et extends Error{constructor(e){super(e);W(this,"error_type");this.error_type=e}err(){return this.error_type}}function X(t){return typeof t=="string"?pt(t):t}class Ze{constructor(n,e){W(this,"EcGroup");W(this,"Fq");W(this,"hashToCurve");W(this,"coordinateSize");this.EcGroup=n,this.Fq=re(this.EcGroup.CURVE.n),this.hashToCurve=e,this.coordinateSize=this.EcGroup.CURVE.Fp.BYTES}curveName(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"P-256";if(n===384)return"P-384";if(n===521)return"P-521";throw new Et("UnknownCurveType")}hashAlgo(){const n=this.EcGroup.CURVE.Fp.BITS;if(n===256)return"SHA-256";if(n===384)return"SHA-384";if(n===521)return"SHA-512";throw new Et("UnknownCurveType")}blind(n){let e=this.EcGroup.utils.randomPrivateKey(),r=Y(e);if(r===BigInt(0))return this.blind(n);let o=X(n),i=this.hashToCurve(o).multiply(r);if(i.equals(this.EcGroup.ProjectivePoint.ZERO))throw new Et("HashedToInifinity");let s=this.EcGroup.ProjectivePoint.fromAffine(i.toAffine());return{hashed_password:n,blinder:r,clientRequestBytes:s.toHex(!1)}}async finalize(n,e){const r=window.crypto.subtle;let o=this.EcGroup.ProjectivePoint.fromHex(n);if(o.assertValidity(),o.toHex(!1)===e.clientRequestBytes)throw Error("Server tried to attack the client during OPRF finalize step by replaying the client's request");let s=this.Fq.inv(e.blinder),c=o.multiply(s).toRawBytes(!0);const f=D(Q(e.hashed_password.length,2),X(e.hashed_password),Q(c.length,2),c,X("Finalize")),a=await r.digest(this.hashAlgo(),f);return r.importKey("raw",a,"HKDF",!1,["deriveBits","deriveKey"])}async login_key(n,e){const r=this.EcGroup.CURVE,o=this.EcGroup.ProjectivePoint,i=globalThis.crypto.subtle,s=D(X(e),X("LoginKeySalt")),c=X("LoginKey"),f=await i.deriveBits({name:"HKDF",hash:"SHA-512",salt:s.buffer,info:c.buffer},n,8*(3*r.nByteLength/2));let a=Y(new Uint8Array(f)),p=Z(a,r.n),u=o.fromPrivateKey(p),S={crv:this.curveName(),d:Ht(p,r.nByteLength),ext:!0,key_ops:["sign"],kty:"EC",x:Ht(u.x,r.Fp.BYTES),y:Ht(u.y,r.Fp.BYTES)};return{loginKey:await i.importKey("jwk",S,{name:"ECDSA",namedCurve:this.curveName()},!0,["sign"]),publicKey:u.toRawBytes(!1)}}async lockbox_key(n,e){const r=globalThis.crypto.subtle,o=D(X(e),X("LockboxSalt")),i=X("LockboxKey");return r.deriveKey({name:"HKDF",hash:"SHA-512",salt:o.buffer,info:i.buffer},n,{name:"AES-GCM",length:256},!1,["encrypt","decrypt","wrapKey","unwrapKey"])}}function Mt(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function se(t,...n){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(n.length>0&&!n.includes(t.length))throw new Error(`Expected Uint8Array of length ${n}, not of length=${t.length}`)}function De(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");Mt(t.outputLen),Mt(t.blockLen)}function xt(t,n=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(n&&t.finished)throw new Error("Hash#digest() has already been called")}function Ke(t,n){se(t);const e=n.outputLen;if(t.length<e)throw new Error(`digestInto() expects output buffer of length at least ${e}`)}class ce extends Qt{constructor(n,e){super(),this.finished=!1,this.destroyed=!1,De(n);const r=Rt(e);if(this.iHash=n.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?n.create().update(r).digest():r);for(let s=0;s<i.length;s++)i[s]^=54;this.iHash.update(i),this.oHash=n.create();for(let s=0;s<i.length;s++)i[s]^=106;this.oHash.update(i),i.fill(0)}update(n){return xt(this),this.iHash.update(n),this}digestInto(n){xt(this),se(n,this.outputLen),this.finished=!0,this.iHash.digestInto(n),this.oHash.update(n),this.oHash.digestInto(n),this.destroy()}digest(){const n=new Uint8Array(this.oHash.outputLen);return this.digestInto(n),n}_cloneInto(n){n||(n=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:o,destroyed:i,blockLen:s,outputLen:c}=this;return n=n,n.finished=o,n.destroyed=i,n.blockLen=s,n.outputLen=c,n.oHash=e._cloneInto(n.oHash),n.iHash=r._cloneInto(n.iHash),n}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const fe=(t,n,e)=>new ce(t,n).update(e).digest();fe.create=(t,n)=>new ce(t,n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const je=BigInt(0),_t=BigInt(1);function Ge(t,n){const e=(o,i)=>{const s=i.negate();return o?s:i},r=o=>{const i=Math.ceil(n/o)+1,s=2**(o-1);return{windows:i,windowSize:s}};return{constTimeNegate:e,unsafeLadder(o,i){let s=t.ZERO,c=o;for(;i>je;)i&_t&&(s=s.add(c)),c=c.double(),i>>=_t;return s},precomputeWindow(o,i){const{windows:s,windowSize:c}=r(i),f=[];let a=o,p=a;for(let u=0;u<s;u++){p=a,f.push(p);for(let S=1;S<c;S++)p=p.add(a),f.push(p);a=p.double()}return f},wNAF(o,i,s){const{windows:c,windowSize:f}=r(o);let a=t.ZERO,p=t.BASE;const u=BigInt(2**o-1),S=2**o,v=BigInt(o);for(let y=0;y<c;y++){const l=y*f;let h=Number(s&u);s>>=v,h>f&&(h-=S,s+=_t);const d=l,g=l+Math.abs(h)-1,w=y%2!==0,A=h<0;h===0?p=p.add(e(w,i[d])):a=a.add(e(A,i[g]))}return{p:a,f:p}},wNAFCached(o,i,s,c){const f=o._WINDOW_SIZE||1;let a=i.get(o);return a||(a=this.precomputeWindow(o,f),f!==1&&i.set(o,c(a))),this.wNAF(f,a,s)}}}function ae(t){return ee(t.Fp),wt(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...ne(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Pe(t){const n=ae(t);wt(n,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:e,Fp:r,a:o}=n;if(e){if(!r.eql(o,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof e!="object"||typeof e.beta!="bigint"||typeof e.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...n})}const{bytesToNumberBE:ze,hexToBytes:Me}=Ce,ct={Err:class extends Error{constructor(n=""){super(n)}},_parseInt(t){const{Err:n}=ct;if(t.length<2||t[0]!==2)throw new n("Invalid signature integer tag");const e=t[1],r=t.subarray(2,e+2);if(!e||r.length!==e)throw new n("Invalid signature integer: wrong length");if(r[0]&128)throw new n("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new n("Invalid signature integer: unnecessary leading zero");return{d:ze(r),l:t.subarray(e+2)}},toSig(t){const{Err:n}=ct,e=typeof t=="string"?Me(t):t;if(!(e instanceof Uint8Array))throw new Error("ui8a expected");let r=e.length;if(r<2||e[0]!=48)throw new n("Invalid signature tag");if(e[1]!==r-2)throw new n("Invalid signature: incorrect length");const{d:o,l:i}=ct._parseInt(e.subarray(2)),{d:s,l:c}=ct._parseInt(i);if(c.length)throw new n("Invalid signature: left bytes after parsing");return{r:o,s}},hexFromSig(t){const n=a=>Number.parseInt(a[0],16)&8?"00"+a:a,e=a=>{const p=a.toString(16);return p.length&1?`0${p}`:p},r=n(e(t.s)),o=n(e(t.r)),i=r.length/2,s=o.length/2,c=e(i),f=e(s);return`30${e(s+i+4)}02${f}${o}02${c}${r}`}},z=BigInt(0),N=BigInt(1),et=BigInt(2),Bt=BigInt(3),Wt=BigInt(4);function We(t){const n=Pe(t),{Fp:e}=n,r=n.toBytes||((y,l,h)=>{const d=l.toAffine();return D(Uint8Array.from([4]),e.toBytes(d.x),e.toBytes(d.y))}),o=n.fromBytes||(y=>{const l=y.subarray(1),h=e.fromBytes(l.subarray(0,e.BYTES)),d=e.fromBytes(l.subarray(e.BYTES,2*e.BYTES));return{x:h,y:d}});function i(y){const{a:l,b:h}=n,d=e.sqr(y),g=e.mul(d,y);return e.add(e.add(g,e.mul(y,l)),h)}if(!e.eql(e.sqr(n.Gy),i(n.Gx)))throw new Error("bad generator point: equation left != right");function s(y){return typeof y=="bigint"&&z<y&&y<n.n}function c(y){if(!s(y))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function f(y){const{allowedPrivateKeyLengths:l,nByteLength:h,wrapPrivateKey:d,n:g}=n;if(l&&typeof y!="bigint"){if(y instanceof Uint8Array&&(y=ht(y)),typeof y!="string"||!l.includes(y.length))throw new Error("Invalid key");y=y.padStart(h*2,"0")}let w;try{w=typeof y=="bigint"?y:Y(P("private key",y,h))}catch{throw new Error(`private key must be ${h} bytes, hex or bigint, not ${typeof y}`)}return d&&(w=Z(w,g)),c(w),w}const a=new Map;function p(y){if(!(y instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(l,h,d){if(this.px=l,this.py=h,this.pz=d,l==null||!e.isValid(l))throw new Error("x required");if(h==null||!e.isValid(h))throw new Error("y required");if(d==null||!e.isValid(d))throw new Error("z required")}static fromAffine(l){const{x:h,y:d}=l||{};if(!l||!e.isValid(h)||!e.isValid(d))throw new Error("invalid affine point");if(l instanceof u)throw new Error("projective point not allowed");const g=w=>e.eql(w,e.ZERO);return g(h)&&g(d)?u.ZERO:new u(h,d,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(l){const h=e.invertBatch(l.map(d=>d.pz));return l.map((d,g)=>d.toAffine(h[g])).map(u.fromAffine)}static fromHex(l){const h=u.fromAffine(o(P("pointHex",l)));return h.assertValidity(),h}static fromPrivateKey(l){return u.BASE.multiply(f(l))}_setWindowSize(l){this._WINDOW_SIZE=l,a.delete(this)}assertValidity(){if(this.is0()){if(n.allowInfinityPoint&&!e.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:l,y:h}=this.toAffine();if(!e.isValid(l)||!e.isValid(h))throw new Error("bad point: x or y not FE");const d=e.sqr(h),g=i(l);if(!e.eql(d,g))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:l}=this.toAffine();if(e.isOdd)return!e.isOdd(l);throw new Error("Field doesn't support isOdd")}equals(l){p(l);const{px:h,py:d,pz:g}=this,{px:w,py:A,pz:U}=l,E=e.eql(e.mul(h,U),e.mul(w,g)),x=e.eql(e.mul(d,U),e.mul(A,g));return E&&x}negate(){return new u(this.px,e.neg(this.py),this.pz)}double(){const{a:l,b:h}=n,d=e.mul(h,Bt),{px:g,py:w,pz:A}=this;let U=e.ZERO,E=e.ZERO,x=e.ZERO,B=e.mul(g,g),O=e.mul(w,w),_=e.mul(A,A),H=e.mul(g,w);return H=e.add(H,H),x=e.mul(g,A),x=e.add(x,x),U=e.mul(l,x),E=e.mul(d,_),E=e.add(U,E),U=e.sub(O,E),E=e.add(O,E),E=e.mul(U,E),U=e.mul(H,U),x=e.mul(d,x),_=e.mul(l,_),H=e.sub(B,_),H=e.mul(l,H),H=e.add(H,x),x=e.add(B,B),B=e.add(x,B),B=e.add(B,_),B=e.mul(B,H),E=e.add(E,B),_=e.mul(w,A),_=e.add(_,_),B=e.mul(_,H),U=e.sub(U,B),x=e.mul(_,O),x=e.add(x,x),x=e.add(x,x),new u(U,E,x)}add(l){p(l);const{px:h,py:d,pz:g}=this,{px:w,py:A,pz:U}=l;let E=e.ZERO,x=e.ZERO,B=e.ZERO;const O=n.a,_=e.mul(n.b,Bt);let H=e.mul(h,w),T=e.mul(d,A),V=e.mul(g,U),M=e.add(h,d),b=e.add(w,A);M=e.mul(M,b),b=e.add(H,T),M=e.sub(M,b),b=e.add(h,g);let m=e.add(w,U);return b=e.mul(b,m),m=e.add(H,V),b=e.sub(b,m),m=e.add(d,g),E=e.add(A,U),m=e.mul(m,E),E=e.add(T,V),m=e.sub(m,E),B=e.mul(O,b),E=e.mul(_,V),B=e.add(E,B),E=e.sub(T,B),B=e.add(T,B),x=e.mul(E,B),T=e.add(H,H),T=e.add(T,H),V=e.mul(O,V),b=e.mul(_,b),T=e.add(T,V),V=e.sub(H,V),V=e.mul(O,V),b=e.add(b,V),H=e.mul(T,b),x=e.add(x,H),H=e.mul(m,b),E=e.mul(M,E),E=e.sub(E,H),H=e.mul(M,T),B=e.mul(m,B),B=e.add(B,H),new u(E,x,B)}subtract(l){return this.add(l.negate())}is0(){return this.equals(u.ZERO)}wNAF(l){return v.wNAFCached(this,a,l,h=>{const d=e.invertBatch(h.map(g=>g.pz));return h.map((g,w)=>g.toAffine(d[w])).map(u.fromAffine)})}multiplyUnsafe(l){const h=u.ZERO;if(l===z)return h;if(c(l),l===N)return this;const{endo:d}=n;if(!d)return v.unsafeLadder(this,l);let{k1neg:g,k1:w,k2neg:A,k2:U}=d.splitScalar(l),E=h,x=h,B=this;for(;w>z||U>z;)w&N&&(E=E.add(B)),U&N&&(x=x.add(B)),B=B.double(),w>>=N,U>>=N;return g&&(E=E.negate()),A&&(x=x.negate()),x=new u(e.mul(x.px,d.beta),x.py,x.pz),E.add(x)}multiply(l){c(l);let h=l,d,g;const{endo:w}=n;if(w){const{k1neg:A,k1:U,k2neg:E,k2:x}=w.splitScalar(h);let{p:B,f:O}=this.wNAF(U),{p:_,f:H}=this.wNAF(x);B=v.constTimeNegate(A,B),_=v.constTimeNegate(E,_),_=new u(e.mul(_.px,w.beta),_.py,_.pz),d=B.add(_),g=O.add(H)}else{const{p:A,f:U}=this.wNAF(h);d=A,g=U}return u.normalizeZ([d,g])[0]}multiplyAndAddUnsafe(l,h,d){const g=u.BASE,w=(U,E)=>E===z||E===N||!U.equals(g)?U.multiplyUnsafe(E):U.multiply(E),A=w(this,h).add(w(l,d));return A.is0()?void 0:A}toAffine(l){const{px:h,py:d,pz:g}=this,w=this.is0();l==null&&(l=w?e.ONE:e.inv(g));const A=e.mul(h,l),U=e.mul(d,l),E=e.mul(g,l);if(w)return{x:e.ZERO,y:e.ZERO};if(!e.eql(E,e.ONE))throw new Error("invZ was invalid");return{x:A,y:U}}isTorsionFree(){const{h:l,isTorsionFree:h}=n;if(l===N)return!0;if(h)return h(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:l,clearCofactor:h}=n;return l===N?this:h?h(u,this):this.multiplyUnsafe(n.h)}toRawBytes(l=!0){return this.assertValidity(),r(u,this,l)}toHex(l=!0){return ht(this.toRawBytes(l))}}u.BASE=new u(n.Gx,n.Gy,e.ONE),u.ZERO=new u(e.ZERO,e.ONE,e.ZERO);const S=n.nBitLength,v=Ge(u,n.endo?Math.ceil(S/2):S);return{CURVE:n,ProjectivePoint:u,normPrivateKeyToScalar:f,weierstrassEquation:i,isWithinCurveOrder:s}}function Ye(t){const n=ae(t);return wt(n,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...n})}function Xe(t){const n=Ye(t),{Fp:e,n:r}=n,o=e.BYTES+1,i=2*e.BYTES+1;function s(b){return z<b&&b<e.ORDER}function c(b){return Z(b,r)}function f(b){return Ot(b,r)}const{ProjectivePoint:a,normPrivateKeyToScalar:p,weierstrassEquation:u,isWithinCurveOrder:S}=We({...n,toBytes(b,m,L){const q=m.toAffine(),C=e.toBytes(q.x),$=D;return L?$(Uint8Array.from([m.hasEvenY()?2:3]),C):$(Uint8Array.from([4]),C,e.toBytes(q.y))},fromBytes(b){const m=b.length,L=b[0],q=b.subarray(1);if(m===o&&(L===2||L===3)){const C=Y(q);if(!s(C))throw new Error("Point is not on curve");const $=u(C);let K=e.sqrt($);const j=(K&N)===N;return(L&1)===1!==j&&(K=e.neg(K)),{x:C,y:K}}else if(m===i&&L===4){const C=e.fromBytes(q.subarray(0,e.BYTES)),$=e.fromBytes(q.subarray(e.BYTES,2*e.BYTES));return{x:C,y:$}}else throw new Error(`Point of length ${m} was invalid. Expected ${o} compressed bytes or ${i} uncompressed bytes`)}}),v=b=>ht(Q(b,n.nByteLength));function y(b){const m=r>>N;return b>m}function l(b){return y(b)?c(-b):b}const h=(b,m,L)=>Y(b.slice(m,L));class d{constructor(m,L,q){this.r=m,this.s=L,this.recovery=q,this.assertValidity()}static fromCompact(m){const L=n.nByteLength;return m=P("compactSignature",m,L*2),new d(h(m,0,L),h(m,L,2*L))}static fromDER(m){const{r:L,s:q}=ct.toSig(P("DER",m));return new d(L,q)}assertValidity(){if(!S(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!S(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(m){return new d(this.r,this.s,m)}recoverPublicKey(m){const{r:L,s:q,recovery:C}=this,$=x(P("msgHash",m));if(C==null||![0,1,2,3].includes(C))throw new Error("recovery id invalid");const K=C===2||C===3?L+n.n:L;if(K>=e.ORDER)throw new Error("recovery id 2 or 3 invalid");const j=C&1?"03":"02",J=a.fromHex(j+v(K)),F=f(K),ft=c(-$*F),bt=c(q*F),tt=a.BASE.multiplyAndAddUnsafe(J,ft,bt);if(!tt)throw new Error("point at infinify");return tt.assertValidity(),tt}hasHighS(){return y(this.s)}normalizeS(){return this.hasHighS()?new d(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return dt(this.toDERHex())}toDERHex(){return ct.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return dt(this.toCompactHex())}toCompactHex(){return v(this.r)+v(this.s)}}const g={isValidPrivateKey(b){try{return p(b),!0}catch{return!1}},normPrivateKeyToScalar:p,randomPrivateKey:()=>{const b=ie(n.n);return ke(n.randomBytes(b),n.n)},precompute(b=8,m=a.BASE){return m._setWindowSize(b),m.multiply(BigInt(3)),m}};function w(b,m=!0){return a.fromPrivateKey(b).toRawBytes(m)}function A(b){const m=b instanceof Uint8Array,L=typeof b=="string",q=(m||L)&&b.length;return m?q===o||q===i:L?q===2*o||q===2*i:b instanceof a}function U(b,m,L=!0){if(A(b))throw new Error("first arg must be private key");if(!A(m))throw new Error("second arg must be public key");return a.fromHex(m).multiply(p(b)).toRawBytes(L)}const E=n.bits2int||function(b){const m=Y(b),L=b.length*8-n.nBitLength;return L>0?m>>BigInt(L):m},x=n.bits2int_modN||function(b){return c(E(b))},B=kt(n.nBitLength);function O(b){if(typeof b!="bigint")throw new Error("bigint expected");if(!(z<=b&&b<B))throw new Error(`bigint expected < 2^${n.nBitLength}`);return Q(b,n.nByteLength)}function _(b,m,L=H){if(["recovered","canonical"].some(it=>it in L))throw new Error("sign() legacy options not supported");const{hash:q,randomBytes:C}=n;let{lowS:$,prehash:K,extraEntropy:j}=L;$==null&&($=!0),b=P("msgHash",b),K&&(b=P("prehashed msgHash",q(b)));const J=x(b),F=p(m),ft=[O(F),O(J)];if(j!=null){const it=j===!0?C(e.BYTES):j;ft.push(P("extraEntropy",it))}const bt=D(...ft),tt=J;function vt(it){const at=E(it);if(!S(at))return;const Dt=f(at),lt=a.BASE.multiply(at).toAffine(),G=c(lt.x);if(G===z)return;const ut=c(Dt*c(tt+G*F));if(ut===z)return;let Kt=(lt.x===G?0:2)|Number(lt.y&N),jt=ut;return $&&y(ut)&&(jt=l(ut),Kt^=1),new d(G,jt,Kt)}return{seed:bt,k2sig:vt}}const H={lowS:n.lowS,prehash:!1},T={lowS:n.lowS,prehash:!1};function V(b,m,L=H){const{seed:q,k2sig:C}=_(b,m,L),$=n;return te($.hash.outputLen,$.nByteLength,$.hmac)(q,C)}a.BASE._setWindowSize(8);function M(b,m,L,q=T){var lt;const C=b;if(m=P("msgHash",m),L=P("publicKey",L),"strict"in q)throw new Error("options.strict was renamed to lowS");const{lowS:$,prehash:K}=q;let j,J;try{if(typeof C=="string"||C instanceof Uint8Array)try{j=d.fromDER(C)}catch(G){if(!(G instanceof ct.Err))throw G;j=d.fromCompact(C)}else if(typeof C=="object"&&typeof C.r=="bigint"&&typeof C.s=="bigint"){const{r:G,s:ut}=C;j=new d(G,ut)}else throw new Error("PARSE");J=a.fromHex(L)}catch(G){if(G.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if($&&j.hasHighS())return!1;K&&(m=n.hash(m));const{r:F,s:ft}=j,bt=x(m),tt=f(ft),vt=c(bt*tt),it=c(F*tt),at=(lt=a.BASE.multiplyAndAddUnsafe(J,vt,it))==null?void 0:lt.toAffine();return at?c(at.x)===F:!1}return{CURVE:n,getPublicKey:w,getSharedSecret:U,sign:V,verify:M,ProjectivePoint:a,Signature:d,utils:g}}function Qe(t,n){const e=t.ORDER;let r=z;for(let y=e-N;y%et===z;y/=et)r+=N;const o=r,i=et<<o-N-N,s=i*et,c=(e-N)/s,f=(c-N)/et,a=s-N,p=i,u=t.pow(n,c),S=t.pow(n,(c+N)/et);let v=(y,l)=>{let h=u,d=t.pow(l,a),g=t.sqr(d);g=t.mul(g,l);let w=t.mul(y,g);w=t.pow(w,f),w=t.mul(w,d),d=t.mul(w,l),g=t.mul(w,y);let A=t.mul(g,d);w=t.pow(A,p);let U=t.eql(w,t.ONE);d=t.mul(g,S),w=t.mul(A,h),g=t.cmov(d,g,U),A=t.cmov(w,A,U);for(let E=o;E>N;E--){let x=E-et;x=et<<x-N;let B=t.pow(A,x);const O=t.eql(B,t.ONE);d=t.mul(g,h),h=t.mul(h,h),B=t.mul(A,h),g=t.cmov(d,g,O),A=t.cmov(B,A,O)}return{isValid:U,value:g}};if(t.ORDER%Wt===Bt){const y=(t.ORDER-Bt)/Wt,l=t.sqrt(t.neg(n));v=(h,d)=>{let g=t.sqr(d);const w=t.mul(h,d);g=t.mul(g,w);let A=t.pow(g,y);A=t.mul(A,w);const U=t.mul(A,l),E=t.mul(t.sqr(A),d),x=t.eql(E,h);let B=t.cmov(U,A,x);return{isValid:x,value:B}}}return v}function Je(t,n){if(ee(t),!t.isValid(n.A)||!t.isValid(n.B)||!t.isValid(n.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const e=Qe(t,n.Z);if(!t.isOdd)throw new Error("Fp.isOdd is not implemented!");return r=>{let o,i,s,c,f,a,p,u;o=t.sqr(r),o=t.mul(o,n.Z),i=t.sqr(o),i=t.add(i,o),s=t.add(i,t.ONE),s=t.mul(s,n.B),c=t.cmov(n.Z,t.neg(i),!t.eql(i,t.ZERO)),c=t.mul(c,n.A),i=t.sqr(s),a=t.sqr(c),f=t.mul(a,n.A),i=t.add(i,f),i=t.mul(i,s),a=t.mul(a,c),f=t.mul(a,n.B),i=t.add(i,f),p=t.mul(o,s);const{isValid:S,value:v}=e(i,a);u=t.mul(o,r),u=t.mul(u,v),p=t.cmov(p,s,S),u=t.cmov(u,v,S);const y=t.isOdd(r)===t.isOdd(u);return u=t.cmov(t.neg(u),u,y),p=t.div(p,c),{x:p,y:u}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Fe(t){return{hash:t,hmac:(n,...e)=>fe(t,n,me(...e)),randomBytes:xe}}function tn(t,n){const e=r=>Xe({...t,...Fe(r)});return Object.freeze({...e(n),create:e})}function en(t,n,e,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(n,e,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(e>>o&i),c=Number(e&i),f=r?4:0,a=r?0:4;t.setUint32(n+f,s,r),t.setUint32(n+a,c,r)}class nn extends Qt{constructor(n,e,r,o){super(),this.blockLen=n,this.outputLen=e,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(n),this.view=It(this.buffer)}update(n){xt(this);const{view:e,buffer:r,blockLen:o}=this;n=Rt(n);const i=n.length;for(let s=0;s<i;){const c=Math.min(o-this.pos,i-s);if(c===o){const f=It(n);for(;o<=i-s;s+=o)this.process(f,s);continue}r.set(n.subarray(s,s+c),this.pos),this.pos+=c,s+=c,this.pos===o&&(this.process(e,0),this.pos=0)}return this.length+=n.length,this.roundClean(),this}digestInto(n){xt(this),Ke(n,this),this.finished=!0;const{buffer:e,view:r,blockLen:o,isLE:i}=this;let{pos:s}=this;e[s++]=128,this.buffer.subarray(s).fill(0),this.padOffset>o-s&&(this.process(r,0),s=0);for(let u=s;u<o;u++)e[u]=0;en(r,o-8,BigInt(this.length*8),i),this.process(r,0);const c=It(n),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const a=f/4,p=this.get();if(a>p.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<a;u++)c.setUint32(4*u,p[u],i)}digest(){const{buffer:n,outputLen:e}=this;this.digestInto(n);const r=n.slice(0,e);return this.destroy(),r}_cloneInto(n){n||(n=new this.constructor),n.set(...this.get());const{blockLen:e,buffer:r,length:o,finished:i,destroyed:s,pos:c}=this;return n.length=o,n.pos=c,n.finished=i,n.destroyed=s,o%e&&n.buffer.set(r),n}}const mt=BigInt(2**32-1),qt=BigInt(32);function le(t,n=!1){return n?{h:Number(t&mt),l:Number(t>>qt&mt)}:{h:Number(t>>qt&mt)|0,l:Number(t&mt)|0}}function rn(t,n=!1){let e=new Uint32Array(t.length),r=new Uint32Array(t.length);for(let o=0;o<t.length;o++){const{h:i,l:s}=le(t[o],n);[e[o],r[o]]=[i,s]}return[e,r]}const on=(t,n)=>BigInt(t>>>0)<<qt|BigInt(n>>>0),sn=(t,n,e)=>t>>>e,cn=(t,n,e)=>t<<32-e|n>>>e,fn=(t,n,e)=>t>>>e|n<<32-e,an=(t,n,e)=>t<<32-e|n>>>e,ln=(t,n,e)=>t<<64-e|n>>>e-32,un=(t,n,e)=>t>>>e-32|n<<64-e,hn=(t,n)=>n,dn=(t,n)=>t,wn=(t,n,e)=>t<<e|n>>>32-e,bn=(t,n,e)=>n<<e|t>>>32-e,gn=(t,n,e)=>n<<e-32|t>>>64-e,yn=(t,n,e)=>t<<e-32|n>>>64-e;function pn(t,n,e,r){const o=(n>>>0)+(r>>>0);return{h:t+e+(o/2**32|0)|0,l:o|0}}const mn=(t,n,e)=>(t>>>0)+(n>>>0)+(e>>>0),En=(t,n,e,r)=>n+e+r+(t/2**32|0)|0,xn=(t,n,e,r)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0),Bn=(t,n,e,r,o)=>n+e+r+o+(t/2**32|0)|0,Sn=(t,n,e,r,o)=>(t>>>0)+(n>>>0)+(e>>>0)+(r>>>0)+(o>>>0),An=(t,n,e,r,o,i)=>n+e+r+o+i+(t/2**32|0)|0,vn={fromBig:le,split:rn,toBig:on,shrSH:sn,shrSL:cn,rotrSH:fn,rotrSL:an,rotrBH:ln,rotrBL:un,rotr32H:hn,rotr32L:dn,rotlSH:wn,rotlSL:bn,rotlBH:gn,rotlBL:yn,add:pn,add3L:mn,add3H:En,add4L:xn,add4H:Bn,add5H:An,add5L:Sn},I=vn,[Un,In]=(()=>I.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))))(),nt=new Uint32Array(80),rt=new Uint32Array(80);class Ln extends nn{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:n,Al:e,Bh:r,Bl:o,Ch:i,Cl:s,Dh:c,Dl:f,Eh:a,El:p,Fh:u,Fl:S,Gh:v,Gl:y,Hh:l,Hl:h}=this;return[n,e,r,o,i,s,c,f,a,p,u,S,v,y,l,h]}set(n,e,r,o,i,s,c,f,a,p,u,S,v,y,l,h){this.Ah=n|0,this.Al=e|0,this.Bh=r|0,this.Bl=o|0,this.Ch=i|0,this.Cl=s|0,this.Dh=c|0,this.Dl=f|0,this.Eh=a|0,this.El=p|0,this.Fh=u|0,this.Fl=S|0,this.Gh=v|0,this.Gl=y|0,this.Hh=l|0,this.Hl=h|0}process(n,e){for(let w=0;w<16;w++,e+=4)nt[w]=n.getUint32(e),rt[w]=n.getUint32(e+=4);for(let w=16;w<80;w++){const A=nt[w-15]|0,U=rt[w-15]|0,E=I.rotrSH(A,U,1)^I.rotrSH(A,U,8)^I.shrSH(A,U,7),x=I.rotrSL(A,U,1)^I.rotrSL(A,U,8)^I.shrSL(A,U,7),B=nt[w-2]|0,O=rt[w-2]|0,_=I.rotrSH(B,O,19)^I.rotrBH(B,O,61)^I.shrSH(B,O,6),H=I.rotrSL(B,O,19)^I.rotrBL(B,O,61)^I.shrSL(B,O,6),T=I.add4L(x,H,rt[w-7],rt[w-16]),V=I.add4H(T,E,_,nt[w-7],nt[w-16]);nt[w]=V|0,rt[w]=T|0}let{Ah:r,Al:o,Bh:i,Bl:s,Ch:c,Cl:f,Dh:a,Dl:p,Eh:u,El:S,Fh:v,Fl:y,Gh:l,Gl:h,Hh:d,Hl:g}=this;for(let w=0;w<80;w++){const A=I.rotrSH(u,S,14)^I.rotrSH(u,S,18)^I.rotrBH(u,S,41),U=I.rotrSL(u,S,14)^I.rotrSL(u,S,18)^I.rotrBL(u,S,41),E=u&v^~u&l,x=S&y^~S&h,B=I.add5L(g,U,x,In[w],rt[w]),O=I.add5H(B,d,A,E,Un[w],nt[w]),_=B|0,H=I.rotrSH(r,o,28)^I.rotrBH(r,o,34)^I.rotrBH(r,o,39),T=I.rotrSL(r,o,28)^I.rotrBL(r,o,34)^I.rotrBL(r,o,39),V=r&i^r&c^i&c,M=o&s^o&f^s&f;d=l|0,g=h|0,l=v|0,h=y|0,v=u|0,y=S|0,{h:u,l:S}=I.add(a|0,p|0,O|0,_|0),a=c|0,p=f|0,c=i|0,f=s|0,i=r|0,s=o|0;const b=I.add3L(_,T,M);r=I.add3H(b,O,H,V),o=b|0}({h:r,l:o}=I.add(this.Ah|0,this.Al|0,r|0,o|0)),{h:i,l:s}=I.add(this.Bh|0,this.Bl|0,i|0,s|0),{h:c,l:f}=I.add(this.Ch|0,this.Cl|0,c|0,f|0),{h:a,l:p}=I.add(this.Dh|0,this.Dl|0,a|0,p|0),{h:u,l:S}=I.add(this.Eh|0,this.El|0,u|0,S|0),{h:v,l:y}=I.add(this.Fh|0,this.Fl|0,v|0,y|0),{h:l,l:h}=I.add(this.Gh|0,this.Gl|0,l|0,h|0),{h:d,l:g}=I.add(this.Hh|0,this.Hl|0,d|0,g|0),this.set(r,o,i,s,c,f,a,p,u,S,v,y,l,h,d,g)}roundClean(){nt.fill(0),rt.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}class Hn extends Ln{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const ue=Ee(()=>new Hn);function _n(t){if(t instanceof Uint8Array)return t;if(typeof t=="string")return pt(t);throw new Error("DST must be Uint8Array or string")}const Cn=Y;function ot(t,n){if(t<0||t>=1<<8*n)throw new Error(`bad I2OSP call: value=${t} length=${n}`);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function On(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function gt(t){if(!(t instanceof Uint8Array))throw new Error("Uint8Array expected")}function Zt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function qn(t,n,e,r){gt(t),gt(n),Zt(e),n.length>255&&(n=r(D(pt("H2C-OVERSIZE-DST-"),n)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(e/o);if(s>255)throw new Error("Invalid xmd length");const c=D(n,ot(n.length,1)),f=ot(0,i),a=ot(e,2),p=new Array(s),u=r(D(f,t,a,ot(0,1),c));p[0]=r(D(u,ot(1,1),c));for(let v=1;v<=s;v++){const y=[On(u,p[v-1]),ot(v+1,1),c];p[v]=r(D(...y))}return D(...p).slice(0,e)}function Nn(t,n,e,r,o){if(gt(t),gt(n),Zt(e),n.length>255){const i=Math.ceil(2*r/8);n=o.create({dkLen:i}).update(pt("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:e}).update(t).update(ot(e,2)).update(n).update(ot(n.length,1)).digest()}function Yt(t,n,e){wt(e,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:c,DST:f}=e;gt(t),Zt(n);const a=_n(f),p=r.toString(2).length,u=Math.ceil((p+o)/8),S=n*i*u;let v;if(c==="xmd")v=qn(t,a,S,s);else if(c==="xof")v=Nn(t,a,S,o,s);else if(c==="_internal_pass")v=t;else throw new Error('expand must be "xmd" or "xof"');const y=new Array(n);for(let l=0;l<n;l++){const h=new Array(i);for(let d=0;d<i;d++){const g=u*(d+l*i),w=v.subarray(g,g+u);h[d]=Z(Cn(w),r)}y[l]=h}return y}function Rn(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");return{hashToCurve(r,o){const i=Yt(r,2,{...e,DST:e.DST,...o}),s=t.fromAffine(n(i[0])),c=t.fromAffine(n(i[1])),f=s.add(c).clearCofactor();return f.assertValidity(),f},encodeToCurve(r,o){const i=Yt(r,1,{...e,DST:e.encodeDST,...o}),s=t.fromAffine(n(i[0])).clearCofactor();return s.assertValidity(),s}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Tn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),yt=re(Tn),he=yt.create(BigInt("-3")),de=BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Nt=tn({a:he,b:de,Fp:yt,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},ue),$n=Nt,Vn=(()=>Je(yt,{A:he,B:de,Z:yt.create(BigInt("-12"))}))(),kn=(()=>Rn($n.ProjectivePoint,t=>Vn(t[0]),{DST:"P384_XMD:SHA-384_SSWU_RO_",encodeDST:"P384_XMD:SHA-384_SSWU_NU_",p:yt.ORDER,m:1,k:192,expand:"xmd",hash:ue}))(),Zn=(()=>kn.hashToCurve)();class Qn{constructor(n){W(this,"discoveryURL");W(this,"baseURL");W(this,"oprfClient");W(this,"oprfClientData",null);if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto");this.discoveryURL=n;const e=new URL(this.discoveryURL);this.baseURL=e.origin,this.oprfClient=new Ze(Nt,Zn)}async computeOprfClientData(n,e){try{e.salt||(e.salt=Be(window.crypto.getRandomValues(new Uint8Array(32))));const r=await Dn(n,e,Nt.CURVE.nByteLength);return this.oprfClientData=this.oprfClient.blind(r),this.oprfClientData}catch(r){if(r instanceof Et&&r.err()=="HashedToInifinity")return this.computeOprfClientData(n,e);throw r}}async parseServerResponse(n){if(n.ok){const e=await n.json();if(e.code>=200&&e.code<300)return e.message;throw new Error(`Server returned unexpected response with code: ${e.code} and message: ${e.message}`)}else{const e=await n.json();throw new Error(`Server error: ${e.code} => ${e.message}`)}}async fetchUserInfo(n,e,r){const o=await this.fetchDirectory();let i=`${this.discoveryURL}${o.user_info}?user_name=${n}`;e&&(i=`${i}&domain=${e}`),r&&(i=`${i}&domain=${r}`);const s=await fetch(i,{mode:"cors",cache:"no-store"});return this.parseServerResponse(s)}}async function Dn(t,n,e){const r=t+n.domain_name+n.user_name+t,o=await globalThis.crypto.subtle.importKey("raw",new TextEncoder().encode(r),{name:"PBKDF2"},!1,["deriveBits"]);let i=ye(n.salt),s=await globalThis.crypto.subtle.deriveBits({name:"PBKDF2",salt:i,iterations:1e6,hash:"SHA-256"},o,8*e);return new Uint8Array(s)}export{Qn as U,zn as V,Gn as a,Yn as b,me as c,Wn as d,Pn as e,Mn as f,jn as i,Be as t,pe as u};

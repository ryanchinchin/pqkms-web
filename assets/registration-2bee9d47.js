var x=Object.defineProperty;var k=(s,a,e)=>a in s?x(s,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[a]=e;var m=(s,a,e)=>(k(s,typeof a!="symbol"?a+"":a,e),e);import{a as u,i as f,b as v,c as D,U,t as y,f as w,e as T,d as P,u as S,g as b,V as R}from"./auth_base-f9acc7de.js";import{_ as E}from"./index-cb61d0b3.js";const L=async(s,a="little")=>{u(s.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await h.hsm().exportKey("jwk",s);u(!f(e.kty)&&!f(e.e)&&!f(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const t=v(e.e);return u(t.byteLength==1&&new DataView(t).getUint8(0)===3),v(e.n,a)},p=class p{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return p.CRYPTO.subtle}uuid(){return p.CRYPTO.randomUUID()}async sgx_rsa_key(){if(D()==="Safari"){const{sgxCompatKey:a}=await E(()=>import("./compat-9f3c673e.js"),["assets/compat-9f3c673e.js","assets/auth_base-f9acc7de.js"]);return a(p.hsm())}else{const a=new Uint8Array([3]),e=["sign","verify"],t={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:a,hash:"SHA-256"};return await p.hsm().generateKey(t,!0,e)}}async sign_enclave(a,e){return u(e.type==="private"),u(e.algorithm.name==="RSASSA-PKCS1-v1_5"),p.hsm().sign(e.algorithm.name,e,a)}async verify_enclave(a,e,t){return u(t.algorithm.name==="RSASSA-PKCS1-v1_5"),u(t.type==="public"),p.hsm().verify(t.algorithm.name,t,e,a)}};m(p,"CRYPTO",globalThis.crypto);let h=p;const A={attestation:"/v0/admin/attestation",registration_init:"/v0/admin/reg_init",enclave_list:"/v0/admin/enclaves",registration_finish:"/v0/admin/reg_finish",user_info:"/v0/admin/user_info"};class O extends U{constructor(e){super(e);m(this,"directory",null)}async fetchDirectory(){if(this.directory)return this.directory;try{const e=await fetch(this.discoveryURL,{mode:"cors"});if(e.ok){let t=await e.json();this.directory=t.v0}else this.directory=A}catch{this.directory=A}return this.directory}async fetchEnclaveList(){let e=await this.fetchDirectory();const t=`${this.baseURL}${e.enclave_list}`,n=await fetch(t,{mode:"cors"});return await this.parseServerResponse(n)}async signEnclaves(e,t,n){const r=new h;u(e.type==="private"),u(t.type==="public");let l=await L(t,"big"),o={user_info:null,server_nonce:null,signer_modulus:y(l),signed_enclaves:[]};for(let i of n.enclaves){const c=w(i.tbs_data),d=w(i.sighash),_=await h.hsm().digest("SHA-256",c);let g={is_ok:!1,signature:"",enclave_name:i.enclave_name,config:i.config};if(!T(d,_))g.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const C=await r.sign_enclave(c,e);g.is_ok=!0,g.signature=y(C),o.signed_enclaves.push(g)}}return o}async pssSign(e,t,n,r){const l=await h.hsm().exportKey("pkcs8",r.privateKey),o=await h.hsm().importKey("pkcs8",l,{name:"RSA-PSS",hash:"SHA-256"},!1,["sign"]);let i=P(S(e),S(t),n),c=await h.hsm().sign({name:"RSA-PSS",saltLength:32},o,i);return new Uint8Array(c)}async regFinalMsg(e,t,n,r,l){const o=await this.pssSign(e.user_info.domain_name,e.user_info.user_name,t,n),i=await h.hsm().sign({name:"ECDSA",hash:"SHA-384"},r,o);let c=globalThis.crypto.getRandomValues(new Uint8Array(12));const d=await h.hsm().wrapKey("pkcs8",n.privateKey,l,{name:"AES-GCM",iv:c}),_=`${b(c)}.${b(d)}`;return{server_nonce:e.server_nonce,aead_data:e.aead_data,user_pub:y(t),user_pub_sig:y(o),oprf_pop_sig:y(i),aux_data:_}}async regInit(e,t,n){const{privateKey:r,publicKey:l}=n;u(r.type==="private"),u(l.type==="public");let o=await this.fetchDirectory(),i=await this.fetchEnclaveList(),c=await this.signEnclaves(r,l,i);await this.computeOprfClientData(e,t),t.auth_data=this.oprfClientData.clientRequestBytes,c.user_info=t,c.server_nonce=i.resp_challenge;let d=`${this.baseURL}${o.registration_init}`,_=await fetch(d,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(c)});return this.parseServerResponse(_)}async regFinal(e,t){const n=await this.fetchDirectory(),r=await this.oprfClient.finalize(e.user_info.auth_data,this.oprfClientData),{loginKey:l,publicKey:o}=await this.oprfClient.login_key(r,this.oprfClientData.hashed_password),i=await this.oprfClient.lockbox_key(r,this.oprfClientData.hashed_password),c=await this.regFinalMsg(e,o,t,l,i);let d=`${this.baseURL}${n.registration_finish}`;const _=JSON.stringify(c);let g=await fetch(d,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:_});return this.parseServerResponse(g)}}function $(s){const a=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!s.match(a))throw new R("Invalid domain prefix. Must be a valid domain component")}function H(s){if(s.length<8)throw new R("Invalid password. Must be at least 8 characters")}function I(s){}async function F(s,a,e,t,n){$(s),H(e);const r=n||await new h().sgx_rsa_key();let l={domain_name:s,user_name:a,auth_algo:"OPRF.P384-SHA384",auth_data:null,salt:null},o=new O(t);const i=await o.regInit(e,l,r);return o.regFinal(i,r)}export{O as default,F as register_user,$ as validateDomainStr,H as validateRawPasswordStr,I as validateUsernameStr};

var C=Object.defineProperty;var x=(s,a,e)=>a in s?C(s,a,{enumerable:!0,configurable:!0,writable:!0,value:e}):s[a]=e;var m=(s,a,e)=>(x(s,typeof a!="symbol"?a+"":a,e),e);import{a as u,i as f,b as v,c as D,U,t as y,f as w,e as T,d as P,u as S,g as b,V as R}from"./auth_base-f1c2b218.js";import{_ as E}from"./index-d2d906bb.js";const L=async(s,a="little")=>{u(s.algorithm.name==="RSASSA-PKCS1-v1_5");let e=await h.hsm().exportKey("jwk",s);u(!f(e.kty)&&!f(e.e)&&!f(e.n)&&(e.kty==="RSA"||e.kty==="rsa"));const t=v(e.e);return u(t.byteLength==1&&new DataView(t).getUint8(0)===3),v(e.n,a)},p=class p{constructor(){if(!globalThis.crypto||!globalThis.crypto.subtle)throw Error("Either this connection is not secure or the browser doesn't support WebCrypto")}static hsm(){return p.CRYPTO.subtle}uuid(){return p.CRYPTO.randomUUID()}async sgx_rsa_key(){if(D()==="Safari"){const{sgxCompatKey:a}=await E(()=>import("./compat-546ab388.js"),["assets/compat-546ab388.js","assets/auth_base-f1c2b218.js"]);return a(p.hsm())}else{const a=new Uint8Array([3]),e=["sign","verify"],t={name:"RSASSA-PKCS1-v1_5",modulusLength:3072,publicExponent:a,hash:"SHA-256"};return await p.hsm().generateKey(t,!0,e)}}async sign_enclave(a,e){return u(e.type==="private"),u(e.algorithm.name==="RSASSA-PKCS1-v1_5"),p.hsm().sign(e.algorithm.name,e,a)}async verify_enclave(a,e,t){return u(t.algorithm.name==="RSASSA-PKCS1-v1_5"),u(t.type==="public"),p.hsm().verify(t.algorithm.name,t,e,a)}};m(p,"CRYPTO",globalThis.crypto);let h=p;const A={attestation:"/v0/admin/attestation",registration_init:"/v0/admin/reg_init",enclave_list:"/v0/admin/enclaves",registration_finish:"/v0/admin/reg_finish",user_info:"/v0/admin/user_info"};class O extends U{constructor(e){super(e);m(this,"directory",null)}async fetchDirectory(){if(this.directory)return this.directory;try{const e=await fetch(this.discoveryURL,{mode:"cors",keepalive:!0});if(e.ok){let t=await e.json();this.directory=t.v0}else this.directory=A}catch{this.directory=A}return this.directory}async fetchEnclaveList(){let e=await this.fetchDirectory();const t=`${this.baseURL}${e.enclave_list}`,r=await fetch(t,{mode:"cors",keepalive:!0});return await this.parseServerResponse(r)}async signEnclaves(e,t,r){const i=new h;u(e.type==="private"),u(t.type==="public");let l=await L(t,"big"),o={user_info:null,server_nonce:null,signer_modulus:y(l),signed_enclaves:[]};for(let n of r.enclaves){const c=w(n.tbs_data),d=w(n.sighash),_=await h.hsm().digest("SHA-256",c);let g={is_ok:!1,signature:"",enclave_name:n.enclave_name,config:n.config};if(!T(d,_))g.signature="Enclave sighash and SHA256(to-be-signed) do not match.";else{const k=await i.sign_enclave(c,e);g.is_ok=!0,g.signature=y(k),o.signed_enclaves.push(g)}}return o}async pssSign(e,t,r,i){const l=await h.hsm().exportKey("pkcs8",i.privateKey),o=await h.hsm().importKey("pkcs8",l,{name:"RSA-PSS",hash:"SHA-256"},!1,["sign"]);let n=P(S(e),S(t),r),c=await h.hsm().sign({name:"RSA-PSS",saltLength:32},o,n);return new Uint8Array(c)}async regFinalMsg(e,t,r,i,l){const o=await this.pssSign(e.user_info.domain_name,e.user_info.user_name,t,r),n=await h.hsm().sign({name:"ECDSA",hash:"SHA-384"},i,o);let c=globalThis.crypto.getRandomValues(new Uint8Array(12));const d=await h.hsm().wrapKey("pkcs8",r.privateKey,l,{name:"AES-GCM",iv:c}),_=`${b(c)}.${b(d)}`;return{server_nonce:e.server_nonce,aead_data:e.aead_data,user_pub:y(t),user_pub_sig:y(o),oprf_pop_sig:y(n),aux_data:_}}async regInit(e,t,r){const{privateKey:i,publicKey:l}=r;u(i.type==="private"),u(l.type==="public");let o=await this.fetchDirectory(),n=await this.fetchEnclaveList(),c=await this.signEnclaves(i,l,n);await this.computeOprfClientData(e,t),t.auth_data=this.oprfClientData.clientRequestBytes,c.user_info=t,c.server_nonce=n.resp_challenge;let d=`${this.baseURL}${o.registration_init}`,_=await fetch(d,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:JSON.stringify(c),keepalive:!0});return this.parseServerResponse(_)}async regFinal(e,t){const r=await this.fetchDirectory(),i=await this.oprfClient.finalize(e.user_info.auth_data,this.oprfClientData),{loginKey:l,publicKey:o}=await this.oprfClient.login_key(i,this.oprfClientData.hashed_password),n=await this.oprfClient.lockbox_key(i,this.oprfClientData.hashed_password),c=await this.regFinalMsg(e,o,t,l,n);let d=`${this.baseURL}${r.registration_finish}`;const _=JSON.stringify(c);let g=await fetch(d,{method:"POST",mode:"cors",cache:"no-cache",headers:{"Content-Type":"application/json"},body:_,keepalive:!0});return this.parseServerResponse(g)}}function $(s){const a=/^[a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]$/g;if(!s.match(a))throw new R("Invalid domain prefix. Must be a valid domain component")}function H(s){if(s.length<8)throw new R("Invalid password. Must be at least 8 characters")}function I(s){}async function F(s,a,e,t,r){$(s),H(e);const i=r||await new h().sgx_rsa_key();let l={domain_name:s,user_name:a,auth_algo:"OPRF.P384-SHA384",auth_data:null,salt:null},o=new O(t);const n=await o.regInit(e,l,i);return o.regFinal(n,i)}export{O as default,F as register_user,$ as validateDomainStr,H as validateRawPasswordStr,I as validateUsernameStr};
